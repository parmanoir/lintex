<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>content editable</title>
	<style>
		body
		{
			font-size: 80%;
		}
		body > div
		{
			white-space: pre;
			height: 600px;
			overflow: auto;
			border: solid 1px #aaa;
			outline: none;
		}
		span
		{
			color: rgba(255, 0, 0, 0.5);
		}
</style>
</head>
<body>

	<div contentEditable='true' onchange='alert("s")'>
	// List launched applications
	var apps = [[NSWorkspace sharedWorkspace] launchedApplications]

	for (var i=0; i&lt;apps.length; i++)
		// option-right from next EOL
		log(apps[i].NSApplicationName)	


	// Instead of using alloc/init and releasing ...
	var url = [[NSURL alloc] initFileURLWithPath:"/tmp" isDirectory:true]
	[url release]
	// Replace 'init' in the method name with 'instance' to get an object managed by JavascriptCore
	var url = [NSURL instanceFileURLWithPath:"/tmp" isDirectory:true]
	// Mark object as collectable
	url = null


	// Mix and match ObjJ and Javascript syntax
	var a = [NSArray arrayWithObjects:'hello', [7, 8, 9], 'world']
	log('a[1][2]=' + [[a objectAtIndex:1] objectAtIndex:2])
	log('a[1][1]=' + [a[1] objectAtIndex:1])
	log('a[1][0]=' + a[1][0])


	// Syntactic sugar for selector notation
	var o = [SomeObject instance]
	[o performSelector:@selector(doStuff:) withObject:anObject afterDelay:500]
	
	
	//
	// Define a Cocoa class in Javascript
	//	It can then be used from Javascript or Cocoa (use it as a delegate class, create a new NSView, ...)
	//
	class MyObject < NSObject
	{
		// Find objects containing at least one capital letter
		- (NSArray*)findObjectsInArray:(NSArray*)array
		{
			return array.filter(function (elt) { return elt.match(/[A-Z]/) })
		}
		// Use radix = 16 to parse hex
		// Use radix = 36 to parse a Reddit story number
		- (NSNumber*)parseNumberInString:(NSString*)str withRadix:(int)radix
		{
			return parseInt(str, radix)
		}
		// NSApplication delegate method
		- (void)applicationWillBecomeActive:(NSNotification *)notification
		{
			log('Hello ! ' + notification.name)
		}
	}

	// Instance our new class
	var obj = [MyObject instance]
	log([obj parseNumberInString:'9q5vm' withRadix:'36'])
	// Register it as application delegate
	[NSApplication sharedApplication].delegate = obj


	//
	// Swizzle a method from an existing class
	//
	class NSButton
	{
		swizzle - (void)drawRect:(NSRect)rect
		{
			// Call original method
			this.Original(arguments)
			log('drawRect: called on button ' + this)
		}
	}


		
<span>The <b>result <i>rapidly</i> bec</b>omes an unmaintainable mess
</span><span>The <b>result <i>rapidly</i> bec</b>omes an unmaintainable <span contentEditable='false'>NO</span>mess
</span><span>The <b>result <i>rapidly</i> bec</b>omes an unmaintainable mess
</span>

function a(b, c)
{
	if (b)			<span contentEditable='true'>l</span>
<span contentEditable='true'>l</span>	c()
}
		
<span>I am working on <span>a systems <span>integration</span> project</span> that has gotten itself into what I call a SpaghettiArchitecture? - a bunch of (generally small) programs that connect one database to another, or one app to another, and so on. This has been a result of DoTheSimplestThingThatCouldPossiblyWork. "Well, we need to get this data over there." "Oh, just write a little batch transfer program." The result rapidly becomes an unmaintainable mess - everything depends on everything else, the business logic is scattered, and there's not even a single codebase to RefactorMercilessly.</span>

So perhaps we can say that DoTheSimplestThingThatCouldPossiblyWork is a reasonable approach within a single program or codebase (provided, of course, that we RefactorMercilessly and UnitTest to keep it from becoming FlimsyAndBarelyFunctional). But on an architectural level, it is absolutely necessary to do a BigDesignUpFront (or at least a SmallDesignUpFront?) - put the right architectural components in place, plan for future expansion, decide how we're going to let our different apps and programs be loosely coupled, and so on. -- RobertEikel

This doesn't sound like DoTheSimplestThingThatCouldPossiblyWork at all to me. It sounds a lot more like DoTheQuickestThingThatMightWorkForAWhile. Programs were simply plugged in without any particular thought to the overall picture. I've never read or heard of anything in XP that says this is a good idea.
	</div>


	<script>
		function	f()
		{
			var n = document.getElementsByTagName('DIV')[0]
			n.focus()
				var s = getSelection()
				s.collapseToStart()
			
		}
		setTimeout(f, 10)



			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}


		function O()
		{
			this.a = 'foo'
		}
		O.prototype = { get test(){ return this.a },
						set test(v) { this.a = v } }
		var o = new O
		o.test = 'foo2'
//		alert(o.test)
//		alert(dumpHash(O.prototype))
		
		
//		var a = { get test(){ return "foo"; }}
//		alert(a.test)
	</script>



</body>
</html>
