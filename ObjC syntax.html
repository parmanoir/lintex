<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>ObjC Syntax</title>
	<style>
	
		table
		{
			width: 100%;
		}
		tr > td:first-child
		{
			width: 30%;
		}
		td
		{
			border: solid 1px #eee;
			vertical-align: top;
		}
		#dump
		{
			font-size: 80%;
			white-space: pre-wrap;
			font-family: monaco;
		}
		textarea
		{
			width: 100%;
			height: 400px;
			white-space: pre-wrap;
		}
		#transformed
		{
			font-size: 80%;
			white-space: pre-wrap;
			efont-family: monaco;
			background-color: #eee;
		}
		.objc
		{
			color: blue;
			font-weight: bold;
		}
		.firstobjc
		{
			color: red;
			font-weight: bold;
		}
		.objcopener
		{
			color: lime;
			font-weight: bold;
		}
		.objccloser
		{
			color: orange;
			font-weight: bold;
		}
		.objcopenerandcloser
		{
			ebackground-color: lime;
			text-shadow: lime 1px 0px 0px, lime -1px 0px 0px;
			font-weight: bold;
		}
		.objcparamsep
		{
			background-color: #faa;
		}
		.objcparamcountopener
		{
			efont-weight: bold;
			background-color: #fea;
		}
		.objcparamcountcloser
		{
			efont-weight: bold;
			background-color: #fea;
			border: solid 1px #f64;
		}
		
		.lintError
		{
			background: -webkit-gradient(linear, left top, left bottom, to(rgba(255, 255, 255, 1)), from(rgba(255, 0, 0, 0.3)));
		}
		
		#dump2
		{
			font-size: 40%;
			white-space: pre-wrap;
			font-family: monaco;
		}
		
		#dump3
		{
			white-space: pre-wrap;			
		}
		
		.linestartspace
		{
			background-color: lime;
		}
		.interspace
		{
			background-color: orange;
		}
</style>
</head>
<body>
	<script src='jslint-jscocoa.js'></script>
	<script src='lintex.js'></script>
<table><tr><td>
<!--
<textarea estyle='display: none'>
	var a = 4 {+} 5 {+} 'hello'
	var b = 564 {+} { blah : 'hello' } {+} 'world'
</textarea>
	var e = 'a' [+] ['b'] [+] 'c'
	var f = 'a' [+] ['b'] [+] +4
</textarea>
	var f = 2 + [4] + [5] * 8
	var g = 'a' {+} { 'hello' : 'world' } {+} 'z'
</textarea>
	var a = 4 [+] 5 {+} 'hello'
	var b = 4 [+] 5+8 [+] 8*2 [+] 'hel\'lo'
	var c = 'hello' {+} 'wo'+'rld' {+} 'end'
	
	var d = 'a' [+]
				'b'
					[+]
						8
							[+]
								'd'

-->
<textarea estyle='display: none'>


	@implementation ObjJClassSyntax1 : NSObject
		- (int)method1:(int)a and2:(int)b
		{
			wentThrough1 = true
			return a+b+1
		}
	@end


	@implementation ObjJClassSyntax2 : ObjJClassSyntax1
	{
		int		var1
		float	var2, var3
	}

		- (int)method1:(int)a and2:(int)b
		{
			wentThrough1 = true
			return a+b+1
		}
	@end

	@implementation ObjJClassSyntax3 (Blah)
	- (void)hello
	{
		
	}
	@end
	
	
	// name + parameters
	// function name(a, b) { ... }
	var f0 = ƒ nameAndParams(a, b)
	{
		return a+b
	}
	
	// name
	// function name() { ... }
	var f1 = ƒ name
	{
		return 'hello'
	}
	
	// params
	// function (a, b) { ... }
	var f2 = ƒ (a, b)
	{
		return a*b
	}
	
	// no name, no params
	var f3 = ƒ
	{
		return 'world'
	}
	
	
	
[NSArray arrayWithObjects:1, 2, 3]
[variadic test2:'ehllo' blah:'hello', 'world']
[variadic test3:'ehllo' andtherealso:'mlkre' blah3:'hello', 'world']
var a = [o class]
	class MyClass < NSView
	{
		// a method
		- (void)hello:(NSView*)world 
			andOthers:(SomeObject*)w
		{
			a = 2
			return if (!z)
			b = 3
			return unless (z)
			
			[super hello:'a' andOthers:'w']
			[original hello:'a' andOthers:'w']
			
			return 'errere'+[[a b]] unless (z + [hello world:'a' and:'b'])
			
			return function (a, b){ return a+b }(3,4) if (true)
	
	[o wantInt:7 andNSArray:[8, [NSString stringWithString:'hello'], [NSArray arrayWithObjects:1, 2, 3], [4, 5, 6]] andFloat:1.23]
		

			return @'hello' + @"hello"
		}
		
		function blah(a, b, c)
		{
			return 'must be part of class'
		}
		
		ƒ hello(y, z)
		{
			return y*z
		}
		
/* 1*/		+ (int)hop /* 2 */
		{
			return 4 + @selector(blah:hop:HEP:) + 15
		}
		- (NSRect)addRect:(NSRect)rect1 andRect:(NSRect)rect2
		{
			return	new NSRect(	 rect1.origin.x+rect2.origin.x
								,rect1.origin.y+rect2.origin.y
								,rect1.size.width+rect2.size.width
								,rect1.size.height+rect2.size.height)
		}
		
		Key sourceValue
		IBOutlet outlet2 (newValue)
		{
			passedOutlet2 = true
		}

		IBOutlet blah
		IBAction hop
		{
			
		}
		IBAction hop2(notifier)		{
			
		}
		swizzle - (void)drawRect:(NSRect)rect // 4
		{
			[[NSWorkspace sharedWorkspace] doStuff]
		}
	}
		var a, b, p = [a, b]
		var o = [[NSObject alloc] init]
		[this performSelector:'hello' withObject:2*6/3-Math.round(6) afterDelay:'HOP']
		
		var c = [someObject doThis] + [someOtherObject handle1:[a1, [d1 doThis]] and2:b1] + [object2 perform:'hello']
		var d = a + c
		
		var chainedCall = [[NSObject allocWith:'hello' and:'world'] initWithKey:[SomeKey someParam] andKey:[SomeOtherKey p1:'a' p2:'b'] andLastKey:'last'] // hep 
		
		var c2 = [call withA:'a'
						B:'b'
						C:'c'
						D:'d'] /* hello */
	
	class OtherClass < MyClass /* check */
	{
		// Test some more swizzle in here
		- (void)a /* blah */
		{
			[[NSWorkspace sharedWorkspace] doStuff]
		}
	}

		var array = [[NSObject alloc]]
		var obj1 = [[[NSObject alloc]][0] init]
		var obj2 = [[[[NSObject alloc]][0] init] keys][0]
		var obj3 = [[[[NSObject alloc]][0] init] keys]['name']
		[[[NSObject alloc] init]]     
		[array[0] init]
		var a2 = { 'hello' : [[NSObject alloc] init] }
		[hash['value'] doSomethingElse]


	var view = [[NSView alloc] 
			initWithSomething:'he' 
			andSomethingElse:'b' 
			andThatAgain:[1, 2, 3]]
	var view2 = [[NSView alloc]]
	var view3 = [[[[[NSView alloc] initWithFrame:'blah']]]]
	var view4 = [[[[[NSView alloc] initWithFrame:'blah'] andDoStuff1:'there' also2:'lk']]]
</textarea>
<textarea style='display: none'>
		var a, b, p = [a, b]
		var o = [[NSObject alloc] init]
		[this performSelector:'hello' withObject:2*6/3-Math.round(6) afterDelay:'HOP']
		
		var c = [someObject doThis] + [someOtherObject handle1:[a1, [d1 doThis]] and2:b1] + [object2 perform:'hello']
		var d = a + c
		
		var chainedCall = [[NSObject allocWith:'hello' and:'world'] initWithKey:[SomeKey someParam] andKey:[SomeOtherKey p1:'a' p2:'b'] andLastKey:'last']
		
		var c2 = [call withA:'a'
						B:'b'
						C:'c'
						D:'d']

		//
		var array = [[NSObject alloc]]
		var obj1 = [[[NSObject alloc]][0] init]
		var obj2 = [[[[NSObject alloc]][0] init] keys][0]
		var obj3 = [[[[NSObject alloc]][0] init] keys]['name']
		[[[NSObject alloc] init]]     
		[array[0] init]
		var a2 = { 'hello' : [[NSObject alloc] init] }
		[hash['value'] doSomethingElse]


	var view = [[NSView alloc] initWithSomething:'he' andSomethingElse:'b' andThatAgain:[1, 2, 3]]
	var view2 = [[NSView alloc]]
	var view3 = [[[[[NSView alloc] initWithFrame:'blah']]]]
	var view4 = [[[[[NSView alloc] initWithFrame:'blah'] andDoStuff1:'there' also2:'lk']]]

</textarea>

<script>
	var classNames = ['objc', 'firstobjc', 'objcopener', 'objccloser', 'objcopenerandcloser', 'objcparamsep', 'objcparamcountopener', 'objcparamcountcloser']
	var str = ''
	var a = []
	for (var i=0; i<classNames.length; i++)
	{
		var c = classNames[i]
		var str = '<span class="' + c + '">' + c + '</span>'
		a.push(str)
	}
	document.write('<p>classes=' + a.join(' &#160;') + '</p>')
</script>
	<div id='dump2'></div>

<td>
<div id='transformed'></div>
	<div id='dump'></div>
	<div id='dump3'></div>
</table>

	<script>

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}
			function	dumpHashNoFunction(o)
			{
				var str = ''
				for (var i in o) { if (typeof o[i] == 'function') continue; str += i + '=' + (o[i].toString == 'toStringToken' in this ? ('*TOKEN*'+o[i].value + '*') : o[i]) + '\n' }
				return str
			}


		//
		// JSLint logging
		// 
		var tokens
		function	logToken(token)
		{
//				alert(dumpHashNoFunction(token))
				
				
//			if (lines[token.line])	token.rawValue = lines[token.line].substr(token.from, token.character-token.from)				
//			else					token.rawValue = ''

			tokens.push(token)
//			dump.innerHTML += ' ' + token.value
//			dump.innerHTML += '\n'
//			alert(dumpHash(token))
//			if (token.id == '(endline)') dump.innerHTML += '\n\n'
		}
		function	logStatement(statement)
		{
		}

		function	logParseStart(rbp, initial)
		{
			
		}
		function	logParseEnd(rbp, initial)
		{
			
		}

		function	logFunctionStart(startToken)
		{
//			functionLines.push(startToken.line)
		}
		function	logFunctionEnd(startToken, endToken)
		{
		}
		
		function	logObjCStart()
		{
//			dump.innerHTML += '\n***OBJC***'
		}
		
		//
		// Dump tokens
		// 
		
		function	tokenizeObjC(tokens)
		{
			var str = ''
			var str2 = ''
			
			var currentParameterCount
			var tokenStream		= []
			var token, prevtoken= tokens[0]
			for (var i=0; i<tokens.length; i++)
			{
				token = tokens[i]
				var v = tv = token.rawValue
				
				var line = lines[token.line]
				if (!line) continue
				
				if (token.id == '(endline)')
				{
					tokenStream.push('\n')
					continue
				}
				
				// Add whitespace - either the start of the line if we switched lines, or the span between this token and the previous one
				var whitespace = prevtoken.line != token.line ? line.substr(0, token.from) : line.substr(prevtoken.character, token.from-prevtoken.character)
				tokenStream.push(String(whitespace.match(/\s*/)))

				prevtoken = token

				// Handle shortcut function token
				if (token.value == 'ƒ')
				{
					token.rawValue = 'function'
					
					// Add parens if they're missing
					if (tokens[i+1].type == '(identifier)')
					{
						if (tokens[i+2].value != '(')	tokens[i+1].rawValue += '()'
					}
					else
						if (tokens[i+1].value != '(')	tokens[i].rawValue += '()'
				}

				// Handle ObjC classes
				if (token.isObjCClassStart)
				{
					if (tokens[i+2].value == '<' || tokens[i+2].value == ':')
					{
						tokenStream.push("Class('" + tokens[i+1].value + ' < ' + tokens[i+3].value + "').definition = function ()")
						i += 3
					}
					else
					{
						tokenStream.push("Class('" + tokens[i+1].value + "').definition = function ()")
						i += 1
					}
					if (token.value == 'implementation')	tokenStream.push('{\n')
					continue
				}
				// Class var list @implementation Class : ParentClass { var list }
				if (token.isObjCVarList)
				{
					while (token && token.value != '}')
					{
						i++
						token = tokens[i]
						if (!token)	return false
					}
					i++
					continue
				}
				// Class category
				if (token.isObjCCategory)
				{
					while (token && token.value != ')')
					{
						i++
						token = tokens[i]
						if (!token)	return false
					}
					i++
					continue
				}
				// Handle ObjC methods
				if (token.isObjCClassItemStart)
				{
					var methodToken = token
					var dataHolder = token
					var isSwizzle = false
					if (token.value.toLowerCase() == 'swizzle')
					{
						methodToken = token = tokens[++i]
						isSwizzle = true
					}
					// Method start
					if (token.value == '-' || token.value == '+')
					{
						// Skip method definition
						while (tokens[i+1] && tokens[i+1].value != '{')
							i++

						var str = "('" + dataHolder.objCMethodName + "').encodingArray([" + dataHolder.objCMethodEncodings + "]).fn = function (" + dataHolder.objCMethodParamNames + ")"
						str = (isSwizzle ? 'Swizzle' : '') + (methodToken.value == '-' ? 'Method' : 'ClassMethod') + str
						tokenStream.push(str)
						continue
					}
					else
					// Outlet
					if (token.value == 'IBOutlet')
					{
						tokenStream.push("IBOutlet('" + tokens[i+1].value + "')")
						if (tokens[i+2].value == '(')
						{
							tokenStream.push('.setter = function (' + tokens[i+3].value + ')')
							i += 3
						}
						i += 1
						continue
					}
					else
					// Action
					if (token.value == 'IBAction')
					{
						var actionName = tokens[i+1].value
						
						var paramName = 'sender'
						if (tokens[i+2].value == '(')
						{
							paramName = tokens[i+3].value
							i += 3
						}

						tokenStream.push("IBAction('" + actionName + "').fn = function (" + paramName + ")")
						i += 1
						continue
					}
					else
					// Key
					if (token.value == 'Key')
					{
						tokenStream.push("Key('" + tokens[i+1].value + "')")
						i += 1
						continue
					}
					else
					// js function
					if (token.isClassJSFunction)
					{
						tokenStream.push("JSFunction('" + token.jsFunctionName.rawValue + "').fn = ")
						token.jsFunctionName.rawValue = ''
					}
				}
				else
				// String immediates, selectors
				if (token.id == '@')
				{
					if (tokens[i+1].value == 'implementation')	continue
					if (tokens[i+1].value == 'end')	
					{
						i++
						tokenStream.push('}\n')
						continue
					}
					
					var nexttoken = tokens[i+1]
					if (nexttoken.id == '(string)')
					{
						tokenStream.push('NSString.stringWithString(' + nexttoken.rawValue + ')')
						i += 1
						continue
					}
					else
					{
						tokenStream.push("'" + tokens[i+3].rawValue + "'")
						i += 4
						continue						
					}
				}
				else
				// If return
				if (token.isIfReturn)
				{
					token.isIfReturn = false
					
					var j = i
					var returnOpenerIndex = i-1
					// Skip return tokens
					while (tokens[j+1] && !tokens[j+1].isIfReturnOpener) j++
					var ifReturnOpenerIndex = j+1
					// Skip if tokens
					while (tokens[j] && !tokens[j].isIfReturnCloser) j++
					var ifReturnCloserIndex = j
					
					// Switch unless (...) to if (!(...))
					if (tokens[ifReturnOpenerIndex].value == 'unless')
					{
						tokens[ifReturnOpenerIndex].rawValue = 'if'
						tokens[ifReturnOpenerIndex+1].rawValue = '(!' + tokens[ifReturnOpenerIndex+1].rawValue
						tokens[ifReturnCloserIndex].rawValue += ')'
					}

					// Splice : delete index, delete item count, replacement
					var r = tokens.splice(i, ifReturnOpenerIndex-returnOpenerIndex-1)
//					token.rawValue = '<b style="background-color: lime">' + token.rawValue + '</b>'

					// Push delete item count and delete index on top of replacing tokens
					r.unshift(0)
					r.unshift(i+ifReturnCloserIndex-ifReturnOpenerIndex+1)
					Array.prototype.splice.apply(tokens, r)

					token = tokens[i]
				}
				

/*
				var c = ''
				if (token.isObjCCall)			c += ' objc'
				if (token.isObjCFirstCall)		c += ' firstobjc'
				if (token.isObjCCallOpener)		c += ' objcopener'
				if (token.isObjCCallCloser) 	c += ' objccloser'
				if (token.isObjCCallCloser && token.isObjCFirstCall) c += ' objcopener objccloser objcopenerandcloser'
				if (token.isObjCParameterSeparator)	c += ' objcparamsep'
				v = '<span class="' + c + '">' + tv + '</span>'
				
//				str += ' ' + v
				str += ' ' + v
				var isCallOpener = 'objCParameterCountOpener' in token
				var isCallCloser = 'objCParameterCountCloser' in token
				if (isCallCloser)	str += '<span class="objcparamcountcloser">' + token.objCParameterCountCloser + '&gt;</span>'
				if (isCallOpener)	str += '<span class="objcparamcountopener">&lt;' + token.objCParameterCountOpener + '</span>'
//				if (isCallOpener && isCallCloser)	str += '<span class="objcparamcount"> </span>'

				//			alert(dumpHash(token))
*/				
				var v = token.rawValue
				//
				// ObjC message handling
				//
				
				// Skip '[' and ':'
				if (token.isObjCCallOpener || token.isObjCParameterSeparator) continue

				if (token.isObjCCallCloser && token.isObjCFirstCall) v = ''

				// Instance : add '.' to get method
				if (token.isObjCFirstCall)
				{
					if (token.isObjCSuperCall)	v = 'this.' + (token.value=='super'?'Super':'Original') + '(arguments, '
					currentParameterCount = token.objCParameterCountOpener
					// Special case for 'class', must be bracketed ['class']
					if (tokens[i+1].rawValue != 'class' && !token.isObjCSuperCall)
						v += '.'
				}
				// Special case for class
				if (token.isObjCCall && token.rawValue == 'class')	v = "['class']"
				// First selector part : retrieve full selector name
				if (token.isObjCFirstParam && currentParameterCount)
				{
					v = token.objCJSSelector
					if (token.isObjCSuperCall)	v = "'" + v.replace(/_/g, ':') + "', new Array"
					v += '('
				}
				// Selector part : ignore name and add ',' separator
				if (token.isObjCMultiCall)
				{
					v = ''
					if (!token.isObjCCallCloser) 
						v += ','
				}
				// Ignore ']', add ')' if we're closing a parameter message
				if (token.isObjCCallCloser)
				{
					if (!token.isObjCFirstCall)
						v = ''
				 	if (token.objCParameterCountCloser)
						v = ')' + (v||'')
					if (token.isObjCSuperCall) v += ')'
				}
				tokenStream.push(v)
			}
			str2 = tokenStream.join('')
			dump2.innerHTML = getTickCount() + '\n' + str
			transformed.innerHTML = getTickCount() + '\n' + str2
			
			
			return tokens
		}

		function	tokenizeOperators(tokens)
		{
			var str = ''
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				var v = tv = token.value
if (!lines[token.line])	continue
				str += v
				var v2 = lines[token.line].substr(token.from, token.character-token.from)
				str += ' <span style="color: blue">*' + v2 + '*</span> '
				var operandCount = 0
				if (token.left) operandCount++, str += ' l=' + token.left.value
				if (token.right) operandCount++, str += ' r=' + token.right.value
				if (operandCount == 1)	str += ' <span style="color: red">missingop</span>'
				if (token.arity)	str += ' <b>' + token.arity + '</b>'
//				if (token.left)	alert(dumpHash(token)), eaz()
				str += '\n'
			}
			
			var operatorFunctions = { '{+}' : '__addHash', '[+]' : '__addArray' }
			var ops = []
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				if (operatorFunctions[token.id])
				{
					ops.push(token)
					var op = operatorFunctions[token.id]
					token.replacedValue = ','
					
					var left, right
					var t = token
					while (t)
					{
						if (t.left) left = t.left
						t = t.left
					}
					var t = token
					while (t)
					{
						if (t.right) right = t.right
						t = t.right
					}
					
					
					if (left && right)
					{
						var v = left.replacedValue || left.rawValue
						left.replacedValue = op + '(' + v
						var v = right.replacedValue || right.rawValue
						right.replacedValue = v + ')'
					}
				}
//				alert('lk')
			}

			var str2 = ''
			
			var evalMe = ''
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				var v = token.replacedValue || token.rawValue
				
//				str2 += v + ' '
//				if (token.id == '(endline)') str2 += '<br>'
				evalMe += v + ' '
				if (token.id == '(endline)') evalMe += '\n'
			}
			str2 += evalMe
//			str2 += '<textarea>' + evalMe + '</textarea>'
			str += '<hr>' + str2 + '<hr>'
			
			try
			{
				var identifierTokens = []
				for (var i=0; i<tokens.length; i++) if (tokens[i].type == '(identifier)') identifierTokens.push(tokens[i])

				evalMe = '{\n' + evalMe + '\n}'
//				var f = new Function(evalMe)
//				var r = f()
				var r = eval(evalMe)
				
				str += '<hr><div style="color: green;">'
				str += '<b>eval OK</b>'
				for (var i=0; i<identifierTokens.length; i++)
				{
					var id = identifierTokens[i].value
					var v = eval(id)
					str += '<br><br>' + id + '=' + v
					var d = dumpHash(v)
					if (d) str += ' (' + d + ')'
				}
				str += '</div>'
			}
			catch(e)
			{
				str += '<hr><div style="color: red; font-weight: bold">eval failed<br>' + dumpHash(e) + '</div>'
			}

//			dump.innerHTML = getTickCount() + '\n' + str
			
//			alert('go through tokens, register ops - sort by binding power, then replace them for highest to lowest')
			/*
				add token number in token ?
			*/
		}
		
		function	__addArray(a, b)
		{
			var r = []
			if (a.constructor != Array.prototype.constructor)	a = [a]
			if (b.constructor != Array.prototype.constructor)	b = [b]
			for (var i=0; i<a.length; i++) r.push(a[i])
			for (var i=0; i<b.length; i++) r.push(b[i])
			return r
		}
		
		function	__addHash(a, b)
		{
			var r = {}
			if (a.constructor != Object.prototype.constructor)	{	var o = {}; o[a] = true; a = o }
			if (b.constructor != Object.prototype.constructor)	{	var o = {}; o[b] = true; b = o }
			for (var i in a) r[i] = a[i]
			for (var i in b) r[i] = b[i]
			return r
		}


		//
		// 
		// 
		var dump = document.getElementById('dump')
		var dump2 = document.getElementById('dump2')
		var transformed = document.getElementById('transformed')
		
		var textarea = document.getElementsByTagName('TEXTAREA')[0]

		var lines
		function	lint()
		{
			var src = textarea.value
			lines = src.split('\n')
		
			dump.innerHTML = getTickCount()

			tokens = []
			var options = { forin : true, laxbreak : true, indent : true }
			var lintRes = jslint(lines, options)
		
			var str = 'LINT=' + lintRes
			document.documentElement.className = JSLINT.errors.length ? 'lintError' : ''
//			if (JSLINT.errors) JSLINT.errors.pop()
			for (var i=0; i<JSLINT.errors.length; i++)
			{
				var e = JSLINT.errors[i]
				if (!e)	continue
				str += '\n<span style="color: red">' + dumpHash(e) + '</span>'
			}
			dump3.innerHTML = '<hr>' + str

			try
			{
			tokens = tokenizeObjC(tokens)
			tokens = tokenizeOperators(tokens)
			}
			catch(e)
			{
				dump.innerHTML = '<span style="color: red">' + dumpHash(e) + '</span>'
			}
//			dumpTokens()
//			dumpTokens2()
		}

		var logs = { logToken : logToken }
		var JSLINT = JSLintWithLogs(logs)
		var jslint = JSLINT()


		lint()
		
		function	keyup()
		{
			setTimeout(lint, 0)
		}
//		textarea.onkeyup = keyup
		
		setTimeout(function () { document.getElementsByTagName('TEXTAREA')[0].focus() }, 10)
	</script>

<pre>	
	var array = [[NSObject alloc]]

	var obj = [[[NSObject alloc]][0] init]
	var obj = [[[[NSObject alloc]][0] init] keys][0]

	-> un immediate de [NSObject.alloc()]
	[[[NSObject alloc] init]]     
	[array[0] init]
	
	

<pre style='color: red'>
	* GUARANTEE SELECTOR TO BE [A-Za-z_]\w+
	
</body>
</html>
