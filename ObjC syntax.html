<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>ObjC Syntax</title>
	<style>
	
		table
		{
			width: 100%;
		}
		tr > td:first-child
		{
			width: 30%;
		}
		td
		{
			border: solid 1px #eee;
			vertical-align: top;
		}
		#dump
		{
			font-size: 80%;
			white-space: pre-wrap;
			font-family: monaco;
		}
		textarea
		{
			width: 100%;
			height: 400px;
			white-space: pre-wrap;
		}
		#transformed
		{
			font-size: 80%;
			white-space: pre-wrap;
			efont-family: monaco;
			background-color: #eee;
		}
		.objc
		{
			color: blue;
			font-weight: bold;
		}
		.firstobjc
		{
			color: red;
			font-weight: bold;
		}
		.objcopener
		{
			color: lime;
			font-weight: bold;
		}
		.objccloser
		{
			color: orange;
			font-weight: bold;
		}
		.objcopenerandcloser
		{
			ebackground-color: lime;
			text-shadow: lime 1px 0px 0px, lime -1px 0px 0px;
			font-weight: bold;
		}
		.objcparamsep
		{
			background-color: #faa;
		}
		.objcparamcountopener
		{
			efont-weight: bold;
			background-color: #fea;
		}
		.objcparamcountcloser
		{
			efont-weight: bold;
			background-color: #fea;
			border: solid 1px #f64;
		}
		
		.lintError
		{
			background: -webkit-gradient(linear, left top, left bottom, to(rgba(255, 255, 255, 1)), from(rgba(255, 0, 0, 0.3)));
		}
		
		#dump2
		{
			font-size: 40%;
			white-space: pre-wrap;
			font-family: monaco;
		}
		
		#dump3
		{
			white-space: pre-wrap;			
		}
</style>
</head>
<body>
	<script src='crockford/jslint-jscocoa.js'></script>
	<script src='lintex.js'></script>
<table><tr><td>
<!--
<textarea estyle='display: none'>
	var a = 4 {+} 5 {+} 'hello'
	var b = 564 {+} { blah : 'hello' } {+} 'world'
</textarea>
	var e = 'a' [+] ['b'] [+] 'c'
	var f = 'a' [+] ['b'] [+] +4
</textarea>
	var f = 2 + [4] + [5] * 8
	var g = 'a' {+} { 'hello' : 'world' } {+} 'z'
</textarea>
	var a = 4 [+] 5 {+} 'hello'
	var b = 4 [+] 5+8 [+] 8*2 [+] 'hel\'lo'
	var c = 'hello' {+} 'wo'+'rld' {+} 'end'
	
	var d = 'a' [+]
				'b'
					[+]
						8
							[+]
								'd'

-->
<textarea estyle='display: none'>
	class MyClass < NSView
	{
		// a method
		- (void)hello:(NSView*)world andOthers:(SomeObject*)w
		{
			return @'hello' + @"hello"
		}
/* 1*/		+ (int)hop /* 2 */
		{
			return 4 + @selector(blah:hop:HEP:)
		}
		IBOutlet blah
		IBAction hop
		{
			
		}
		IBAction hop2(notifier)		{
			
		}
		swizzle - (void)drawRect:(NSRect)rect // 4
		{
			[[NSWorkspace sharedWorkspace] doStuff]
		}
	}
		var a, b, p = [a, b]
		var o = [[NSObject alloc] init]
		[this performSelector:'hello' withObject:2*6/3-Math.round(6) afterDelay:'HOP']
		
		var c = [someObject doThis] + [someOtherObject handle1:[a1, [d1 doThis]] and2:b1] + [object2 perform:'hello']
		var d = a + c
		
		var chainedCall = [[NSObject allocWith:'hello' and:'world'] initWithKey:[SomeKey someParam] andKey:[SomeOtherKey p1:'a' p2:'b'] andLastKey:'last']
		
		var c2 = [call withA:'a'
						B:'b'
						C:'c'
						D:'d']
	
	class OtherClass < MyClass
	{
		// Test some more swizzle in here
		- (void)a
		{
			[[NSWorkspace sharedWorkspace] doStuff]
		}
	}

		var array = [[NSObject alloc]]
		var obj1 = [[[NSObject alloc]][0] init]
		var obj2 = [[[[NSObject alloc]][0] init] keys][0]
		var obj3 = [[[[NSObject alloc]][0] init] keys]['name']
		[[[NSObject alloc] init]]     
		[array[0] init]
		var a2 = { 'hello' : [[NSObject alloc] init] }
		[hash['value'] doSomethingElse]


	var view = [[NSView alloc] initWithSomething:'he' andSomethingElse:'b' andThatAgain:[1, 2, 3]]
	var view2 = [[NSView alloc]]
	var view3 = [[[[[NSView alloc] initWithFrame:'blah']]]]
	var view4 = [[[[[NSView alloc] initWithFrame:'blah'] andDoStuff1:'there' also2:'lk']]]
</textarea>
<textarea style='display: none'>
		var a, b, p = [a, b]
		var o = [[NSObject alloc] init]
		[this performSelector:'hello' withObject:2*6/3-Math.round(6) afterDelay:'HOP']
		
		var c = [someObject doThis] + [someOtherObject handle1:[a1, [d1 doThis]] and2:b1] + [object2 perform:'hello']
		var d = a + c
		
		var chainedCall = [[NSObject allocWith:'hello' and:'world'] initWithKey:[SomeKey someParam] andKey:[SomeOtherKey p1:'a' p2:'b'] andLastKey:'last']
		
		var c2 = [call withA:'a'
						B:'b'
						C:'c'
						D:'d']

		//
		var array = [[NSObject alloc]]
		var obj1 = [[[NSObject alloc]][0] init]
		var obj2 = [[[[NSObject alloc]][0] init] keys][0]
		var obj3 = [[[[NSObject alloc]][0] init] keys]['name']
		[[[NSObject alloc] init]]     
		[array[0] init]
		var a2 = { 'hello' : [[NSObject alloc] init] }
		[hash['value'] doSomethingElse]


	var view = [[NSView alloc] initWithSomething:'he' andSomethingElse:'b' andThatAgain:[1, 2, 3]]
	var view2 = [[NSView alloc]]
	var view3 = [[[[[NSView alloc] initWithFrame:'blah']]]]
	var view4 = [[[[[NSView alloc] initWithFrame:'blah'] andDoStuff1:'there' also2:'lk']]]

</textarea>

<script>
	var classNames = ['objc', 'firstobjc', 'objcopener', 'objccloser', 'objcopenerandcloser', 'objcparamsep', 'objcparamcountopener', 'objcparamcountcloser']
	var str = ''
	var a = []
	for (var i=0; i<classNames.length; i++)
	{
		var c = classNames[i]
		var str = '<span class="' + c + '">' + c + '</span>'
		a.push(str)
	}
	document.write('<p>classes=' + a.join(' &#160;') + '</p>')
</script>
	<div id='dump2'></div>

<td>
<div id='transformed'></div>
	<div id='dump'></div>
	<div id='dump3'></div>
</table>

	<script>

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}
			function	dumpHashNoFunction(o)
			{
				var str = ''
				for (var i in o) { if (typeof o[i] == 'function') continue; str += i + '=' + (o[i].toString == 'toStringToken' in this ? ('*TOKEN*'+o[i].value + '*') : o[i]) + '\n' }
				return str
			}


		//
		// JSLint logging
		// 
		var tokens
		function	logToken(token)
		{
//				alert(dumpHashNoFunction(token))
				
				
			if (lines[token.line])	token.rawValue = lines[token.line].substr(token.from, token.character-token.from)				
			else					token.rawValue = ''

			tokens.push(token)
//			dump.innerHTML += ' ' + token.value
//			dump.innerHTML += '\n'
//			alert(dumpHash(token))
//			if (token.id == '(endline)') dump.innerHTML += '\n\n'
		}
		function	logStatement(statement)
		{
		}

		function	logParseStart(rbp, initial)
		{
			
		}
		function	logParseEnd(rbp, initial)
		{
			
		}

		function	logFunctionStart(startToken)
		{
//			functionLines.push(startToken.line)
		}
		function	logFunctionEnd(startToken, endToken)
		{
		}
		
		function	logObjCStart()
		{
//			dump.innerHTML += '\n***OBJC***'
		}
		
		//
		// Dump tokens
		// 
		
		function	MultiParameterMessage(firstParameter)
		{
			this.value = firstParameter + '_'
		}
		
		MultiParameterMessage.prototype.toString = function ()
		{
//			return '*' + this.value + 'Â°'
			return this.value
		}
		MultiParameterMessage.prototype.addParameter = function (param)
		{
			this.value += param + '_'
		}
		
		function	tokenizeObjC(tokens)
		{
			var str = ''
			var str2 = ''
			
			var tokenStream = []
			var messageStream = []
			var currentParameterCount
			var currentMessage
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				var v = tv = token.value
//				if (!lines[token.line])	continue
//				tv = lines[token.line].substr(token.from, token.character-token.from)
/*
				if (token.isObjCCall)			v = '<span class="objc">' + tv + '</span>'
				if (token.isObjCFirstCall)		v = '<span class="firstobjc">' + tv + '</span>'
				if (token.isObjCCallOpener)		v = '<span class="objcopener">' + tv + '</span>'
				if (token.isObjCCallCloser) 	v = '<span class="objccloser">' + tv + '</span>'
				if (token.isObjCCallCloser && token.isFirstObjCCall) v = '<span class="objcopener objccloser objcopenerandcloser">' + tv + '</span>'
				if (token.isObjCParameterSeparator)	v = '<span class="objcparamsep">' + tv + '</span>'
*/

				// Handle ObjC classes
				if (token.isObjCClassStart)
				{
					tokenStream.push("Class('" + tokens[i+1].value + ' < ' + tokens[i+3].value + "').definition = function ()")
					i += 3
					continue
				}
				// Handle ObjC methods
				if (token.isObjCClassItemStart)
				{
					var methodToken = token
					var dataHolder = token
					var isSwizzle = false
					if (token.value.toLowerCase() == 'swizzle')
					{
						methodToken = token = tokens[++i]
						isSwizzle = true
					}
					// Method start
					if (token.value == '-' || token.value == '+')
					{
						i++
						// Skip method definition
						while (tokens[i] && tokens[i].value != '{')
							i++

						var str = "('" + dataHolder.objCMethodName + "').encodingArray(" + dataHolder.objCMethodEncodings + ").fn = function (" + dataHolder.objCMethodParamNames + ")"
						str = (isSwizzle ? 'Swizzle' : '') + (methodToken.value == '-' ? 'Method' : 'ClassMethod') + str
						tokenStream.push(str)
						continue
					}
					// Outlet
					if (token.value == 'IBOutlet')
					{
						tokenStream.push("IBOutlet('" + tokens[i+1].value + "')")
						i += 1
						continue
					}
					// Action
					if (token.value == 'IBAction')
					{
						var actionName = tokens[i+1].value
						
						var paramName = 'sender'
						if (tokens[i+2].value == '(')
						{
							paramName = tokens[i+3].value
							i += 3
						}

						tokenStream.push("IBAction('" + actionName + "').fn = function (" + paramName + ")")
						i += 1
						continue
					}
				}
				// String immediates, selectors
				if (token.id == '@')
				{
					var nexttoken = tokens[i+1]
					if (nexttoken.id == '(string)')
					{
						tokenStream.push('NSString.stringWithString(' + nexttoken.rawValue + ')')
						i += 1
						continue
					}
					else
					{
						tokenStream.push("'" + tokens[i+3].rawValue + "'")
						i += 4
						continue						
					}
//					alert('@')					
				}


				var c = ''
				if (token.isObjCCall)			c += ' objc'
				if (token.isObjCFirstCall)		c += ' firstobjc'
				if (token.isObjCCallOpener)		c += ' objcopener'
				if (token.isObjCCallCloser) 	c += ' objccloser'
				if (token.isObjCCallCloser && token.isObjCFirstCall) c += ' objcopener objccloser objcopenerandcloser'
				if (token.isObjCParameterSeparator)	c += ' objcparamsep'
				v = '<span class="' + c + '">' + tv + '</span>'
				
//				str += ' ' + v
				str += ' ' + v
				var isCallOpener = 'objCParameterCountOpener' in token
				var isCallCloser = 'objCParameterCountCloser' in token
				if (isCallCloser)	str += '<span class="objcparamcountcloser">' + token.objCParameterCountCloser + '&gt;</span>'
				if (isCallOpener)	str += '<span class="objcparamcountopener">&lt;' + token.objCParameterCountOpener + '</span>'
//				if (isCallOpener && isCallCloser)	str += '<span class="objcparamcount"> </span>'

				//			alert(dumpHash(token))
				if (token.id == '(endline)') 
				{
//					str += '\n\n'
					str += '\n'
					tokenStream.push('\n')
				}
				
				
//				v = tv
				//
				// ObjC message handling
				//
				
				// Skip '[' and ':'
				if (token.isObjCCallOpener || token.isObjCParameterSeparator) continue

					if (token.isObjCCallCloser && token.isObjCFirstCall) v = ''

				// Instance : add '.' to get method
				if (token.isObjCFirstCall)
				{
					currentParameterCount = token.objCParameterCountOpener
					v += '.'
				}
				// First selector part : retrieve full selector name
				if (token.isObjCFirstParam && currentParameterCount)
				{
					v = token.objCJSSelector
					v += '('
				}
				// Selector part : ignore name and add ',' separator
				if (token.isObjCMultiCall)
				{
					v = ''
					if (!token.isObjCCallCloser) 
						v += ','
				}
				// Ignore ']', add ')' if we're closing a parameter message
				if (token.isObjCCallCloser)
				{
					v = ''
				 	if (token.objCParameterCountCloser)
						v = ')'
				}
				tokenStream.push(v)

			}
			str2 = tokenStream.join('')
			dump2.innerHTML = getTickCount() + '\n' + str
			transformed.innerHTML = getTickCount() + '\n' + str2
			
			
			return tokens
		}

		function	tokenizeOperators(tokens)
		{
			var str = ''
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				var v = tv = token.value
if (!lines[token.line])	continue
				str += v
				var v2 = lines[token.line].substr(token.from, token.character-token.from)
				str += ' <span style="color: blue">*' + v2 + '*</span> '
				var operandCount = 0
				if (token.left) operandCount++, str += ' l=' + token.left.value
				if (token.right) operandCount++, str += ' r=' + token.right.value
				if (operandCount == 1)	str += ' <span style="color: red">missingop</span>'
				if (token.arity)	str += ' <b>' + token.arity + '</b>'
//				if (token.left)	alert(dumpHash(token)), eaz()
				str += '\n'
			}
			
			var operatorFunctions = { '{+}' : '__addHash', '[+]' : '__addArray' }
			var ops = []
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				if (operatorFunctions[token.id])
				{
					ops.push(token)
					var op = operatorFunctions[token.id]
					token.replacedValue = ','
					
					var left, right
					var t = token
					while (t)
					{
						if (t.left) left = t.left
						t = t.left
					}
					var t = token
					while (t)
					{
						if (t.right) right = t.right
						t = t.right
					}
					
					
					if (left && right)
					{
						var v = left.replacedValue || left.rawValue
						left.replacedValue = op + '(' + v
						var v = right.replacedValue || right.rawValue
						right.replacedValue = v + ')'
					}
				}
//				alert('lk')
			}

			var str2 = ''
			
			var evalMe = ''
			for (var i=0; i<tokens.length; i++)
			{
				var token = tokens[i]
				var v = token.replacedValue || token.rawValue
				
//				str2 += v + ' '
//				if (token.id == '(endline)') str2 += '<br>'
				evalMe += v + ' '
				if (token.id == '(endline)') evalMe += '\n'
			}
			str2 += evalMe
//			str2 += '<textarea>' + evalMe + '</textarea>'
			str += '<hr>' + str2 + '<hr>'
			
			try
			{
				var identifierTokens = []
				for (var i=0; i<tokens.length; i++) if (tokens[i].type == '(identifier)') identifierTokens.push(tokens[i])

				evalMe = '{\n' + evalMe + '\n}'
//				var f = new Function(evalMe)
//				var r = f()
				var r = eval(evalMe)
				
				str += '<hr><div style="color: green;">'
				str += '<b>eval OK</b>'
				for (var i=0; i<identifierTokens.length; i++)
				{
					var id = identifierTokens[i].value
					var v = eval(id)
					str += '<br><br>' + id + '=' + v
					var d = dumpHash(v)
					if (d) str += ' (' + d + ')'
				}
				str += '</div>'
			}
			catch(e)
			{
				str += '<hr><div style="color: red; font-weight: bold">eval failed<br>' + dumpHash(e) + '</div>'
			}

//			dump.innerHTML = getTickCount() + '\n' + str
			
//			alert('go through tokens, register ops - sort by binding power, then replace them for highest to lowest')
			/*
				add token number in token ?
			*/
		}
		
		function	__addArray(a, b)
		{
			var r = []
			if (a.constructor != Array.prototype.constructor)	a = [a]
			if (b.constructor != Array.prototype.constructor)	b = [b]
			for (var i=0; i<a.length; i++) r.push(a[i])
			for (var i=0; i<b.length; i++) r.push(b[i])
			return r
		}
		
		function	__addHash(a, b)
		{
			var r = {}
			if (a.constructor != Object.prototype.constructor)	{	var o = {}; o[a] = true; a = o }
			if (b.constructor != Object.prototype.constructor)	{	var o = {}; o[b] = true; b = o }
			for (var i in a) r[i] = a[i]
			for (var i in b) r[i] = b[i]
			return r
		}


		//
		// 
		// 
		var dump = document.getElementById('dump')
		var dump2 = document.getElementById('dump2')
		var transformed = document.getElementById('transformed')
		
		var textarea = document.getElementsByTagName('TEXTAREA')[0]

		var lines
		function	lint()
		{
			var src = textarea.value
			lines = src.split('\n')
		
			dump.innerHTML = getTickCount()

			tokens = []
			var options = { forin : true, laxbreak : true, indent : true }
			var lintRes = jslint(lines, options)
		
			var str = 'LINT=' + lintRes
			document.documentElement.className = JSLINT.errors.length ? 'lintError' : ''
//			if (JSLINT.errors) JSLINT.errors.pop()
			for (var i=0; i<JSLINT.errors.length; i++)
			{
				var e = JSLINT.errors[i]
				if (!e)	continue
				str += '\n<span style="color: red">' + dumpHash(e) + '</span>'
			}
			dump3.innerHTML = '<hr>' + str

			try
			{
			tokens = tokenizeObjC(tokens)
			tokens = tokenizeOperators(tokens)
			}
			catch(e)
			{
				dump.innerHTML = '<span style="color: red">' + dumpHash(e) + '</span>'
			}
//			dumpTokens()
//			dumpTokens2()
		}

		var logs = { logToken : logToken }
		var JSLINT = JSLintWithLogs(logs)
		var jslint = JSLINT()


		lint()
		
		function	keyup()
		{
			setTimeout(lint, 0)
		}
//		textarea.onkeyup = keyup
		
		setTimeout(function () { document.getElementsByTagName('TEXTAREA')[0].focus() }, 10)
	</script>

<pre>	
	var array = [[NSObject alloc]]

	var obj = [[[NSObject alloc]][0] init]
	var obj = [[[[NSObject alloc]][0] init] keys][0]

	-> un immediate de [NSObject.alloc()]
	[[[NSObject alloc] init]]     
	[array[0] init]
	
	

<pre style='color: red'>
	* GUARANTEE SELECTOR TO BE [A-Za-z_]\w+
	
</body>
</html>
