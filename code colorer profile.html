<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Profiler</title>
<!--
-->	
	<style>
		html
		{
			font-family: Lucida Grande;
		}
	
		#coloredCodeContainer
		{
			position: relative;
			white-space: pre-wrap;
			font-family: monaco;
			font-size: 7pt;
			epadding: 1em;
			height: 700px;
			overflow: auto;
			position: relative;
			z-index: 4;
		}
		#coloredCode
		{
			outline: none;
			position: relative;
			z-index: 20;
		}
	
		/*
		*
		* Dump styles
		*
		*/
		td
		{
			vertical-align: top;
		}
		
		.selectedLine
		{
			position: absolute;
			width: 100%;
			ebackground-color: red;
			border: solid 1px #fc8;
			border-left: 0;
			border-right: 0;
			margin-top: -2px;
			background: -webkit-gradient(linear, left top, left bottom, from(#fec), to(#fda));
			background: -webkit-gradient(linear, left top, left bottom, from(#ffd), to(#fec));
			background: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 208, 0.5)), to(rgba(255, 240, 192, 1.0) ) );
		}
		.selectedLinePosition
		{
			position: absolute;
			right: 0;
			bottom: 0;
			text-align: right;
			color: #f80;
			vertical-align: bottom;
			margin-right: 4px;
			efont-size: 70%;
		}
		
		.selectionDump
		{
			width: 350px;
		}
		.selectionDump, .selectionDump td
		{
			border: solid 1px #aaa;
		}
		.selectionDump .header
		{
			font-weight: bold;
		}
		#undoStackDump
		{
			color: #8c0;
		}
		
		.newline
		{
			/* cursor won't land an empty lines with white-space: normal */
			/* but if normal, shift-selecting up stops on newline */
			/* inline-block works OK */
			ewhite-space: normal;
			edisplay: -webkit-inline-box; 
		}
		.newline-blank
		{
			ewhite-space: pre;
			/* border: solid 1px red; */
		}
		
		.fakeTab
		{
			ewhite-space: normal;
			edisplay: inline-block;
			epadding-right: 20px;
			emargin-right: 20px;
			eborder: solid 1px red;

			eletter-spacing: -4px;
			eletter-spacing: -0.5em;
			eletter-spacing: -0.5pt;
			epadding-right: 40px;
			emargin-right: -20px;
			ebackground: -webkit-gradient(linear, left top, right top, from(#f44), to(#fcc));
			ebackground: -webkit-gradient(linear, left top, right top, from(rgba(220, 245, 200, 0.81)), to(rgba(100, 255, 100, 0.81)));
			
			emax-height: 1em;
			eline-height: 0.2em;
			overflow: none;
		}
		#warning
		{
			position: absolute;
			color: red;
			z-index: 1;
		}
		
	</style>
</head>
<body>

<div id='warning'></div>
<table border='1' style='table-layout: fixed; width: 100%; height: 800px; height: 650px; height: 300px; overflow: auto;' cellPadding='0' cellSpacing='0'><tr>
	<td>
		<div id='coloredCodeContainer'><div id='coloredCode'></div></div>
	</td>
	<td style='width: 300px'>
		<div id='birdView'></div>
		<div id='selectionDump'>SELECTION DUMP</div>
		<hr>
		<div id='birdViewDump'>LOG ALL COMMANDS HERE. typing (typing count, line extent + sel) + move + undo/redo</div>
		<div id='clockDump'>clock dump</div>
		<hr>
		<div id='undoStackDump'>UNDO DUMP</div>
		<button onclick='undo()'>undo</button>
		<button onclick='redo()'>redo</button>
		<button onclick='paste()'>paste</button>
		<button onclick='dumpUndoStack()'>dump undo</button>
		<div id='orderDump'>order dump <br></div>
		<div id='linesDump'>lines dump</div>
	</td>
</tr></table>

	<textarea style='display: none'>
		// Profiler placeholder
		2+2
		
</textarea>	
	<pre id='dump'></pre>



<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
	<pre id='dump4'></pre>
</tr></table>
	<button onclick="clearDumps()">Clear</button>
	<pre id='dump5'></pre>
	<pre id='dump6'></pre>
<!--
	<script src="json2.js"></script>
	<script src='showdown.js'></script>
-->	
	<script src="jslint-jscocoa.js"></script>

		<script>
		
//			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}
			function	dumpHashNoFunction(o)
			{
				var str = ''
				for (var i in o) { if (typeof o[i] == 'function') continue; str += i + '=' + (o[i].toString == 'toStringToken' in this ? ('*TOKEN*'+o[i].value + '*') : o[i]) + '\n' }
				return str
			}
			function	newNodeAsChildOf(node, tagName)
			{
				var n2 = document.createElement(tagName||'DIV')
				node.appendChild(n2)
				return n2
			}
			function	log(str)
			{
				document.getElementById('warning').innerHTML += '<pre style="margin: 0">' + getTickCount() + ' ' + str + '</pre>'
			}
			

			// Walkers
			function nextNode(n)
			{
				if (n.firstChild)	return n.firstChild
				while (n)
				{
					if (n.nextSibling)	return n.nextSibling
					n = n.parentNode
				}
				return	null
			}
			function	previousNode(n)
			{
				if (n.previousSibling)
				{
					n = n.previousSibling
					while (n && n.lastChild)
						n = n.lastChild
					return	n
				}
				n = n.parentNode
				return	n
			}
			
			








			//
			// Code colorer class
			// 						
			function	CodeColorer(editorNode, containerNode, birdViewNode)
			{
				this.initWithNodes(editorNode, containerNode, birdViewNode)
			}
			var CCp = CodeColorer.prototype
			CCp.initWithNodes = function (editorNode, containerNode, birdViewNode)
			{
				this.editorNode		= editorNode
				this.birdViewNode	= birdViewNode
				this.containerNode	= containerNode
/*
><div id='bubbleContainer'></div><div id='lineNumbers'></div><div id='selectedLine'><div id='selectedLinePosition'></div></div><div id='highlightedContainer'><div id='tracesContainer'></div><div id='whiteSpaceRevealer'></div>
*/			
				this.editorNode.contentEditable = true
				
				this.bubbleContainer	= newNodeAsChildOf(this.containerNode)
				this.lineNumbers		= newNodeAsChildOf(this.containerNode)
				this.selectedLine		= newNodeAsChildOf(this.containerNode)
				this.selectedLinePosition	= newNodeAsChildOf(this.selectedLine)
				this.tracesContainer	= newNodeAsChildOf(this.containerNode)
				this.whiteSpaceRevealer	= newNodeAsChildOf(this.containerNode)
				
				this.selectedLine.className	= 'selectedLine'
				this.selectedLinePosition.className	= 'selectedLinePosition'


				// Measure width of one character
				this.charWidthMeasurer	= newNodeAsChildOf(this.containerNode)

				// Undo
				this.actionId = 0
//				this.selectionStack = []
				this.undoStack = []
				this.redoStack = []
				
				// Create lint and register our logs
				var logNames = ['logToken', 'logExtraSyntax']
				var logs = {}
				var self = this
				for (var i=0; i<logNames.length; i++)	{
					var name = logNames[i]
					// Close name
					logs[name] = function (name) { return function () { return self[name].apply(self, arguments) } }(name)
				}
				this.JSLINT = JSLintWithLogs(logs)
				this.jslint = this.JSLINT()
				
				// Events
				var self = this
//				this.DOMCharacterDataModifiedListener = function () { return self.DOMCharacterDataModified.apply(self, arguments) }
//				this.editorNode.addEventListener('DOMCharacterDataModified', this.DOMCharacterDataModifiedListener, false)

//document.onselectionchange = function ()
/*
var self = this
document.body.onselectstart = function ()
{
//	document.getElementById('linesDump').innerHTML = getTickCount() + ' selchange' + '<pre>' + dumpHash(self.rangeSelection) + '</pre>'
	document.getElementById('selectionDump').innerHTML = getTickCount() + ' selchange' + '<pre>' + dumpHash(self.rangeSelection) + '</pre>'
}
*/

				this.editorNode.onkeydown		= function () { return self.keydown.apply(self, arguments) }
/*
				this.editorNode.oncut			= function () { return self.cut.apply(self, arguments) }
				this.editorNode.onpaste			= function () { return self.paste.apply(self, arguments) }
				this.containerNode.onscroll		= function () { return self.scroll.apply(self, arguments) }
				this.editorNode.onmousedown		= function () { return self.mousedown.apply(self, arguments) }
				this.editorNode.onmousemove		= function () { return self.mousemove.apply(self, arguments) }
				this.editorNode.onmouseup		= function () { return self.mouseup.apply(self, arguments) }
				this.editorNode.onblur			= function () { return self.blur.apply(self, arguments) }
*/
//				this.editorNode.addEventListener('DOMFocusIn', function () { var a = getSelection().type; alert('IN ' + a) }, false)

//var s = this
//				this.editorNode.addEventListener('DOMFocusOut', function () { var a = getSelection().type; alert('OUT ' + a  + '\n' + dumpHash(s.lastValidCaret)) }, false)

//				this.editorNode.addEventListener('webkitBeforeTextInserted', function () { alert('webkitBeforeTextInserted') }, false)
//				this.editorNode.addEventListener('textInput', function () { alert('textInput') }, false)

//				this.postBrowserActionFunction	= function () { return self.postBrowserAction.apply(self, arguments) }
				// Safari might execute two keydowns in a row instead of keydown + postkeydown. Used a counter to ensure order execution.
//				this.postBrowserActionPending = 0
				
				// Keep last valid caret position. setting this.caret.text = newText deletes Safari's selection, querying caret after it will return the last known position
				this.lastValidCaret = { line : 0, offset : 0 }
				
				// Holds isMoving, and when !isMoving, rangeText, lineCount, caretLineNumber, caretLineText, previousLineText, nextLineText
				this.editState		= {}
			}
			
			//
			// Helpers
			// 
			CCp.warn = function (str)
			{
				document.getElementById('dump3').innerHTML = getTickCount() + '<br>' + '<span style="color: red">' + str + '</span>'
			}
			CCp.dumpLintErrors = function (errors)
			{
				var str = ''
				for (var i=0; i<errors.length; i++)
					if (errors[i]) str += '(' + errors[i].line + ',' + errors[i].character + ')=' + errors[i].reason + '\n'
				return str
			}
			CCp.toString = function () {
				return 'CodeColorer'
			}
			
			//
			// Text loading
			//
			CCp.loadText = function (text)
			{
				// Should remove \r
				var lines = text.split('\n')
				this.loadLines(lines)
			}
			CCp.loadLines = function (lines)
			{
				this.measureCharWidth()
				var src = []
				if (lines.length == 0) lines = ['']
				for (var i=0; i<lines.length; i++)
				{
					var l = lines[i]
					l = this.replaceTabsInLine(l)
					l = '<div class="line">' + l + '\n</div>'
					src.push(l)
				}
				this.editorNode.innerHTML = src.join('')
			}
			CCp.__defineGetter__('lineCount', function ()
			{
				return this.editorNode.childNodes.length
			})
			CCp.rawText = function ()
			{
				return this.editorNode.innerText
			}

			CCp.measureCharWidth = function ()
			{
				var str = '<span>*</span><br/>'
				this.charWidthMeasurer.innerHTML = str
				this.charWidth = this.charWidthMeasurer.firstChild.offsetWidth
				this.charTabWidths = {}
			}

			CCp.textFromLine = function(line)
			{
				if (typeof line == 'number')
					line = this.lineNodeFromLineNumber(line)
				if (!line)	return null
				var t = line.innerText
				// When suppr-ing text from the end of line, Safari might delete newline - re-add it
				if (!t.match(/\n/)) t += '\n'
				return	t
			}
			CCp.setLineText = function (line, text)
			{
				var n = this.lineNodeFromLineNumber(line)
				if (n) n.innerHTML = this.replaceTabsInLine(text)
			}
			
			
			//
			// Line and offset computation
			// 
			CCp.lineNodeFromNode = function (startNode)
			{
				if (!startNode)		return log('lineNodeFromNode called with (null)'), null
				var node = startNode
				while (node)
				{
					if (node.nodeType == 1 && node.className == 'line')
						return node
					node = node.parentNode
				}
				if (!node)	
					log('lineNodeFromNode found no line with startNode=' + startNode + '' + (startNode.nodeType==1?startNode.outerHTML:startNode.nodeValue).substr(0, 100))
				return node
			}
			CCp.nodeIsInEditor = function (node)
			{
				while (node)
				{
					if (node == this.editorNode)	return true
					node = node.parentNode
				}
			}
			
			CCp.lineNumberFromNode = function (node)
			{
				node = this.lineNodeFromNode(node)
				if (!node)	return
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			CCp.lineNodeFromLineNumber = function (i)
			{
				return this.editorNode.childNodes[i]
			}
			// Given a relative (node, offset), return an absolute offset in the matching line
			CCp.caretFromNodeAndOffset = function (node, offset)
			{
//				if (!node)	return new Caret(0, 0, this)
				var n = node
				var offset2 = offset, lineNumber = this.lineNumberFromNode(n)
				if (n.className != 'line')
				{
					n = previousNode(n)
					while (n && n.className != 'line')
					{
						if (n.nodeType == 3) offset2 += n.nodeValue.length
						n = previousNode(n)
					}
				}
//				return	{ line : lineNumber, offset : offset2, isDiv : node.className == 'line' && offset == 0 }
				var c = new Caret(lineNumber, offset2, this)
				c.isDiv = node.className == 'line' && offset == 0
				return c
			}
/*
			// Given an absolute (line, offset), return an inner line node and offset
			CCp.nodeAndOffsetFromLineAndOffset = function (line, offset, isDiv)
			{
				var lineNode		= this.lineNodeFromLineNumber(line)
				if (isDiv && offset == 0)	return { node : lineNode, offset : offset }
				var currentOffset	= 0
				
				var n = nextNode(lineNode)
				while (n && n.className != 'line')
				{
					if (n.nodeType == 3)
					{
						var t = n.nodeValue
						if (currentOffset + t.length >= offset)
							return { node : n, offset : offset-currentOffset }
						else
							currentOffset += t.length
					}
					n = nextNode(n)
				}
				return { node : null, offset : undefined }
			}
*/

			//
			// Selection handling
			// 
			CCp.__defineGetter__('rawSelection', function ()
			{
				var s = getSelection()
//				return [s.baseNode, s.baseOffset, s.extentNode, s.extentOffset]
				return [s.anchorNode, s.anchorOffset, s.focusNode, s.focusOffset]
			})
			CCp.__defineSetter__('rawSelection', function (r)
			{
				getSelection().setBaseAndExtent(r[0], r[1], r[2], r[3])
			})
			
			// Caret selection { line, offset }
			CCp.__defineGetter__('caretSelection', function ()
			{
				return this.caretFromNodeAndOffset(getSelection().anchorNode, getSelection().anchorOffset)
			})
			CCp.__defineSetter__('caretSelection', function (s)
			{
				var line = this.lineNodeFromLineNumber(s.line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<s.offset; i++)
					sel.modify('move', 'right', 'character')
			})

			// Range selection { line, offset, line2, offset2 }
			CCp.__defineGetter__('rangeSelection', function ()
			{
				var n = 'anchor'
				var c1 = this.caretFromNodeAndOffset(getSelection()[n + 'Node'], getSelection()[n + 'Offset'])
				var n = 'focus'
				var c2 = this.caretFromNodeAndOffset(getSelection()[n + 'Node'], getSelection()[n + 'Offset'])
				return { type : 'Range', line : c1.line, offset : c1.offset, line2 : c2.line, offset2 : c2.offset, CCp : this, 
							select : function () { this.CCp.rangeSelection = this } }
			})
			CCp.__defineSetter__('rangeSelection', function (s)
			{
				var sel = getSelection()
				this.caretSelection = { line : s.line, offset : s.offset }
				var baseNode	= sel.baseNode
				var baseOffset	= sel.baseOffset
				this.caretSelection = { line : s.line2, offset : s.offset2 }
				var extentNode	= sel.extentNode
				var extentOffset= sel.extentOffset
				sel.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset)
			})
			
			CCp.orderedLineNumbersFromRangeSelection = function (includeLastLine)
			{
				var c1 = this.caret, c2 = this.caret2
				if (c1.lineNumber > c2.lineNumber) c1 = this.caret2, c2 = this.caret
				var l1 = c1.lineNumber
				var l2 = c2.lineNumber
				if (!includeLastLine && c2.offset == 0) l2--
				return { line : c1.lineNumber, offset : c1.offset, line2 : c2.lineNumber, offset2 : c2.offset, l1 : l1, l2 : l2 }
			}
			CCp.textFromRangeSelection = function(includeLastLine)
			{
				var lineNumbers = this.orderedLineNumbersFromRangeSelection(includeLastLine)
				var text = ''

				// When a whole line is selected, deleting it will move caret to the next line. Save it too.
				var l2 = lineNumbers.l2
				for (var i=lineNumbers.l1; i<=l2; i++)
				{
					var c = new Caret(i, 0, this)
					text += c.text
				}
				return text
			}
/*
			CCp.selectionOnStack = function()
			{
				if (!this.selectionStack.length)	return
				return	this.selectionStack[this.selectionStack.length-1]
			}
			CCp.pushSelection = function ()
			{
				this.selectionStack.push(getSelection().type == 'Caret' ? this.caretSelection : this.rangeSelection)
			}
			CCp.popSelection = function ()
			{
				if (this.selectionStack.length == 0)	return log('popSelection exhausted selection stack')
				var r = this.selectionStack.pop()
				if (r.type == 'Caret')	this.caretSelection = r
				else					this.rangeSelection = r
			}
*/
/*
			// Return position - offset differs from selection offset, as tabs will count for 1 to 4 chars
			CCp.textPositionAsLineAndOffset = function ()
			{
				var sel	= getSelection()
				var s	= this.lineAndOffsetFromNodeAndOffset(sel.baseNode, sel.baseOffset)
				var line= this.lineNodeFromNode(sel.baseNode)
				var str	= this.textFromLine(line).substr(0, s.offset)

				var o = {}
				this.replaceTabsInLine(str, null, null, o)
				return { line : s.line, offset : o.totalWidth }
			}
*/

			CCp.gatherLinesToLint = function ()
			{
				var lines = []
				var f = this.editorNode.firstChild
				while (f)
				{
					var text = f.textContent
					lines.push(text)
					f = f.nextSibling
				}
				return lines
			}
			
			CCp.lintLines = function (lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }

//### FIX INSTANCE VARS				
				this.tokensByLine	= {}
				this.functionLines	= []
//				this.traceTokens	= []
    			var res = this.jslint(lines, options)
				return { tokens : this.tokensByLine, res : !!res, functionLines : this.functionLines, errors : this.JSLINT.errors }
			}
			
			//
			// Color code
			// 
			CCp.colorCode = function ()
			{
//					this.measureCharWidth()
				
				var t
				var str = ''
				var clock = function (c)
				{
					if (!c) t = getTickCount()
					if (c) str += '<br>' + c + '=' + (getTickCount()-t) +  ' ms'
				}

				clock()
//				var text = this.editorNode.textContent
//				alert(text)
				var lines = []
				var f = this.editorNode.firstChild
				while (f)
				{
					var t = f.textContent
//					if (!t.match(/\n/)) t += '\n'
					lines.push(t)
					f = f.nextSibling
				}
				
				var lineCount = lines.length
				
				str += 'linting ' + lineCount + ' lines <small>' + getTickCount() + '</small>'
				
				var text = lines.join('\n')
//				alert(text)
				clock('gather')

				clock()
				this.tokenCount = 0
				var lint = this.lintLines(text)
				clock('lint')
				
				if (!lint.res)	
				{
					this.warn('Lint error dump ... ' + getTickCount() + '\n' + this.dumpLintErrors(lint.errors))
				}
				else
				{
					document.getElementById('dump3').innerHTML = getTickCount() + ' <span style="color: lime; font-weight: bold">OK</span>'
				}
				
				str += '<br>tokenCount=' + this.tokenCount
				
//				str += '<br>tokenCount=' + lint.tokens[0].length
				
/*				
				clock()
				//
				// Color
				//
//				this.pushSelection()
//				var s = this.rangeSelection
				var f = this.editorNode.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					this.writeTokensToLine(f, tokens, line, i)
					
					f = f.nextSibling
					i++
				}
//				this.rangeSelection = s
//				this.popSelection()
				
				clock('color')
*/
				document.getElementById('clockDump').innerHTML = str
			}

			//
			//
			// Write functions
			// 
			//
			
			// Replace tabs switched methods ...
			//  fully deleting the tab with letter-spacing messes up caret AND selection indices when selecting a range (yields a baseOffset of 1 when a full line is selected)
			CCp.replaceTabsInLine = function (line, html, customReplaceFunction, o)
			{
				if (!html)	html = htmlEncode(line)
				var tabWidths = []
				var tabWidths8 = []
				function	countTabs(str, idx)
				{
					var length = (idx+deltaTabPosition) % tabWidth
					length = tabWidth - length
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition += length-1
					
					tabWidths.push(length)

					var length8 = (idx+deltaTabPosition8) % 8
					length8 = 8 - length8
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition8 += length8-1
					
					tabWidths8.push(length8)
				}

				var tabIndex = 0
				var charWidth = this.charWidth
				var charTabWidths = this.charTabWidths
				function	replaceTabs(str, idx)
				{
					// A tab is surrounded by a SPAN nulling its width (with negative letter-spacing) and padding it to the correct 4-size with charWidth (measured in charWidthMeasurer)
					totalWidth += tabWidths[tabIndex]
//					alert(tabWidths[tabIndex] + '\n' + tabWidths8[tabIndex])
					var w1 = charWidth
					var w2 = tabWidths[tabIndex]*charWidth


					var w = tabWidths[tabIndex]*charWidth
					var p = w
					var ls = charWidth


//alert(tabWidths8[tabIndex] + '\n\n*****\n' + dumpHash(charTabWidths))
					var p = tabWidths[tabIndex]*charWidth-charTabWidths[tabWidths8[tabIndex]]
					var ls = (charWidth-1)
					
					p = tabWidths[tabIndex]*charWidth-3
//					p = 21
//alert('letterspacing=' + ls + '\ntab width 4=' + tabWidths[tabIndex] + '\ntab character count=' + tabWidths8[tabIndex] + '\ntab pixel width=' + charTabWidths[tabWidths8[tabIndex]] + '\np=' + p + '\n\ncharTabWidths=\n' + dumpHash(charTabWidths))
//alert(tabWidths8[tabIndex] + '\n*\n' + charTabWidths[tabWidths8[tabIndex]] + '\n*\n' + dumpHash(charTabWidths))
					var style = 'letter-spacing: -' + ls + 'px; padding-right: ' + p + 'px'
					style = ' display: inline-block'

//ls = charWidth
//p = 0
//					var style = 'letter-spacing: -' + ls + 'px; margin-right: -' + (p) + 'px'

//					var style = 'letter-spacing: -' + charWidth + 'px; emargin-right: -' + (p) + 'px'
//					style = ''

//					alert(style)
//					var style = 'letter-spacing: -' + ls + 'px; margin-right: -' + (charTabWidths[tabWidths8[tabIndex]]) + 'px'
					
//var mr = -charTabWidths[tabWidths8[tabIndex]]
//style = 'margin-right: ' + mr + 'px'
					tabIndex++
//style = ''	
//style = 'letter-spacing: -' + charWidth + 'px'
//alert(style)
style = 'display: inline-block'
style = 'white-space: normal; eborder-top: solid 1px red; padding-right: ' + w2 + 'px; '
style = 'white-space: normal; letter-spacing: ' + w2 + 'px; border-left: solid 3px red; edisplay: inline-block'

style = ''
style = 'display: inline-table; width: 20px'



style = 'display: -webkit-inline-box; width: ' + w + 'px'
style = 'display: inline-block; width: ' + w + 'px; eheight: 7px; overflow: hidden'

/* 
	-webkit-box-align: alignment;
baseline
Elements are aligned with the baseline of the box.

center
Elements are aligned with the center of the box.

end
Elements are aligned with the end of the box.

start
Elements are aligned with the start of the box.

stretch
Elements are stretched to fill the box.


*/

//alert(style)
//style='white-space: normal; margin-right: 10px'
style = ''

style = 'display: -webkit-inline-box; width: ' + w + 'px;' //' overflow: hidden; height: 1em'

//style = 'display: inline-block; width: ' + w + 'px'

//style = 'display: inline; white-space: normal; width: ' + w + 'px'

style = ''
//					return '<span class="fakeTab" style="' + style + '"><span>	</span></span>'
					return '<span class="fakeTab" style="' + style + '">	</span>'
					
//					return '<span class="fakeTab" style="letter-spacing: -' + w1 + 'px; padding-right: ' + w2 + 'px">	</span>'
//					w1 = 0
//					w2 = 100
//					return '<span class="fakeTab" style="eletter-spacing: ' + w1 + 'px; padding-right: ' + w2 + 'px; white-space:normal; border: solid 1px red">	</span>'
				}
				var tabWidth = this.tabWidth()
				var deltaTabPosition = 0
				var deltaTabPosition8 = 0

				// Count tabs
				line.replace(/\t/g, countTabs)
				// Total character width of line (counting a full tab as tabWidth())
				var totalWidth = line.length - tabWidths.length
				// Replace tabs
				html = html.replace(/\t/g, customReplaceFunction ? function () { return customReplaceFunction(tabWidths[tabIndex++]) } : replaceTabs)
//alert(html)				
				// Output totalWidth
				if (o)	o.totalWidth = totalWidth
				return	html
			}
			CCp.tabWidth = function ()
			{
				return	4
			}
			
			CCp.writeTokensToLine = function (node, tokens, line, lineNumber)
			{
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
					// Skip endline
					if (token.id == '(endline)')
					{
						i++
						continue
					}
					
					if (token.rawValue && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						str += htmlEncode(space)
					}
					var c = ''
					var v = token.value
					v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
//						alert(token.rawValue + '*\nline length=' + line.length + '\n' + dumpHash(token))
//						alert(line + '*\ncharacter=' + token.character + '\nline.length=' + line.length + '\nv=' + v + '*')

						// Single line markdown comment
//						if (v.match(/^\/\/md/))
//						{
//							v = v.replace(/^\/\/md\s?/, '')
//							v = MarkDownConverter.makeHtml(v)
//							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
//						}

					}
					if (token.isObjCCall)
					{
						c += ' objcCall'
						if (!token.isObjCCallOpener && !token.isObjCCallCloser && !token.isObjCFirstCall)	
							c+= ' objcCallSelector'
						if (token.isObjCCallOpener || token.isObjCCallCloser)
							c += ' objcCallBracket'
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length && 0)
				{
					var space = line.substr(lastIndex)
					alert('space=' + space + '*')
					str += htmlEncode(space)
				}

				// TABS ! sized to any size you want.
				str = this.replaceTabsInLine(line, str)
//				if (lineNumber == 1)	alert(line.length + ' ' + (line == '\n'))
//				if (line == '\n')	str = str.replace(/\n/, '<span class="newline-blank">\n</span>')
//				else				str = str.replace(/\n/, '<span class="newline">\n</span>')
				
				// Blank lines are just a newline, non blank lines get their newline wiped out - it screws selection up. 
				// (caret position wrong when going up, selecting end of line fails)
				if (line.match(/^\n$/))	str = str.replace(/\n/, '<span class="newline-blank">\n</span>')
				else					str = str.replace(/\n/, '')
				
//				if (lineNumber == 8)	alert(str + '\n*' + line + '*')
//				str = str.replace(/\n/, '<span class="newline-blank">\n</span>')
//				str = str.replace(/\n/, String.fromCharCode(0x200b))
//				str = str.replace(/\n/, String.fromCharCode(0x0001))
//				str = str.replace(/\n/, String.fromCharCode(0x0001))
				
				node.innerHTML = str
			}
			
			//
			// Logs
			// 
			CCp.logToken = function (token)
			{
/*
				var el  = token.id == '(endline)' ? '\n' : ''
				var id = token.id ? ('<span style="color: blue">(<b>' + token.id + '</b>)</span> ') : ''
				document.getElementById('dump2').innerHTML += token.value + id + el
*/
//				if (this.lines[token.line])	token.rawValue = lines[token.line].substr(token.from, token.character-token.from)				
//				else						token.rawValue = ''
//				alert('handle rawvalue'), eaz()

				var line = token.line
				if (!this.tokensByLine[line])	this.tokensByLine[line] = []
				this.tokensByLine[line].push(token)
				
				this.tokenCount++
			}
			
			CCp.logExtraSyntax = function (syntaxName, token)
			{
//				alert(syntaxName)
			}

			
			CCp.mousedown = function()
			{
				this.performAfterDelay('highlightSelectedLine')
/*
				var self = this
				function h()
				{
					self.highlightSelectedLine()
				}
				setTimeout(h, 0)
*/
				this.closeEditAction()
			}
			CCp.mousemove = function()
			{
//				var self = this
//				function h()		{		self.highlightSelectedLine()		}
				this.performAfterDelay('highlightSelectedLine')
//				setTimeout(h, 0)
			}
			
			CCp.mouseup = function()
			{
			}
			
			CCp.blur = function ()
			{
//				alert(dumpHash(this.editorNode.firstChild))
//				var self = this
//				function h()		{		self.highlightSelectedLine()		}
//alert(dumpHash(event) + '\n\n\n' + (getSelection().baseNode))
				this.closeEditAction()
				this.performAfterDelay('highlightSelectedLine')
//				setTimeout(h, 0)
			}
			
			
			//
			// Undo
			// 
/*			
			function	EditAction()
			{
			}
*/			
			
			CCp.newEditAction = function ()
			{
				this.closeEditAction()
				this.actionId++
//				var action	= new EditAction
				var action	= {}
				action.id	= this.actionId
				action.text	= ''
				action.rangeSelection = this.rangeSelection
				this.undoStack.push(action)
				this.redoStack = []
				return action
			}
			
			CCp.closeEditAction = function ()
			{
				if (!this.currentEditAction)	return
				this.currentEditAction.endRangeSelection = getSelection().type == 'None' ? this.lastValidCaret : this.rangeSelection
				// Go up to check for modified lines
				var text = ''
				var line = this.lineNodeFromLineNumber(this.currentEditAction.lastLineVisited)
				while (line && line.id == this.actionId)
				{
					this.currentEditAction.startLine = this.lineNumberFromNode(line)
					text = this.textFromLine(line) + text
					line = line.previousSibling
				}
				// Go down to check for modified lines
				var line = this.lineNodeFromLineNumber(this.currentEditAction.lastLineVisited).nextSibling
				while (line && line.id == this.actionId)
				{
					text += this.textFromLine(line)
					line = line.nextSibling
				}
				// Register newText
				this.currentEditAction.newText = text
				this.currentEditAction.closed = true
				this.currentEditAction = null

				
				
//				return
/*				
//				if (this.currentEditingAction == 'typing')
				{
//					this.currentEditingAction = 'moving'
					if (this.undoStack.length)
					{
						var action = this.currentEditAction
						action.closed = true*/
/*						
						var text = ''
						var lineChangedCount = action.newLineCount - action.backwardLineDeleteCount - action.forwardLineDeleteCount
						var lineChangedCount = action.currentLine - action.lastDeletedBackwardLineNumber
						lineChangedCount = Math.abs(lineChangedCount)
						
//						if (lineChangedCount < 1) lineChangedCount = 1
//						alert(action.lastDeletedBackwardLineNumber + '\n' + lineChangedCount)
						for (var i=action.lastDeletedBackwardLineNumber; i<=action.lastDeletedBackwardLineNumber+lineChangedCount; i++)
							text += this.textFromLine(i)
						action.newText = text
						// Remove action if nothing was changed
						if (action.isBlank)	this.undoStack.pop()
						else
						{
							this.redoStack = []
						}
*/
/*
					}
				}
*/				
				this.dumpUndoStack()
			}
			CCp.dumpUndoStack = function ()
			{
				return
				if (this.undoStack.length)
				{
					var str = getTickCount() + ' actionCount=' + this.undoStack.length + ' redoActionCount=' + this.redoStack.length
					for (var j=this.undoStack.length-1; j>=0; j--)
					{
						var action = this.undoStack[j]
						str += '<br><b> ACTION ' + j  + '</b>  ' + (action.closed ? '' : ' ...IN PROGRESS') + ' ' + (action.isBlank ? '<b>isBlank</b>' : '')
						str += '<br>startLine=' + action.startLine
						try
						{
							str += '<br>text=' + (action.text.split('\n').length-1) + ' lines'
							str += '<pre style="margin: 0; background-color: #eee">' + htmlEncode(action.text) + '</pre>'
							str += 'newText=' + (action.newText.split('\n').length-1) + ' lines'
							str += '<pre style="margin: 0; background-color: #eee">' + htmlEncode(action.newText) + '</pre>'
						} catch (e) {}
/*					
						str += '<br>startedAtLine=' + action.startedAtLine
						if (j == this.undoStack.length-1)
							str += '<br>currentLine=' + action.currentLine
						str += '<br>range=' + action.startLine + ',' + action.endLine
						str += '<br>backwardLineDeleteCount=' + action.backwardLineDeleteCount
						str += '<br>forwardLineDeleteCount=' + action.forwardLineDeleteCount
						str += '<br>newLineCount=' + action.newLineCount
						str += '<br>lastDeletedBackwardLineNumber=' + action.lastDeletedBackwardLineNumber
						str += '<br>total line change count=' + (action.newLineCount - action.backwardLineDeleteCount - action.forwardLineDeleteCount)
//						str += '<br>text=' + action.text.split('n').length
						if (action.text)
						{
							str += '<br>text=' + (action.text.split('\n').length-1) + ' lines'
							str += '<pre style="background-color: #eee">' + htmlEncode(action.text) + '</pre>'
							str += '<br>newText=' + (action.newText.split('\n').length-1) + ' lines'
							str += '<pre style="background-color: #eee">' + htmlEncode(action.newText) + '</pre>'
						}
*/
					}
					document.getElementById('undoStackDump').innerHTML = str
				}
			}
			
			CCp.undo = function ()
			{
				this.closeEditAction()
				
				if (!this.undoStack.length)	return
				var action = this.undoStack.pop()
				this.redoStack.push(action)

				// Starting from lastDeletedBackwardLineNumber, delete newText.length lines
				this.deleteTextAfterLineNumber(action.newText, action.startLine)
				// Insert after lastDeletedBackwardLineNumber text lines
				this.insertTextAfterLineNumber(action.text, action.startLine)
				
				// Reset selection
				action.rangeSelection.select()
				this.editState.rangeText = this.textFromRangeSelection(true)
				this.highlightSelectedLine()
			}
			CCp.redo = function ()
			{
				if (!this.redoStack.length)	return
				var action = this.redoStack.pop()
				this.undoStack.push(action)
				
				// Starting from lastDeletedBackwardLineNumber, delete newText.length lines
				this.deleteTextAfterLineNumber(action.text, action.startLine)
				// Insert after lastDeletedBackwardLineNumber text lines
				this.insertTextAfterLineNumber(action.newText, action.startLine)
				
				// Reset selection
				action.endRangeSelection.select()
				this.editState.rangeText = this.textFromRangeSelection(true)
				this.highlightSelectedLine()
			}
			
			
			CCp.deleteTextAfterLineNumber = function (text, lineNumber)
			{
				var lineCount = text.match(/\n/g).length
				for (var i=0; i<lineCount; i++)
				{
					var l = this.lineNodeFromLineNumber(lineNumber)
					if (!l)	return log('deleteTextAfterLineNumber missing line ' + (lineNumber+i))
					l.parentNode.removeChild(l)
				}
			}
			CCp.insertTextAfterLineNumber = function (text, lineNumber)
			{
				var l = this.lineNodeFromLineNumber(lineNumber-1)
				if (lineNumber && !l)	return this.warning('insertTextAfterLineNumber missing line ' + lineNumber)
				
				var lineCount = text.match(/\n/g).length
				var splitText = text.split('\n')
				
				for (var i=0; i<lineCount; i++)
					this.insertLineAfterLineNumber(splitText[i], lineNumber+i-1)
			}
			
			CCp.insertLineAfterLineNumber = function (text, lineNumber)
			{
				var n2 = document.createElement('DIV')
				n2.className = 'line'
				n2.innerHTML = this.replaceTabsInLine(text + '\n')
				n2.id = this.actionId

				var l = this.lineNodeFromLineNumber(lineNumber)
				if (l)	l.insertAdjacentElement('afterEnd', n2)
				else	
				{
					if (!this.editorNode.firstChild)	this.editorNode.appendChild(n2)
					else								this.editorNode.firstChild.insertAdjacentElement('beforeBegin', n2)
				}
			}
			
			
			
			//
			// Events
			// 
			CCp.keyName = function (keyCode)
			{
				if (!this.keyNames)
					this.keyNames = { 90 : 'undo', 37 : 'left', 39 : 'right', 38 : 'up', 40 : 'down', 9 : 'tab', 13 : 'newline', 8 : 'leftdelete', 46 : 'rightdelete', 32 : 'space' }
				return this.keyNames[keyCode]
			}
			CCp.keyIs = function (keyCode, keyName)
			{
				return this.keyName(keyCode) == keyName
			}
			
			
			//
			// Selection object
			//
/*
			function	Selection(s)
			{
				for (var i in s)	this[i] = s[i]
			}
			var Sp = Selection.prototype
			Sp.toString = function ()
			{
				if (!this.line2)	return this.line + ',' + this.offset
				else				return this.line + ',' + this.offset + '->' + this.line2 + ',' + this.offset
			}
			Sp.select = function ()	
			{
				if (!('line2' in this))	this.CCp.caretSelection = this
				else 					this.CCp.rangeSelection = this
			}
*/			
			//
			// Line object
			// 
			function	Line(line, CC)
			{
				this.line	= typeof line == 'Number' ? line : line.valueOf()
				this.CC		= CC
			}
			var Lp = Line.prototype
			Lp.valueOf = Lp.toString = function ()		{	return this.line	}
			Lp.__defineGetter__('text', function ()		{	return this.CC.textFromLine(this.line)		})
			Lp.__defineSetter__('text', function (text)	{	this.CC.lineNodeFromLineNumber(this.line).id = this.CC.actionId; return this.CC.setLineText(this.line, text)	})
			Lp.__defineGetter__('isFirst', function ()	{	return this.line == 0 })
			Lp.__defineGetter__('isLast', function ()	{	return this.line == this.CC.lineCount-1 })
			Lp.__defineGetter__('node', function ()		{	return this.CC.lineNodeFromLineNumber(this.line) })
			Lp.insertNewlineBelow = function ()
			{
				var n = this.CC.lineNodeFromLineNumber(this.line)
				if (!n)	return log('Line.insertNewlineBelow : invalid line number ' + this.line)
				var n2 = document.createElement('DIV')
				n2.className = 'line'
				n2.innerHTML = '\n'
				n2.id = this.CC.actionId
				n.insertAdjacentElement('afterEnd', n2)
				return new Line(this.line+1, this.CC)
			}
			Lp.select = function ()	
			{
				this.CC.caretSelection = { line : this.line, offset : 0 }
			}
			
			//
			// Caret object
			// 
			function	Caret(line, offset, CC)
			{
				this.line	= new Line(line, CC)
				this.offset	= offset
				this.CC		= CC
			}
			
			// Get, set text
			var Cp = Caret.prototype
			Cp.__defineGetter__('leftText', function ()		{	return this.line.text.substr(0, this.offset) })
			Cp.__defineGetter__('rightText', function ()	{	return this.line.text.substr(this.offset)	})
			Cp.__defineGetter__('text', function ()			{	return this.line.text })
			Cp.__defineSetter__('text', function (text)		{	this.line.text = text })
			Cp.__defineGetter__('lineNumber', function ()	{	return this.line.valueOf() })
			
			// Move
			Cp.caretMoved = function (direction, grain)	{
				var raw = this.CC.rawSelection
				this.CC.caretSelection = { line : this.line, offset : this.offset }
				getSelection().modify('move', direction, grain)
				var s = this.CC.caretSelection
				this.CC.rawSelection = raw
				return new Caret(s.line, s.offset, this.CC)
			}
			Cp.__defineGetter__('leftChar', 	function () { return this.caretMoved('left', 'character')	})
			Cp.__defineGetter__('rightChar', 	function () { return this.caretMoved('right', 'character')	})
			// These only move one line at a time. Cocoa skips whitelines.
			Cp.__defineGetter__('leftWord', 	function () { 
				var caret2 = this._leftWord
				if (caret2.lineNumber != this.lineNumber)	{
					caret2 = this.previousLine.lineEnd
					if (caret2._leftWord.lineNumber == caret2.lineNumber) caret2 = caret2._leftWord
				}
				return caret2
			})
			Cp.__defineGetter__('rightWord', 	function () { 
				var caret2 = this._rightWord
				if (caret2.lineNumber != this.lineNumber)	
					caret2 = this.nextLine.skipRightWhite()
				return caret2
			})

			Cp.__defineGetter__('_leftWord', 	function () { return this.caretMoved('left', 'word')	})
			Cp.__defineGetter__('_rightWord', 	function () { return this.caretMoved('right', 'word')	})
			Cp.__defineGetter__('previousLine', function () { return this.caretMoved('left', 'paragraphBoundary').caretMoved('left', 'character').caretMoved('left', 'paragraphBoundary')	})
			Cp.__defineGetter__('nextLine',		function () { return this.caretMoved('right', 'paragraphBoundary').caretMoved('right', 'character')	})
			// Safari mishandles these on lines with tabs, do it by hand
			Cp.__defineGetter__('lineStart',	function () { return new Caret(this.line, 0, this.CC)	})
			Cp.__defineGetter__('lineEnd',		function () { return new Caret(this.line, this.text.length-1, this.CC)	})
			Cp.__defineGetter__('startOfLine',	function () { return this.lineStart	})
			Cp.__defineGetter__('endOfLine',	function () { return this.lineEnd	})

			Cp.__defineGetter__('isAtStartOfLine',	function () { return this.offset == 0	})
			Cp.__defineGetter__('isAtEndOfLine',	function () { return this.offset == this.line.text.length-1	})


			Cp.__defineGetter__('pageUp', 		function () { var c = this; for (var i=0; i<10; i++) c = c.previousLine; return c.skipRightWhite();	})
			Cp.__defineGetter__('pageDown', 	function () { var c = this; for (var i=0; i<10; i++) c = c.nextLine; return c.skipRightWhite();	})
			
			Cp.select = function ()	
			{
				this.CC.caretSelection = { line : this.line, offset : this.offset }
			}
			Cp.selectTo = function (caret)
			{
				this.CC.rangeSelection = { line : this.line, offset : this.offset, line2 : caret.line, offset2 : caret.offset }
			}
			Cp.deleteLine = function ()
			{
				var n = this.CC.lineNodeFromLineNumber(this.lineNumber)
				if (!n)	return log('Line.delete : invalid line number ' + this.line)
				n.parentNode.removeChild(n)
			}
			
			
			Cp.skipRightWhite = function ()
			{
				var t = String(this.rightText.match(/^(\u0009|\u0020)*/)[0])
				if (!t)	return this
				var c = this
				for (var i=0; i<t.length; i++)	c = c.caretMoved('right', 'character')
				return c
			}
			Cp.isBefore = function (caret)
			{
				if (this.isEqualTo(caret)) return false;
				if (caret.lineNumber < this.lineNumber)	return false
				if (caret.lineNumber > this.lineNumber) return true
				if (caret.offset > this.offset)			return true
			}
			Cp.isEqualTo = function (caret)	{ return caret.lineNumber == this.lineNumber && caret.offset == this.offset }
			Cp.isAfter = function (caret)	{ if (this.isEqualTo(caret)) return false; return !this.isBefore(caret) }
			Cp.deleteTo = function (caret)
			{
				var caret2 = this
				if (caret2.isBefore(caret))	caret2 = caret, caret = this
				caret.line.text = caret.leftText + caret2.rightText
				var lineDeleteCount = caret2.lineNumber - caret.lineNumber
				for (var i=0; i<lineDeleteCount; i++)	
					caret.nextLine.deleteLine()
				caret.select()
			}
			Cp.toString = function ()		{	return this.line + ',' + this.offset	}
			
			
			
			
			
			CCp.__defineGetter__('caret', function ()
			{
				// Only update caret when we have a selection
				if (getSelection().anchorNode)		this.lastValidCaret = this.caretFromNodeAndOffset(getSelection().anchorNode, getSelection().anchorOffset)
				return new Caret(this.lastValidCaret.line, this.lastValidCaret.offset, this)
			})
			CCp.__defineGetter__('caret2', function ()
			{
				var c = this.caretFromNodeAndOffset(getSelection().focusNode, getSelection().focusOffset)
				return new Caret(c.line, c.offset, this)
			})
			

			//
			// Save current undoable state before an action
			// 
			CCp.saveUndoable = function ()
			{
				var sel = getSelection(), self = this, keyIs = function (keyName) { return self.keyIs(event.keyCode, keyName) }
/*				
				var tryCount = 10
				while (this.postBrowserActionPending && tryCount)	
				{
					tryCount--
					this.postBrowserActionFunction()
				}
*/				
				// Flush any remaining actions
				this.exhaustDelayedPerforms()
				
//				this.postBrowserActionPending++
//				setTimeout(this.postBrowserActionFunction, 0)
				this.performAfterDelay('postBrowserAction')

				var caret = this.caret
				this.editState = {
					 isMoving		: keyIs('left') || keyIs('right') || keyIs('up') || keyIs('down')
					,lineCount 		: this.lineCount
					,caretLineNumber: caret.lineNumber
					,caretLineText	: caret.text
					,rangeSelection	: this.rangeSelection
				}

				var action = this.currentEditAction
				if (this.editState.isMoving)	this.closeEditAction()

				if (!this.editState.isMoving)
				{
					if (sel.type == 'Caret')
					{
						if (!caret.line.isFirst)	this.editState.previousLineText	= caret.previousLine.text	, this.editState.previousLineId = caret.previousLine.line.node.id
						if (!caret.line.isLast)		this.editState.nextLineText		= caret.nextLine.text		, this.editState.nextLineId = caret.nextLine.line.node.id
					}
					else
						this.editState.rangeText = this.textFromRangeSelection(true)
				}
			}
			
			CCp.keydown = function ()
			{
				var self = this
				function lint()
				{
					self.colorCode()
				}
				setTimeout(lint, 0)
			}
			
			
			//
			// post key down
			// 
			CCp.postBrowserAction = function ()
			{
//				if (!this.postBrowserActionPending)	return

				
//				this.postBrowserActionPending--
				this.dumpUndoStack()
				var sel = getSelection()

				if (sel.type == 'None')	return

				var str = ''

				var self = this

				this.birdViewNode.innerHTML = this.keydownStr
				this.birdViewNode.innerHTML += str
				
				str += '<br>newLineCount=' + this.lineCount
				str += '<br>newCaretLineNumber=' + this.caret.lineNumber
//				if (this.editState.rangeText)
				{
					str += '<br>rangeText=<pre>' + this.editState.rangeText + '</pre>'
				}

				var caret = this.caret
				var mode = 'moving'
				var typingAction
				var lineChangeCount = this.lineCount - this.editState.lineCount

				var reason
				if (!this.editState.isMoving)
				{
					if (this.lineCount != this.editState.lineCount || this.caret.line.text != this.editState.caretLineText) mode = 'typing'
					// If we were typing and now have a range selection, close it (handles actions like select all, check action name to not close tab actins)
//					if (sel.type == 'Range' && this.currentEditAction && !this.currentEditAction.name)	this.closeEditAction()
//				alert('k' + mode + '\n' + this.editState.caretLineText)
/*
					if (this.lineCount != this.editState.lineCount)	mode = 'typing', typingAction = this.lineCount > this.editState.lineCount ? 'added lines' : 'removed lines'
					else
					if (this.caret.line.text != this.editState.caretLineText)	mode = 'typing', reason = 'typed'
*/
				}

				str += '<br>mode=' + mode
				if (mode == 'typing')	str += ' reason=' + reason
				str += '<br>caret=' + this.caret.line.node.innerText

				if (mode == 'typing')	
				{
					if (!this.currentEditAction)	
					{
						this.currentEditAction = this.newEditAction()
						this.currentEditAction.rangeSelection	= this.editState.rangeSelection
					}
					if (this.editState.rangeText)
					{
						str += '<br>HasRange=' + String(getSelection()).length
						str += '<br>is collapsed=' + getSelection().isCollapsed
						str += '<br>this.currentEditAction=' + this.currentEditAction
						
						this.caret.line.node.id		= this.actionId
						this.currentEditAction.text	= this.editState.rangeText
						this.currentEditAction.lastLineVisited	= this.caret.lineNumber
						this.currentEditAction.rangeSelection	= this.editState.rangeSelection

//						if (this.currentEditAction.name == 'tab')
//							this.closeEditAction()
					}
					else
					{
						this.currentEditAction.lastLineVisited = this.caret.lineNumber
						if (this.caret.line.node.id != this.currentEditAction.id && !this.currentEditAction.text)
						{
							this.currentEditAction.text = this.editState.caretLineText
							this.caret.line.node.id = this.actionId
						}
						// Deleted a line
						if (this.lineCount < this.editState.lineCount)
						{
							// Deleted previous line
							if (this.editState.caretLineNumber > this.caret.lineNumber)
							{
								if (this.editState.previousLineId != this.actionId) this.currentEditAction.text = this.editState.previousLineText + this.currentEditAction.text
							}
							else
							{
								if (this.editState.nextLineId != this.actionId) this.currentEditAction.text += this.editState.nextLineText
							}
							this.caret.line.node.id = this.actionId
						}
						// Inserted a line
						if (this.lineCount > this.editState.lineCount)
						{
							this.caret.previousLine.line.node.id = this.actionId
						}
						
						
						// Brace handling : indent after {, outdent after }
						if (lineChangeCount == 1)
						{
							if (this.caret.previousLine.text.match(/^\s*\{/))
							{
								this.caret.text = this.caret.leftText + '\t' + this.caret.rightText
								this.caret.rightChar.select()
							}
						}
						if (this.caret.line.text.match(/^\s*\}(\n)?$/))
						{
							this.caret.text = this.caret.text.replace(/\s\}/, '}')
							this.caret.leftChar.select()
						}
						
					}
				}
//return				

//				this.editState.rangeText = this.textFromRangeSelection(true)
				
				str += '<hr>'
/*				
				this.editState.mode = mode
				
//				if (this.editState.caretLineNumber == )
				
				
				// Check editingForSure
				var lineCount = this.lineCount
				var lineCountChanged = lineCount != this.previousLineCount
				str += '<br>lineCountChanged=' + (lineCountChanged  ? ('<b>YES</b> ' + this.previousLineCount + '->' + lineCount) : 'no')

				// Check if linetext changed
				var lineTextChanged = false
				if (sel.baseNode)
				{
					var lineText 		= this.lineNodeFromNode(sel.baseNode).innerText
				
					lineTextChanged = lineText != this.previousLineText
					str += '<br>lineTextChanged=' + (lineTextChanged ? '<b>YES</b>' : 'no')
				}
				str += '<br>Selection is range=' + (sel.type == 'Range' ? '<b>YES</b>' : 'no')
				
				var type = 'moving'
				if (!this.movingForSure && (lineCountChanged || lineTextChanged)) type = '<b style="color: red; font-size: 150%">editing</b>'
				str += '<br>TYPE=' + type
*/				
//				str += '<hr><pre>' + dumpSelection()
/*
				var s = this.selectionAsLineAndOffset()
				str += '<br>line=' + s.line
				str += '<br>lineCount=' + this.lineCount()
*/
				
				this.birdViewNode.innerHTML += str
				
				
//				this.previousLineCount = lineCount
				
				
				
				//
				//
				// 
				// 
				// 
				// 
				// 
				
				this.highlightSelectedLine()
				if (sel.type == 'Range' || mode == 'moving') return
				this.colorCode()
			}
/*			
			CCp.DOMCharacterDataModified = function ()
			{
				// Called from keydown
				if (this.postBrowserActionPending)	return
//				if (!this.editState.savedDuringMouseUp)	return
//				alert('k')
//				alert(this.postBrowserActionPending)
				document.getElementById('orderDump').innerHTML += ' <b>DOMMOD</b> '
//				alert(dumpHash(this.editState) + ' ' + getSelection().type)
				// Called from Character viewer, text has been saved during mouseup
				var text = this.editState.rangeText// || this.editState.caretLineText
//				alert(this.lineNodeFromNode(event.target).innerText)
//				alert('***' + text + '\n****\n' + dumpHash(this.editState))
//				alert(dumpHash(event))
				this.saveUndoable()
				if (getSelection().type == 'Caret')	this.editState.caretLineText = text
				else								this.editState.rangeText = text
				
//				alert('state1=' + this.editState.rangeText)
//				alert('state1b=' + text)
			}
*/
			CCp.cut = function ()
			{
				// Called from keydown
				if (this.postBrowserActionPending)	return
				
				this.saveUndoable()
			}

			//
			// Override paste to create new lines and mark them (insertNewlineBelow() does this)
			//	If we could reenter right after Webkit's paste, we'd just have to fixup existing text
			// 
			// http://developer.apple.com/documentation/AppleApplications/Conceptual/SafariJSProgTopics/Tasks/CopyAndPaste.html#//apple_ref/doc/uid/30001234
			CCp.paste = function ()
			{
				this.saveUndoable()
				this.currentEditAction		= this.newEditAction()
				this.currentEditAction.text	= this.textFromRangeSelection(true)

				var sel			= getSelection()
				var clipboard	= event.clipboardData
				var text		= clipboard.getData('Text')

				// We'll handle paste as we need to create one DIV per line
				event.preventDefault()
				event.returnValue = false
				
				// Delete selection if we have a range
				this.caret.deleteTo(this.caret2)
				var rightText = this.caret.rightText
				
				var lines = clipboard.getData('Text').split('\n')
				this.caret.line.text = this.caret.leftText + lines[0]
				var line = this.caret.line
				for (var i=1; i<lines.length; i++)
				{
					line = line.insertNewlineBelow()
					line.text = lines[i]
				}
				var o = line.text.length-1
				line.text = line.text.replace(/\n/g, '') + rightText
				this.caretSelection = { line : line, offset : o }
			}
			
			CCp.scroll = function ()
			{
				document.getElementById('selectionDump').innerHTML = getTickCount() + ' scroll'
			}



			
			CCp.highlightSelectedLine = function ()
			{
				var sel			= getSelection()
				if (sel.type == 'Range' || !this.nodeIsInEditor(sel.baseNode))	return this.selectedLine.style.visibility = 'hidden'

				var line	= this.lineNodeFromNode(sel.baseNode)
				this.selectedLine.style.visibility = ''
				if (!line)	return

				this.selectedLine.style.top		= line.offsetTop + 'px'
				this.selectedLine.style.height	= (line.offsetHeight+1) + 'px'

				var o = {}
				this.replaceTabsInLine(this.caret.text.substr(0, this.caret.offset), null, null, o)
				this.selectedLinePosition.innerHTML = (this.caret.lineNumber+1) + ',' + (o.totalWidth+1)
			}
			
			//
			// Register actions to be performed in the next run loop cycle
			// 
			CCp.performAfterDelay = function (fnName, delay)
			{
				if (!this.delayedPerformsCache)
				{
					this.delayedPerformsCache = {}
					this.delayedPerformCount = 0
				}
				this.delayedPerformCount++
				var self= this
				var id
				var fn	= function () { self[fnName].apply(self); delete self.delayedPerformsCache[id] }
				id = setTimeout(fn, delay || 0)
				this.delayedPerformsCache[id] = fn
			}
			
			//
			// (Called from Cocoa) 
			//	Cocoa overrides WebHTMLView's keyDown, which call the original method then the browser handler,
			//	then exhausts any actions. The browser's handler has changed state and CC can react to them.
			//	This removes flicker, as CC is done after the browser's keydown has updated the page.
			//
			CCp.exhaustDelayedPerforms = function ()
			{
				if (!this.delayedPerformsCache)	return
				for (var id in this.delayedPerformsCache)
				{
					this.delayedPerformsCache[id]()
					clearTimeout(id)
				}
				this.delayedPerformsCache = {}
			}



			//
			// Init a code colorer and load some text in it
			//
			var cc = new CodeColorer(	document.getElementById('coloredCode'), 
										document.getElementById('coloredCodeContainer'), 
										document.getElementById('birdView'))
			
			var textarea = document.getElementsByTagName('TEXTAREA')[0]


			cc.loadText(textarea.value)

//			var JSLINT = JSLintWithLogs({})
//			cc.loadText(JSLINT.toString())
			
			
			function	undo()
			{
				cc.undo()
			}
			function	redo()
			{
				cc.redo()
			}
			function	paste()
			{
				cc.paste()
			}
			function	dumpUndoStack()
			{
				cc.dumpUndoStack()
			}



			function	focusHighlighted()
			{
//				cc.editorNode.focus()
//				getSelection().collapseToStart()				
				cc.colorCode()
			}
			setTimeout(focusHighlighted, 10)
			
/*			
			function	clearDumps()
			{
				document.getElementById('dump2').innerHTML = ' '
				document.getElementById('dump3').innerHTML = ' '
				document.getElementById('dump4').innerHTML = ' '
				document.getElementById('dump5').innerHTML = ' '
				document.getElementById('dump6').innerHTML = ' '
			}
*/


			function	dumpSelection()
			{
					function dumpSelectionNode(name)
					{
						var node = sel[name + 'Node']
						var offset = sel[name + 'Offset']
						if (!node)	return str += name + '=(null)<br>'
						var t = ''
//						str += '\n' + name + '(' + offset + ')=' + (t)

						str += '<tr><td style="color: blue">' + name + '<td>' + cc.lineNumberFromNode(node) + '<td>' + offset


						var o = cc.caretFromNodeAndOffset(node, offset)
						str += '<td>' + o.line + ',' + o.offset + ' &nbsp; l=' + (cc.textFromLine(cc.lineNodeFromNode(node)) || '').length

							str += '<tr><td colSpan="4">'
						if (node.nodeType == 3) 
						{
							t = node.nodeValue
							str += '<span style="color:#a00">*</span>' + t.substr(0, offset) + '<span style="color:red">*</span>' + t.substr(offset) + '<span style="color:#a00">*</span>'
							str += ' length=' + t.length
						}
						if (node.nodeType == 1) 
						{
//							t = node + '->' + htmlEncode(cc.textFromLine(node).substr(0, 80))
							t = htmlEncode(cc.textFromLine(node).substr(0, 80))
							var line = cc.lineNumberFromNode(node)
							str += '<span style="color: lime">DIV</span> line=' + line + ' content=' + node.innerText
						}

//						str += '<span style="color: blue">' + (lineNumber+1) + ',' + (offset2+1) + ' <span style="efont-size: 50%; opacity: 0.5">' + lineNumber + ',' + offset2 +  '</span></span>'
//						str += '<span style="color: blue">' + (lineNumber) + ',' + (offset2) + '</span>'
						str += '<br><br>'
					}
				var sel = getSelection()
				var str = '<table class="selectionDump" eborder="1" style="border-collapse: collapse; table-layout: fixed">'
				str += '<tr class="header"><td>name</td><td>line</td><td>offset</td><td><nobr>line, lineoffset, length</nobr></td></tr>'
					dumpSelectionNode('base')
					dumpSelectionNode('anchor')
					dumpSelectionNode('extent')
					dumpSelectionNode('focus')
					str += '</table>'
/*
				str += '<pre>' + dumpHash(sel) + '</pre>'
				try
				{
				var r = sel.getRangeAt(0)
				if (r)		str += '<hr><pre>' + dumpHash(r) + '</pre>'
				} catch (e) {}
*/				
				return str
			}




			function ds()
			{
				document.getElementById('selectionDump').innerHTML = getTickCount() + '<br>' + dumpSelection()
/*
				cc.pushSelection2()
				cc.popSelection2()
				
				var sel = getSelection()
				function	saveSelectionPiece(name)
				{
					var node = sel[name + 'Node']
					var offset = sel[name + 'Offset']
					var line = cc.lineNumberFromNode()
					var o1 = cc.lineAndOffsetFromNodeAndOffset(node, offset)
					
					var o2 = cc.nodeAndOffsetFromLineAndOffset(o1.line, o1.offset, o1.isDiv)
					
					document.getElementById('selectionDump').innerHTML += name + '(RAW)=' + node + ',' + offset + '<br>'
					document.getElementById('selectionDump').innerHTML += name + '(lineOffset)=' + o1.line + ',' + o1.offset + ' '
					document.getElementById('selectionDump').innerHTML += (o1.isDiv?'<b style="background-color: lime; color: red">DIV</b>':'') + '<br>'
					document.getElementById('selectionDump').innerHTML += name + '(nodeOffset)=' + o2.node + ',' + o2.offset + '<br>'
					var nodeEQ = (o2.node == node)
					var offsetEQ = (o2.offset == offset)
					document.getElementById('selectionDump').innerHTML += 'nodeEQ=' + nodeEQ + ' offsetEQ=' + offsetEQ + ' '
					document.getElementById('selectionDump').innerHTML += (nodeEQ && offsetEQ) ? '<span style="color: lime">OK</span>' : '<span style="color: red">NO</span>'
					document.getElementById('selectionDump').innerHTML += '<br>'
//					return { lineNumber : line, isDIV : isDIV, }
					return o1
				}
				var saved = {}
				saved.base		= saveSelectionPiece('base')
				saved.anchor	= saveSelectionPiece('anchor')
				saved.extent	= saveSelectionPiece('extent')
				saved.focus		= saveSelectionPiece('focus')
*/				
/*				
				var n = document.getElementById('coloredCode').firstChild
				sel.setBaseAndExtent(n, 0, n, 0)

				var base = cc.nodeAndOffsetFromLineAndOffset(saved.base.line, saved.base.offset)
				var extent = cc.nodeAndOffsetFromLineAndOffset(saved.extent.line, saved.extent.offset)
				sel.setBaseAndExtent(base.node, base.offset, extent.node, extent.offset)
*/

/*
				restoreSelectionPiece(name, o1)
				{
					var o2 = cc.nodeAndOffsetFromLineAndOffset(o1.line, o1.offset, o1.isDiv)
					sel[name + 'Node'] = o2.node
					sel[name + 'Offset'] = o2.offset
				}
				restoreSelectionPiece('base', saved.base)
				restoreSelectionPiece('anchor', saved.anchor)
				restoreSelectionPiece('extent', saved.extent)
				restoreSelectionPiece('extent', saved.extent)
*/				
				
//					dumpSelectionNode('base')
//					dumpSelectionNode('anchor')
//					dumpSelectionNode('extent')
//					dumpSelectionNode('focus')
				
//				document.getElementById('selectionDump').innerHTML += '<br>PUSH / POP 2<br><br>'
//				document.getElementById('selectionDump').innerHTML += getTickCount() + '<br>' + dumpSelection()
			}
			function	dumpLines()
			{
				var str = ''
//				str += cc.editorNode
				var lines = cc.editorNode.childNodes
				for (var i=0; i<lines.length; i++)
				{
					var line = lines[i]
					str += '<br>' + i + '=' + (line.id||'')
				}
				document.getElementById('linesDump').innerHTML = getTickCount() + '<br>' + str
				
				dumpUndoStack()
			}
//			setInterval(ds, 100), ds()
//			setInterval(dumpLines, 100), dumpLines()
//			setInterval(dumpUndoStack, 100)
			
//			alert('exhaust')
			
			function	testArrow()
			{
				var n = document.createElement('CANVAS')
				document.body.appendChild(n)
				n.style.border = 'solid 1px red'
				n.style.position = 'absolute'
				n.style.zIndex = 20
				n.style.top = '0px'
				n.width = 200
				n.height = 200
				var canvas = n
				var ctx = canvas.getContext('2d');  
	  

				ctx.fillStyle = ctx.strokeStyle = "rgb(83, 180, 255)"
				ctx.fillStyle = ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)'

				ctx.beginPath()
				ctx.arc(75, 60, 2, 0, Math.PI*2)
				ctx.fill()

				ctx.beginPath()
				ctx.moveTo(75, 60)
				ctx.quadraticCurveTo(25, 90, 75, 150)
				ctx.stroke()

				ctx.translate(75, 150)
				ctx.rotate(-0.7)
				ctx.scale(0.9, 0.9)
				ctx.stroke()
				ctx.beginPath()

				ctx.moveTo(3, 0)
				ctx.lineTo(-3, 0)
				ctx.lineTo(0, 8)
				ctx.lineTo(3, 0)
				ctx.fill()
			}
//			testArrow()
		</script>

<pre>

</body>
</html>
