<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Highlighter</title>
	<style>
		html, body
		{
			margin: 0;
			padding: 0;
		}
		body
		{
			font-size: 80%;
			ebackground-color: rgb(255, 255, 240);
		}
		textarea
		{
			width: 100%;
			height: 500px;
			ecolor: rgba(255, 255, 255, 0.1);
			background-color: transparent;
			font-family: courier;
			font-family: Andale Mono;
			font-family: Monaco;
			font-size: 7pt;
		}
		td
		{
			vertical-align: top;
			width: 50%;
		}
		#highlighted, #fontWidthMeasurer
		{
			position: relative;
			white-space: pre-wrap;
			emargin-left: 20px;
			font-family: monaco;
			font-size: 7pt;
			outline: none;
			eborder: solid 1px #aaa;
			-webkit-user-modify: read-write;
		}
		#sourceContainer
		{
			height: 100%;
			overflow-y: scroll;
			position: relative;
		}
		
		
		.line
		{
			ebackground-color: #fafafa;
			eposition: relative;
			line-height: 1.3em;
			min-height: 1.3em;
		}
		.selectedLine
		{
			background-color: lime;
			background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#eee));
			border: solid 1px #bbb;
			border-left: 0;
			border-right: 0;
			margin: -1px 0;
		}
		
		#dumpHighlighted
		{
		}
		#dump5
		{
			white-space: normal;
		}
		
		
		/* source styling */
		.keyword
		{
			color: rgba(51, 28, 255, 1);
			text-shadow: rgba(51, 28, 255, 0.9) 0px 0px 1px, rgba(51, 28, 255, 1) 0px 0px 0px;
		}
		.exps
		{
			color: red;
		}
		.number
		{
			color: green;
		}
		.string
		{
			color: purple;
		}
		.comment
		{
			color: rgb(83, 180, 255);
			ecolor: #888;
		}


/*		
		.newline:before
		{
			content: '¶';
		}
		.space:before
		{
			content: '·';
		}
		.tab:before
		{
			content: '→';
		}
*/
/*
		.newline, .space, .tab
		{
			color: rgb(83, 180, 255);
			eposition: absolute;
		}
*/

		.newline
		{
		}
		.newline-normal
		{
			white-space: normal;
		}

		/* source styling */


		.tabspaceviewer
		{
			white-space: pre;
			font-family: monaco;
			font-size: 7pt;
		}

		.visualtab
		{
			background-color: red;
			position: absolute;
			display: inline-block;
			border-left: solid 1px #ddd;
			height: 800px;
		}

		.fakeTab
		{
/*
			eborder: solid 1px red; 
			height: 2px; 
			background-color: lime;			
*/
		}
		
		#fontWidthMeasurer
		{
			position: absolute;
			top: -30000px;
		}
		#rawSourceFromLineExtractor
		{
			display: none;
		}
/*		
		.bubble
		{
			position: absolute; 
			letter-spacing: 0px; 
			width: 800px;
			background-color: yellow;
			position: absolute;
			z-index: 100;
		}
*/
		.bubble
		{

			padding: 3px 9px;
			padding-bottom: 5px;
			background: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.2)), to(rgba(0, 0, 0, 0.2)));
			background-color: red;
			text-shadow: rgba(0, 0, 0, 0.3) 0px -1px 1px;
			color: white;
			font-weight: bold;
			font-family: helvetica neue;
			white-space: normal;

			-webkit-border-radius: 5px;
				-webkit-box-shadow: rgba(0, 0, 0, 0.3) 0px 3px 5px;
			
			display: inline-block;
			margin-bottom: 2em;
			max-width: 160px;
			emin-width: 80px;
		}
		.bubbleWrapper
		{
			position: absolute;
			z-index: 8;
		}
		.warningContainer
		{
			font-size: 9pt;
			position: relative;
			eborder: solid 1px lime;
		}


		#lineNumbers
		{
			position: absolute;
			width: 25px;
			border-right: solid 1px #eee;
			background-color: #f8f8f8;
		}
		#highlightedContainer
		{
			padding-left: 30px;
			position: relative;
		}
		#highlighted, #highlightedContainer
		{
			position: relative;
		}
		
		.lineNumber
		{
			font-size: 50%;
			color: #ccc;
			text-align: right;
			padding-right: 1px;
		}
		.l10
		{
			color: #888;
		}
		
</style>
</head>
<body>

<table eborder='1' style='table-layout: fixed; width: 100%; height: 800px' cellPadding='0' cellSpacing='0'><tr>
<td>
	<div id='sourceContainer'><div id='bubbleContainer'></div><div id='lineNumbers'></div><div id='highlightedContainer'><div id='highlighted'></div></div></div>
</td><td style='width: 200px'><div id='birdView'></div></tr></table>


	<textarea style='display: none'>
		var a = 'hello'
var b = "world"
var c = 'hello I\'m home'

if ('blah'.match(/[a-zA-Z0-4]/))
{
	// do something
	var d = 8.0
}

function doSomething(pa, pb, pc)
{
	
	function	fn2(pz)
	{
		return z+pa
	}
	function fn32(tryme)
	{
		return tryme+pc + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow
	}
	function fn4(pz)
	{
		return
	}
	var d = pb+pc+globalVar
	return a*b+c
}

var ccc = 'hello'
/*md
	some comment
*/
function somethingElse(z)
{
	if (!z)	return
	if (z == 2)	return z+2
	return z*2
}

&lt;?math ?&gt;
for (var i=0; i<10; i++)
{
	// do stuff ...
	for (var i=10; i>0; i--) { /* some more stuff ... */ }

}

	&lt;?math 2
		hop
		la
	?&gt;
	
// end line !
var c = 3+a2*5
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
</textarea>


<!-- Measures the width of one char -->
<div id='fontWidthMeasurer'><span>*</span> measures font width</div>
<!-- readRawSourceFromLine copies line in here and reads it. As the process is destructive, copying it won't affect original source -->
<div id='rawSourceFromLineExtractor'></div>

	<pre id='dump'></pre>



<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
</tr></table>
	<button onclick="clearDumps()">Clear</button>
	<pre id='dump4'></pre>
	<pre id='dump5'></pre>
	<pre id='dump6'></pre>

	<script src="crockford/json2.js"></script>
	<script src="crockford/fulljslint.js"></script>
	<script src='showdown.js'></script>

		<script>
			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}


			var charWidth = document.getElementById('fontWidthMeasurer').firstChild.offsetWidth
		
			var textarea = document.getElementsByTagName('TEXTAREA')[0]
			var source = textarea.value
			var highlighted = document.getElementById('highlighted')
			
			var lines = source.split('\n')
			
			var src = []

			// Each line will be enclosed in a div, thereby enabling padding it to show info bubbles
			var lineElementName = 'DIV'
			var prefix = '<' + lineElementName + ' class="line">'
			var suffix = '\n</' + lineElementName + '>'
			// Display all lines as raw text
			for (var i=0; i<lines.length; i++)
			{
				var l = htmlEncode(lines[i])
				l = replaceTabInLine(l, l)
				l = prefix + l + suffix
				src.push(l)
			}
			highlighted.innerHTML = src.join('')
			
			function	dumpHighlighted()
			{
				var str = getTickCount() + '\n'
				str += '<textarea id="dumpHighlighted">' + highlighted.innerHTML + '</textarea>'
				document.getElementById('dump2').innerHTML = str
			}
			
			function	dumpInternalSource()
			{
				document.getElementById('dump3').innerHTML = lines.join('\n')
			}
			
			
			function	lineNodeFromNode(node)
			{
				while (node)
				{
					if (node.nodeType == 1 && node.className.match(/\bline\b/))
						return node
					node = node.parentNode
				}
			}
			
			function	lineNumberFromNode(node)
			{
				node = lineNodeFromNode(node)
				if (!node)	return
//				return parseFloat(node.id.match(/\d+/))
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			function	nodeFromLineNumber(i)
			{
				return highlighted.childNodes[i]
			}

			// Inner offset : counting tab as ONE character
			function	characterOffsetFromLineAndNode(node)
			{
				
			}
			
			
			
			function	toStringToken(o)
			{
				if (!o)	o = this
//				return this.value + '(' + this.line + ':' + this.from + '->' + this.character + ')'
				return o.value + '(' + o.from + '->' + o.character + ')'
			}
			
			var tokensByLine
			var functionLines
			function	logToken(token)
			{
				var line = token.line
				
//				token.toString = toStringToken
				
				if (!tokensByLine[line])	tokensByLine[line] = []
				tokensByLine[line].push(token)
			}
			function	logStatement(statement)
			{
			}


			function	logFunctionStart(startToken)
			{
				functionLines.push(startToken.line)
//				alert(startToken.line + ' ' + startToken)
			}
			function	logFunctionEnd(startToken, endToken)
			{
			}

			
			function	lintLines(lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }
				
				tokensByLine = {}
				functionLines = []
    			tree = JSLINT(lines, options)
//alert(lines + '\n********\n' + tree)
//				alert(dumpHash(tokensByLine))
//				if (!tree)
				{
//					alert('FAIL')
//					return
				}
				
				return { tokens : tokensByLine, res : !!tree, functionLines : functionLines, errors : JSLINT.errors }
			}
			
			
			function	makeWhitespaceVisible(space)
			{
//				space = space.replace(/ /g, '<span contentEditable="false"><span class="space"></span></span> ')
//				space = space.replace(/\t/g, '<span contentEditable="false"><span class="tab"></span></span>	')
				return	space					
			}
			
			function	replaceTabInLine(line, html)
			{
				var tabLengths = []
				function	countTabs(str, idx)
				{
					var length = (idx+deltaTabPosition) % tabLength
					length = tabLength - length
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition += length-1
					
					tabLengths.push(length)
				}
				var tabIndex = 0
				function	replaceTabs(str, idx)
				{
					// A tab is surrounded by a SPAN nulling its width (with negative letter-spacing) and padding it to the correct 4-size with charWidth (measured in fontWidthMeasurer)
					return '<span class="fakeTab" style="letter-spacing: -' + charWidth + 'px; padding-right: ' + tabLengths[tabIndex++]*charWidth + 'px">	</span>'
//					return '<span class="fakeTab" >	</span>'
				}
				var tabLength = 4
				var deltaTabPosition = 0

				line.replace(/\t/g, countTabs)
				html = html.replace(/\t/g, replaceTabs)

				return	html
			}
			function	writeTokensToLine(node, tokens, line)
			{
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
//					keep an index of current char, copy from source string with splice or substring if not there
					if (token.value && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						str += htmlEncode(space)
					}
					var c = ''
					var v = token.value
					v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
/*
						// Single line markdown comment
						if (v.match(/^\/\/md/))
						{
							v = v.replace(/^\/\/md\s?/, '')
							v = MarkDownConverter.makeHtml(v)
							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
						}
*/
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length)
				{
					var space = line.substr(lastIndex)
					str += htmlEncode(space)
				}
				
				// Treat newlines in lines empty or containing only tabs as white-space: pre (so the caret lets you stop on them), use white-space: normal for the rest
				if (line.match(/^(\t*)\n$/))	str = str.replace(/\n/, '<span class="newline">\n</span>')
				else 							str = str.replace(/\n/, '<span class="newline-normal">\n</span>')

				// TABS ! sized to any size you want.
				str = replaceTabInLine(line, str)
				
				node.innerHTML = str
			}

			//
			// Get raw text from highlighted line
			//
			function	readRawSourceFromLineQuicker(line)
			{
/*
				// Restore newlines
				var ns = line.getElementsByClassName('newline')
				for (var i=0; i<ns.length; i++) 
				{
					var n = ns[i]
					n.className = ''
				}
				
				// Restore tabs
				var ns = line.getElementsByClassName('fakeTab')
				for (var i=0; i<ns.length; i++) 
				{
					var n2 = document.createElement('SPAN')
					n2.className = 'realTab'
					n2.innerText = '\t'
					ns[i].insertAdjacentElement('beforeBegin', n2)
				} 
*/
				var t = line.innerText
				// innerText removes \n when using white-space: normal (we need it to make tabs show up)
				if (line.lastChild && line.lastChild.nodeType == 1 && line.lastChild.className == 'newline-normal')	t += '\n'
				return	t
			}
			
			function	readRawSourceFromLine(line)
			{
/*
				var n = document.getElementById('rawSourceFromLineExtractor')
				n.innerHTML = '<div>' + line.innerHTML + '</div>'
//				alert(n.innerHTML)
//				return ''
*/
//				return	readRawSourceFromLineQuicker(n.firstChild)
				return	readRawSourceFromLineQuicker(line)
			}
			
			

			var selectionStack = []
			
			function	rawSelection()
			{
				var sel = getSelection()
//				return { anchorNode : sel.anchorNode, anchorOffset : sel.anchorOffset, extentNode : sel.extentNode, extentOffset : sel.extentOffset }
				return sel.getRangeAt(0)
			}
			function	setRawSelection(r)
			{
				var sel = getSelection()
				sel.removeAllRanges()
				sel.addRange(r)
//				sel.setBaseAndExtent(r.anchorNode, r.anchorOffset, r.extentNode, r.extentOffset)
			}
			function	selectionAsLineAndOffset()
			{
				var sel = getSelection()
				var raw = rawSelection()

				sel.modify('extend', 'left', 'paragraphboundary')
				var selectionText = sel.toString()
				var length = selectionText.length
				var range = sel.getRangeAt(0)
				var h = { type : 'Caret', line : lineNumberFromNode(sel.anchorNode), offset : length }

				setRawSelection(raw)

				return h
			}
			function	setSelectionAsLineAndOffset(line, offset)
			{
				var line = nodeFromLineNumber(line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<offset; i++)
					sel.modify('move', 'right', 'character')
			}
			function	pushCaretSelection()
			{
				selectionStack.push(selectionAsLineAndOffset())
			}
			function	popCaretSelection()
			{
				var s = selectionStack.pop()
//				alert(s.line + ' ' + s.offset)
				setSelectionAsLineAndOffset(s.line, s.offset)
			}
			function	caretSelectionOnStack()
			{
				if (!selectionStack.length)	return
				return	selectionStack[selectionStack.length-1]
			}
			
			function	pushSelection()
			{
				pushCaretSelection()
			}
			function	popSelection()
			{
				popCaretSelection()
			}
			
			
			var lineCount
			var currentLineNumber
			var currentLineText
//			var previousLineText
//			var nextLineText
			
			function	keydown()
			{
				setTimeout(postKeydown, 0)
//				alert(event.keyCode)
				var keyCode = event.keyCode
				
				
				
				var sel = getSelection()
				
				if (sel.type != 'Caret' && sel.type != 'Range')	return
				
				var line = lineNodeFromNode(sel.anchorNode)

				if (!line)
				{
					alert('Caret is not in a DIV')
					return
				}
					
				var lineNode 		= lineNodeFromNode(sel.anchorNode)
				lineCount			= highlighted.childNodes.length
				currentLineNumber 	= lineNumberFromNode(sel.anchorNode)
//				currentLineText 	= lineNode.innerText
				currentLineText		= readRawSourceFromLine(lineNode)
//				previousLineText	= lineNode.previousSibling ? lineNode.previousSibling.innerText : null
//				nextLineText		= lineNode.nextSibling ? lineNode.nextSibling.innerText : null
				

				var lineNumber = lineNumberFromNode(sel.anchorNode)

				//  Insert tab
				if (keyCode == 9)
				{
					event.preventDefault()
					var lineNumber2 = lineNumberFromNode(sel.extentNode)
					// Insert a single tab
					if (lineNumber == lineNumber2)
					{
						if (sel.type == 'Range')	sel.deleteFromDocument()
						pushCaretSelection()
//alert('1')						
						var t = currentLineText
//						lineNode.innerText = t
						var offset = caretSelectionOnStack().offset
//alert('2')						
//alert('3')						
						var left = t.substr(0, offset)
						var right = t.substr(offset)
//						alert(left + '<CARET>' + right)
//						alert('offset=' + offset + '\ntext=' + t + '\n\n\nleft=' + left + '\n\n\nright=' + right)
						var text = left + '\t' + right
						lineNode.innerHTML = replaceTabInLine(text, text)
//alert('4')						
						popCaretSelection()
						// Advance after tabbing
						sel.modify('move', 'right', 'character')
//alert('5')						
//				document.getElementById('dump6').innerHTML += '\nselectionAsLineAndOffset line=' + h.line + ', offset=' + h.offset

					}
					else
					// Move lines back and from
					{
//						alert(sel.extentNode.parentNode.innerText + ' ' + sel.extentOffset)
//						alert('tab selection TODO, account shift')
						
//						pushRangeSelection()
/*
						var str = 'when shift selecting keyboard, selection differs and selects part of the first line'
						str += '\nanchor=(' + sel.anchorOffset + ')' + lineNodeFromNode(sel.anchorNode).innerText
						str += '\nextent=(' + sel.extentOffset + ')' + lineNodeFromNode(sel.extentNode).innerText
						str += '\nbase=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\noffset=(' + sel.focusOffset + ')' + lineNodeFromNode(sel.focusNode).innerText
						alert(str)
*/
alert('SEL TAB MULTIPLE LINES')
						// Keyboard selecting lines will select the next line with a zero offset
						// happens on triple-clicking left space on tabs on a function
						if (sel.extentOffset == 0) lineNumber2--

//						alert(lineNumber + ' ' + lineNumber2)
//						alert(lineNodeFromNode(sel.baseNode).innerText)
						
						if (lineNumber2 <= lineNumber)
						{
							var tmp = lineNumber2
							lineNumber2 = lineNumber
							lineNumber = tmp
						}
						
						for (var i=lineNumber; i<=lineNumber2; i++)
						{
							alert('change innerText to READ')
							var line = nodeFromLineNumber(i)
							if (!event.shiftKey)
								line.innerText = '\t' + line.innerText
							else
							{
								line.innerText = line.innerText.toString().replace(/^\s/, '')
							}
						}
//						popRangeSelection()
					}
				}
				
				// Custom word delete handling
				if (keyCode == 8 && event.altKey)
				{
					alert('CHECK ! extent selection to previous word. if overflows line, just move it to start of line')
				}
				
				// Insert new line
				// Check enter and CTRL+O
				if (keyCode == 13 || (keyCode == 79 && event.ctrlKey))
				{
					if (sel.type == 'Caret')
					// OR if one line range
					{
						event.preventDefault()
						pushCaretSelection()
						lineNode.innerText = readRawSourceFromLineQuicker(lineNode)
						popCaretSelection()
						var l = lineNumberFromNode(sel.anchorNode)
						
						var line = lineNodeFromNode(sel.anchorNode)
						
						sel.setBaseAndExtent(line, 0, sel.anchorNode, sel.anchorOffset)
//						alert(line.innerText + '\n' + l)
//						var c = characterOffsetFromLineAndNode(sel.anchorNode, sel.anchorOffset)
						
//						sel.modify('extend', 'left', 'line')
						
						
						
						var leftLength = sel.toString().length
//						var newLine = line.innerText.substr(leftLength)
						
//						alert(l)
//						alert(lines[l])
//						alert(sel.toString().length + '\n' + line.innerText.length)
						
						var n = document.createElement(lineElementName)
						n.className = 'line'
						
						// Add \n if it's not here (happens on one-line documents)
						var rightText = line.innerText.substr(leftLength)
						if (!rightText.match(/\n/)) rightText += '\n'
						// Get space (minus \n) on cursor left
						var leftSpace = line.innerText.substr(0, leftLength).toString().match(/^\s*/).toString().replace(/(\r|\n)/g, '').toString()
						
						// Add a tab if we're pressing enter AFTER a brace
						if (line.innerText.match(/^\s*\{/) && !rightText.match(/\{/))	leftSpace += '	'
						
//						alert(line.innerText)
						
						var text = leftSpace + rightText
						text = replaceTabInLine(text, text)
						n.innerHTML = text
						
						line.insertAdjacentElement('afterEnd', n)
//						line.innerText = line.innerText.substr(0, leftLength) + '\n'
						var text = line.innerText.substr(0, leftLength) + '\n'
						lineNode.innerHTML = replaceTabInLine(text, text)

						if (keyCode == 13)
						{
							sel.setPosition(n, 0)
							if (leftSpace.length)
							{
								for (var i=0; i<leftSpace.length; i++)
									sel.modify('move', 'right', 'character')
							}
						}
						else
							sel.setPosition(sel.extentNode, sel.extentOffset)
					}
					else
					{
						// Nothing to do with a range as no newline is inserted.
					}
					
				}
				
				/*
					If Range selection, save all lines
				*/
			}
			
			var previouslySelectedLine
			function	postKeydown()
			{
				var sel = getSelection()
//				var lineNumber = lineNumberFromNode(sel.anchorNode)
				
				/*
					Maybe 
					* deleted everything
						-> just a text node left, or a br
					* backspace or delete
						-> two spans on the same line					
				*/
				
				var line = lineNodeFromNode(sel.anchorNode)
				if (!line)
				{
					// Will be called even after ALT-L (select address bar), check if we have a selection
					if (sel.type == 'None')	return
					
					alert('ADD READ')
					var newLines = highlighted.innerText.split('\n')
					highlighted.innerHTML = ''
//					alert(newLines.length)
					for (var i=0; i<newLines.length; i++)
					{
						var n = document.createElement(lineElementName)
						n.className = 'line'
						n.innerText = newLines[i] + '\n'
						highlighted.appendChild(n)
					}
					// Select the text node
					sel.setPosition(highlighted.firstChild.firstChild, 0)
					var line = lineNodeFromNode(sel.anchorNode)
				}
				
				if (previouslySelectedLine)	previouslySelectedLine.className = 'line'
				previouslySelectedLine = null
				if (sel.type == 'Caret')
				{
					previouslySelectedLine = line
					line.className += ' selectedLine'
				}
				
				var lineCount2			= highlighted.childNodes.length
				var currentLineNumber2 	= lineNumberFromNode(sel.anchorNode)
				
				var currentLineText2 	= readRawSourceFromLine(lineNodeFromNode(sel.anchorNode))

				

//alert(currentLineText + '\n\n' + currentLineText2 + '\n\n\nn1=' + currentLineNumber + '\nn2=' + currentLineNumber2)
				
				var mode = 'selecting'
				var moved = lineCount2 != lineCount
				var lineChanged = !(currentLineNumber2 == currentLineNumber && currentLineText2 == currentLineText)
				if (moved || lineChanged)
					mode = 'typing'
				
				// Custom handling for having inserted specific characters
				if (mode == 'typing' && currentLineNumber == currentLineNumber2 && currentLineText.length+1 == currentLineText2.length)
				{
					
					var s = selectionAsLineAndOffset()
					var addedChar = currentLineText2.charAt(s.offset-1)

					// If closed a block, remove a tab in front of it
					if (addedChar == '}' && currentLineText2.match(/\t\}/))
					{
						pushCaretSelection()
						var text = currentLineText2.replace(/\t\}/, '}')
						line.innerText = text
						selectionStack[selectionStack.length-1].offset--
						popCaretSelection()
					}
				}
				
/*				
				var str  = getTickCount() + ' '
				if (mode == 'typing') 	str += '<span style="color: red">' + mode + '</span>'
				else					str += mode
				
				
				if (line.previousSibling && line.previousSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red">PREVIOUS SPAN ON SAME LINE</span>'
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red"><b>NEXT</b> SPAN ON SAME LINE</span>'
*/
				// While forward or backward deleting, the next line SPAN came onto the current SPAN. Remove it
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
				{
					alert('Does this still happen ?')
					pushCaretSelection()
					line.innerText = readRawSourceFromLineQuicker(line)
					line.nextSibling.innerText = readRawSourceFromLineQuicker(line.nextSibling)
					line.innerText += readRawSourceFromLine(line.nextSibling)
					line.nextSibling.parentNode.removeChild(line.nextSibling)
					popCaretSelection()
					// Selection stays the same, nice !
				}
/*
				str += '\nchildNodesCount=' + highlighted.childNodes.length + ' \\n count=' + (highlighted.innerText.match(/\n/g)||0).length
				
				str += '\nlineCount=' + lineCount
				str += '\nlineCount2=' + lineCount2
				str += '\nlineNumber=' + currentLineNumber
				str += '\nlineNumber2=' + currentLineNumber2
				str += '\ncurrentLineText=' + currentLineText
				str += '\ncurrentLineText2=' + currentLineText2
				str += '\n!=lineCount=' + (lineCount2 != lineCount)
				str += '\n!=currentLineNumber=' + (currentLineNumber2 != currentLineNumber)
				str += '\n!=currentLineText=' + (currentLineText2 != currentLineText)
				
				document.getElementById('dump4').innerHTML = str
*/				
//				document.getElementById('dump5').innerHTML += '*PKD*line=' + currentLineNumber2
				
				
				if (mode != 'typing')	return
				
				highlightText()

//				alert(lines)
				
			}

			function	birdView(line, functionLines)
			{
				var str = ''
				for (var i=0; i<functionLines.length; i++)
				{
					var idx = functionLines[i]
					var line = lines[idx]
					str += idx + '=' + line + '<br>'
				}
				document.getElementById('birdView').innerHTML = str
				
			}
			
			var charWidth = 0
			var paddedLines = []
			
			function	replaceExtensions(src)
			{
				var idx = src.indexOf('<?')
				var idx2 = 0
				
				var tag1 = /<\?/g
				var tag2 = /\?>/g
				
				var r1
				var lastIndex = 0
				var src2 = []
				while (r1 = tag1.exec(src))
				{
//					alert(r1.index  + '\n' + dumpHash(r1))
					tag2.lastIndex = r1.index
					var r2 = tag2.exec(src)
					if (r2)
					{
						src2.push(src.substr(lastIndex, r1.index-lastIndex))
//						src2.push(src.substr(r1.index, r2.index-r1.index+2))
						var str = src.substr(r1.index, r2.index-r1.index+2)
//						alert('IN=' + str + '\n**********************')
						lastIndex = r2.index+2
					}
					else
					{
						return null
					}
//					alert(dumpHash(r1))
//					alert(dumpHash(r2))
//					alert(r.index + '\n' + (r2 ? r2.index : 'NO LASTMATCH'))
				}
				if (lastIndex)
				{
					src2.push(src.substr(lastIndex))
//					alert('EXTRACTED=' + src2.join(''))
					return src2.join('')
				}
				return	src
				
/*
				if (idx)
				{
					var src2 = src.substr(idx2, idx)
					var idx2 = src.indexOf('')
				}
*/
			}
			
			
			function	errorBubbles(lint)
			{
				var str = ''
				
				var bubbleContainer = document.getElementById('bubbleContainer')
				bubbleContainer.innerHTML = ''

				// Remove padding from bubble lines
				for (var i=0; i<paddedLines.length; i++)	
				{
					var line = nodeFromLineNumber(paddedLines[i])
					// Skip line if it's been deleted since
					if (!line)	continue
					line.style.padding = 0
				}



//				if (highlightCount > 1)	return
//					pushSelection()

				var previousLineError
				for (var i=0; i<lint.errors.length; i++)
				{
					var error = lint.errors[i]
					// Last error is null
					if (error == null)		break
					
					// This error will be made visible by the non-highlighted source
					if (error['reason'].match(/unable to continue/))	continue

					// Only show one error per line
					if (error.line == previousLineError)				continue
					previousLineError = error.line
					
					str += '<b>' + i + '</b>='
//					str += JSLINT.errors[i].line
					str += dumpHash(error)
					str += '<br>'
//					str += error['reason'] + '<br>'
//					str += i + '=' + error.reason + '<br>'
//alert(dumpHash(e))
//					str += i + '=' + e.line + '<br>'

//					var s = ''
//					for (var i=0; i<lines.length; i++) s += i + '=' + lines[i]
//					alert(dumpHash(error) + '***\n***\n' + s)
//						i = 54
//						continue
					
					setSelectionAsLineAndOffset(error.line, error.character)
					var sel = getSelection()
//					var str2 = '\nanchorNode in selection=' + (sel.anchorNode) + ' parentNode=' + htmlEncode(sel.anchorNode.parentNode.outerHTML).substr(0, 40)
					
					
					var ll = nodeFromLineNumber(error.line)
					if (!ll)
					{
						alert('NULL LINE IN LINT ERROR\n' + dumpHash(error) + '\nhighlighted.childNodes.length=' + highlighted.childNodes.length)
					}
					var t = ll.innerText
					var str = ''
					str += 'line=' + error.line + ' offset=' + error.character + ' lineLength=' + t.length + '\n'
					str += 'anchorOffset=' + sel.anchorOffset + ' text=' + sel.anchorNode.nodeValue + '!'
					var offset = error.character
					str += 'line=' + t.substr(0, offset) + '*' + t.substr(offset) + '!'
//					alert(str)
					
//					ll.innerText = t
					setSelectionAsLineAndOffset(error.line, error.character)


					// Create an empty span to measure position
					var n = sel.anchorNode
					if (n.nodeType == 3)
					{
						var span = document.createElement('SPAN')
						// Special case for tabs — as they're made by adding padding, need to go up one node
						if (n.parentNode.className == 'fakeTab')
						{
							n.parentNode.parentNode.insertBefore(span, n.parentNode.nextSibling)
						}
						else
						{
//							alert('IN THERE')
							n.parentNode.appendChild(span)
//							span.style.cssText = 'display: inline-block; width: 2px; height: 10px; background-color: red'
							// Split text node at anchorOffset : original text node, SPAN, new text node
							var n3 = document.createTextNode(sel.anchorNode.nodeValue.substr(sel.anchorOffset))
							n.parentNode.appendChild(n3)
							sel.anchorNode.nodeValue = sel.anchorNode.nodeValue.substr(0, sel.anchorOffset)
						}
					}
					else
						alert('Cannot create lint error bubble\n' + dumpHash(error))

//					span.style.borderLeft = 'solid 1px red'
//					var t = document.createTextNode('')
//					span.appendChild(t)
//					span.className = 'HOOOOOO'
//					span.innerHTML = '*'
					
//					span.innerHTML = ''
//					alert('*' + sel.anchorNode.nodeValue + '-' + sel.anchorOffset)
/*
					var n = sel.anchorNode
					var n2 = document.createElement('SPAN')
					n2.innerHTML = '<div class="bubble" contentEditable="false">' + error.reason + '</div>'
					var n3 = document.createTextNode('')
//					alert(n.nodeValue + sel.anchorOffset)
					if (n.nextSibling)	n.parentNode.insertBefore(n3, n.nextSibling)
					else				n.parentNode.appendChild(n3)
					n.parentNode.insertBefore(n2, n3)
					sel.anchorNode.nodeValue 
*/
					var line = nodeFromLineNumber(error.line)
					var x = (span.offsetLeft + highlighted.offsetLeft)
					var y = /*span.offsetTop +*/ line.offsetTop + line.offsetHeight
					var margin = span.offsetHeight
					if (line.className.match(/selectedLine/)) y++//, margin -= 2
//					alert(margin)
					
					var bubbleWrapper	= document.createElement('DIV')
					bubbleWrapper.className = 'bubbleWrapper'
					bubbleWrapper.style.top = y + 'px'
					bubbleWrapper.style.marginLeft = 0 + 'px'
//					alert(highlighted.offsetLeft)

					var bubble			= document.createElement('DIV')
					bubble.innerHTML = error.reason
					bubble.className = 'bubble'
//					n2.style.marginTop = '0px'
					
					
					bubbleWrapper.appendChild(bubble)
					bubbleContainer.appendChild(bubbleWrapper)
//					alert(bubbleWrapper.offsetHeight + '\n' + bubbleWrapper.clientHeight)

//					alert('x=' + x + '\nspan.offsetLeft=' + span.offsetLeft + '\nhighlighted.offsetLeft=' + highlighted.offsetLeft + '\nbubbleWrapper.offsetWidth=' + bubbleWrapper.offsetWidth + '\nhighlighted.offsetWidth=' + highlighted.offsetWidth)
					
					if (x+bubbleWrapper.offsetWidth > highlighted.offsetWidth)
					{
						x = highlighted.offsetWidth - bubbleWrapper.offsetWidth
					}
					bubbleWrapper.style.marginLeft = x + 'px'
					

					line.style.paddingBottom = bubbleWrapper.offsetHeight + 'px'
					
					paddedLines.push(error.line)

					
//					document.getElementById('dump6').innerHTML += str2

//					break

				}


				str = '\n<span style="color: red">' + str + '</span>'
				document.getElementById('dump5').innerHTML += str
			}
			
			function	lineNumbers()
			{
				var lineNumbers = document.getElementById('lineNumbers')
				lineNumbers.innerHTML = ''
				var lines = highlighted.childNodes
				var f = highlighted.firstChild
				var numbers = []
				var i = 1
				while (f)
				{
					var h = f.offsetHeight
					var c = 'lineNumber'
					if ((i % 10) == 0) c += ' l10'
					numbers.push('<div class="' + c + '" style="height: ' + h + 'px">' + i++ + '</div>')
					f = f.nextSibling
				}
				lineNumbers.innerHTML = numbers.join('')
			}
			
			
			var highlightCount = 0
			
			//
			// Highlight
			// 
			function	highlightText()
			{
				var str = 'childNodes.length=' + highlighted.childNodes.length + ' innerText.newlineCount=' + highlighted.innerText.match(/\n/g).length
				str += ' newline-normal=' + document.getElementsByClassName('newline-normal').length + ' newline=' + document.getElementsByClassName('newline').length
				document.getElementById('dump4').innerHTML = str

				highlightCount++
				charWidth = document.getElementById('fontWidthMeasurer').firstChild.offsetWidth
				lines = []
				var f = highlighted.firstChild
				while (f)
				{
					var text = readRawSourceFromLineQuicker(f)
					lines.push(text)
					
					if (text.indexOf('<?') != -1)
					{
//						alert('ext start line=' + text)
					}
					
					f = f.nextSibling
				}
//				var src = lines.join('')
//				src = replaceExtensions(src)
//				lines = src.split('\n')
//				for (var i=0; i<lines.length-1; i++)	lines[i] += '\n'
/*				if (src.match(/<\?/))
				{
					function	r(a, b, c, d)
					{
//						alert(a + '!' + String(a).indexOf('\n'))//+ ' ' + b)
						
					}					
					src.replace(/<\?.*\?>/g, r)
				}
*/				
//				alert(lines.join('').substr(0, 200))
				var lint = lintLines(lines)
//				var lint = lintLines(src)
				


				//
				// Highlight
				//
				pushCaretSelection()
				
				var f = highlighted.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					writeTokensToLine(f, tokens, line)
					
					f = f.nextSibling
					i++
				}
				
				
				//
				// Bird view
				// 
				birdView(lines, lint.functionLines)
//				alert(lint.errors)


				//
				// Save selected line's className
				// 
				var selectedLineClassName
				if (previouslySelectedLine)
				{
					selectedLineClassName = previouslySelectedLine.className
					previouslySelectedLine.className = 'line'
				}
				
				
				



				var str = getTickCount() + ' highlight (' + highlightCount + ')<br>' 
				document.getElementById('dump5').innerHTML = str
				
				
				
				//
				// Show error bubbles
				// 
				
				errorBubbles(lint)
//return
//				alert(lint.errors[0].reason)
//				alert(str)
				
				
				//
				// Line numbers
				//
				lineNumbers()

//					popSelection()

				popCaretSelection()


				if (previouslySelectedLine)	previouslySelectedLine.className = selectedLineClassName
			}
			
			
			highlighted.onkeydown = keydown
			
			
			function	selectstart()
			{
//				document.getElementById('dump4').innerHTML = getTickCount() + ' selectstart'
			}
			highlighted.onselectstart = selectstart
			
			function	focusHighlighted()
			{
				highlighted.focus()

				var s = getSelection()
				s.collapseToStart()
				highlightText()
			}
			setTimeout(focusHighlighted, 10)
			
			
			
			
			function	clearDumps()
			{
				document.getElementById('dump2').innerHTML = ' '
				document.getElementById('dump3').innerHTML = ' '
				document.getElementById('dump4').innerHTML = ' '
				document.getElementById('dump5').innerHTML = ' '
				document.getElementById('dump6').innerHTML = ' '
			}

		</script>

<pre>
	<h1 style='color: red; margin-top: -50px'>
* highlight happens on caret move : left/right + up/down on overflowing lines
* try linting src, ie lines.join('')
* when option/suppr, might delete an endline. need to restore it
	deleted newline : 
		* enter to create a line
		* new tab
		* type some text
		* option suppr
		-> no newline
* remove all innerText refs
* post deleting everything : lint bubbles error without beeing able to find the matching line node
	</h1>
	everything on the same line : white-space: wrap
	retour lign : white-space: pre-wrap


</body>
</html>
