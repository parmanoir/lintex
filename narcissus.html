<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Highlighter</title>
	<style>
		body
		{
			font-size: 80%;
			ebackground-color: rgb(255, 255, 240);
		}
		textarea
		{
			width: 100%;
			height: 500px;
			ecolor: rgba(255, 255, 255, 0.1);
			background-color: transparent;
			font-family: courier;
			font-family: Andale Mono;
			font-family: Monaco;
			font-size: 7pt;
		}
		td
		{
			vertical-align: top;
			width: 50%;
		}
		#highlighted
		{
			white-space: pre;
			margin-left: 20px;
			font-family: monaco;
			font-size: 7pt;
			outline: none;
			border: solid 1px #aaa;
		}
		.line
		{
			ebackground-color: #fafafa;
			position: relative;
		}
		.selectedLine
		{
			background-color: lime;
		}
		
		#dumpHighlighted
		{
			width: 100%;
		}
		#dump5
		{
			white-space: normal;
		}
		
		
		/* source styling */
		.keyword
		{
			color: rgba(51, 28, 255, 1);
			text-shadow: rgba(51, 28, 255, 0.9) 0px 0px 1px, rgba(51, 28, 255, 1) 0px 0px 0px;
		}
		.exps
		{
			color: red;
		}
		.number
		{
			color: green;
		}
		.string
		{
			color: purple;
		}
		.comment
		{
			color: rgb(83, 180, 255);
		}


		
		.newline:before
		{
			content: '¶';
		}
		.space:before
		{
			content: '·';
		}
		.tab:before
		{
			content: '→';
		}
		.newline, .space, .tab
		{
			color: rgb(83, 180, 255);
			position: absolute;
		}

		/* source styling */
		
		
</style>
</head>
<body>

<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
	<textarea>
var a = 'hello'
var b = "world"
var c = 'hello I\'m home'

if ('blah'.match(/[a-zA-Z0-4]/))
{
	// do something
}

function doSomething(pa, pb, pc)
{
	function fn2(pz)
	{
		return z+pa
	}
	function fn32(tryme)
	{
		return tryme+pc + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow
	}
	function fn4(pz)
	{
		return
	}
	var d = pb+pc+globalVar
	return a*b+c
}

var ccc = 'hello'
/*md
	some comment
*/
function somethingElse(z)
{
	if (!z)	return
	if (z == 2)	return z+2
	return z*2
}

&lt;?minitex ?&gt;
for (var i=0; i<10; i++)
{
	// do stuff ...
}
</textarea>
	<pre id='dump'></pre>
	
</td><td>
	<div id='highlighted' contentEditable='true'></div>
</td></tr></table>
<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
</tr></table>
	<pre id='dump4'></pre>
	<pre id='dump5'></pre>
	<button onclick="document.getElementById('dump2').innerHTML = ' ', document.getElementById('dump3').innerHTML = ' ', document.getElementById('dump4').innerHTML = ' ', document.getElementById('dump5').innerHTML = ' '">Clear</button>

	<script src="crockford/json2.js"></script>
	<script src="crockford/fulljslint.js"></script>
	<script src='showdown.js'></script>

		<script>
			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}

		
			var textarea = document.getElementsByTagName('TEXTAREA')[0]
			var source = textarea.value
			var highlighted = document.getElementById('highlighted')
			
			var lines = source.split('\n')
			
			var src = []

			// Typing on an empty line deletes trailing '\n'
			// Now that I'm handling line breaking, no more problems
			var lineElementName = 'DIV'
			// OK
//			var lineElementName = 'SPAN'
			var prefix = '<' + lineElementName + ' class="line">'
			var suffix = '\n</' + lineElementName + '>'
			for (var i=0; i<lines.length; i++)
			{
				src.push(prefix + htmlEncode(lines[i]) + suffix)
			}
			highlighted.innerHTML = src.join('')
			
			function	dumpHighlighted()
			{
				var str = getTickCount() + '\n'
				str += '<textarea id="dumpHighlighted">' + highlighted.innerHTML + '</textarea>'
				document.getElementById('dump2').innerHTML = str
			}
			
			function	dumpInternalSource()
			{
				document.getElementById('dump3').innerHTML = lines.join('\n')
			}
			
			
			function	lineNodeFromNode(node)
			{
				while (node)
				{
					if (node.nodeType == 1 && node.className.indexOf('line') != -1)
						return node
					node = node.parentNode
				}
			}
			
			function	lineNumberFromNode(node)
			{
				node = lineNodeFromNode(node)
				if (!node)	return
//				return parseFloat(node.id.match(/\d+/))
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			function	nodeFromLineNumber(i)
			{
				return highlighted.childNodes[i]
			}

			// Inner offset : counting tab as ONE character
			function	characterOffsetFromLineAndNode(node)
			{
				
			}
			
			
			
			function	toStringToken()
			{
//				return this.value + '(' + this.line + ':' + this.from + '->' + this.character + ')'
				return this.value + '(' + this.from + '->' + this.character + ')'
			}
			
			var tokens
			function	logToken(token)
			{
				var line = token.line
				
//				token.toString = toStringToken
				
				if (!tokensByLine[line])	tokensByLine[line] = []
				tokensByLine[line].push(token)
			}
			function	logStatement(statement)
			{
			}
			
			function	logFunctionStart(startToken)
			{
			}
			function	logFunctionEnd(startToken, endToken)
			{
			}

			
			function	lintLines(lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }
				
				tokensByLine = { }
    			tree = JSLINT(lines, options)
//alert(lines + '\n********\n' + tree)
//				alert(dumpHash(tokensByLine))
//				if (!tree)
				{
//					alert('FAIL')
//					return
				}
				
				return { tokens : tokensByLine, res : !!tree }
			}
			
			
			function	makeWhitespaceVisible(space)
			{
//				space = space.replace(/ /g, '<span contentEditable="false"><span class="space"></span></span> ')
//				space = space.replace(/\t/g, '<span contentEditable="false"><span class="tab"></span></span>	')
				return	space					
			}
			
			function	writeTokensToLine(node, tokens, line)
			{
//				node.innerHTML = '*' + lineContent
//				alert(tokens)
				
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
//					keep an index of current char, copy from source string with splice or substring if not there
					if (token.value && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						space = htmlEncode(space)
						str += makeWhitespaceVisible(space)						
					}
					var c = ''
					var v = token.value
						v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
/*
						// Single line markdown comment
						if (v.match(/^\/\/md/))
						{
							v = v.replace(/^\/\/md\s?/, '')
							v = MarkDownConverter.makeHtml(v)
							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
						}
*/
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length)
				{
					var space = line.substr(lastIndex)
					space = htmlEncode(space)
					str += makeWhitespaceVisible(space)
				}
//str += '\n'				
				node.innerHTML = str
			}
			

			var selectionStack = []
			
			function	rawSelection()
			{
				var sel = getSelection()
//				return { anchorNode : sel.anchorNode, anchorOffset : sel.anchorOffset, extentNode : sel.extentNode, extentOffset : sel.extentOffset }
				return sel.getRangeAt(0)
			}
			function	setRawSelection(r)
			{
				var sel = getSelection()
				sel.removeAllRanges()
				sel.addRange(r)
//				sel.setBaseAndExtent(r.anchorNode, r.anchorOffset, r.extentNode, r.extentOffset)
			}
			function	selectionAsLineAndOffset()
			{
				var sel = getSelection()
				var raw = rawSelection()

				sel.modify('extend', 'left', 'lineboundary')
				var h = { type : 'Caret', line : lineNumberFromNode(sel.anchorNode), offset : sel.toString().length }

				setRawSelection(raw)

				return h
			}
			function	setSelectionAsLineAndOffset(line, offset)
			{
				var line = nodeFromLineNumber(line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<offset; i++)
					sel.modify('move', 'right', 'character')
			}
			function	pushCaretSelection()
			{
				selectionStack.push(selectionAsLineAndOffset())
			}
			function	popCaretSelection()
			{
				var s = selectionStack.pop()
//				alert(s.line + ' ' + s.offset)
				setSelectionAsLineAndOffset(s.line, s.offset)
			}
			
			
			var lineCount
			var currentLineNumber
			var currentLineText
//			var previousLineText
//			var nextLineText
			
			function	keydown()
			{
				setTimeout(postKeydown, 0)
//				alert(event.keyCode)
				var keyCode = event.keyCode
				
				
				
				var sel = getSelection()
				
				if (sel.type != 'Caret' && sel.type != 'Range')	return
				
				var line = lineNodeFromNode(sel.anchorNode)
				
				if (line.innerText.length > 1)
				{
					var brs = line.getElementsByTagName('BR')
					for (var i=0; i<brs.length; i++) brs[i].parentNode.removeChild(brs[i])
				}
//				if (sel.anchorNode == highlighted || sel.extentNode == highlighted)
				if (!line)
				{
					alert('TEXT NOT IN SPAN')
					return
				}
					
				var lineNode 		= lineNodeFromNode(sel.anchorNode)
				lineCount			= highlighted.childNodes.length
				currentLineNumber 	= lineNumberFromNode(sel.anchorNode)
				currentLineText 	= lineNode.innerText
//				previousLineText	= lineNode.previousSibling ? lineNode.previousSibling.innerText : null
//				nextLineText		= lineNode.nextSibling ? lineNode.nextSibling.innerText : null
				

				var lineNumber = lineNumberFromNode(sel.anchorNode)
//				alert(lineNumber)
				var str = keyCode + '(' + String.fromCharCode(keyCode) + ') line=' + lineNumber
				document.getElementById('dump5').innerHTML += str


				//  Insert tab
				if (keyCode == 9)
				{
					event.preventDefault()
					var lineNumber2 = lineNumberFromNode(sel.extentNode)
					if (lineNumber == lineNumber2)
					{
						if (sel.type == 'Range')	sel.deleteFromDocument()
						pushCaretSelection()
						
						var t = lineNode.innerText
						lineNode.innerText = t
						popCaretSelection()
						lineNode.innerText = t.substr(0, sel.anchorOffset) + '\t' + t.substr(sel.anchorOffset)
						sel.modify('move', 'right', 'character')
					}
					else
					{
//						alert(sel.extentNode.parentNode.innerText + ' ' + sel.extentOffset)
//						alert('tab selection TODO, account shift')
						
//						pushRangeSelection()
						var str = 'when shift selecting keyboard, selection differs and selects part of the first line'
						str += '\nanchor=(' + sel.anchorOffset + ')' + lineNodeFromNode(sel.anchorNode).innerText
						str += '\nextent=(' + sel.extentOffset + ')' + lineNodeFromNode(sel.extentNode).innerText
						str += '\nbase=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\noffset=(' + sel.focusOffset + ')' + lineNodeFromNode(sel.focusNode).innerText
						alert(str)

						// Keyboard selecting lines will select the next line with a zero offset
						// happens on triple-clicking left space on tabs on a function
						if (sel.extentOffset == 0) lineNumber2--

//						alert(lineNumber + ' ' + lineNumber2)
//						alert(lineNodeFromNode(sel.baseNode).innerText)
						
						if (lineNumber2 <= lineNumber)
						{
							var tmp = lineNumber2
							lineNumber2 = lineNumber
							lineNumber = tmp
						}
						
						for (var i=lineNumber; i<=lineNumber2; i++)
						{
							var line = nodeFromLineNumber(i)
							if (!event.shiftKey)
								line.innerText = '\t' + line.innerText
							else
							{
								line.innerText = line.innerText.toString().replace(/^\s/, '')
							}
						}
//						popRangeSelection()
					}
				}
				
				// Custom word delete handling
				if (keyCode == 8 && event.altKey)
				{
					alert('CHECK ! extent selection to previous word. if overflows line, just move it to start of line')
				}
				
				// Insert new line
				// Check enter and CTRL+O
				if (keyCode == 13 || (keyCode == 79 && event.ctrlKey))
				{
					
					if (sel.type == 'Caret')
					// OR if one line range
					{
						event.preventDefault()
						pushCaretSelection()
						lineNode.innerText = lineNode.innerText
						popCaretSelection()
						var l = lineNumberFromNode(sel.anchorNode)
						
						var line = lineNodeFromNode(sel.anchorNode)
						
						sel.setBaseAndExtent(line, 0, sel.anchorNode, sel.anchorOffset)
//						alert(line.innerText + '\n' + l)
//						var c = characterOffsetFromLineAndNode(sel.anchorNode, sel.anchorOffset)
						
//						sel.modify('extend', 'left', 'line')
						
						
						
						var leftLength = sel.toString().length
//						var newLine = line.innerText.substr(leftLength)
						
//						alert(l)
//						alert(lines[l])
//						alert(sel.toString().length + '\n' + line.innerText.length)
						
						var n = document.createElement(lineElementName)
						n.className = 'line'
						
						// Add \n if it's not here (happens on one-line documents)
						var rightText = line.innerText.substr(leftLength)
						if (!rightText.match(/\n/)) rightText += '\n'
						// Get space (minus \n) on cursor left
						var leftSpace = line.innerText.substr(0, leftLength).toString().match(/^\s*/).toString().replace(/(\r|\n)/g, '').toString()
						n.innerText = leftSpace + rightText
						
//-> COUNT line number with a LOOP						

//-> WARNING : may happen to have NO span left : select all, backspace -> plus rien
// -> detex when a span no longer contains a newline
// check selection change : if extentNode differs ?

						line.insertAdjacentElement('afterEnd', n)
						line.innerText = line.innerText.substr(0, leftLength) + '\n'

						if (keyCode == 13)
						{
							sel.setPosition(n, 0)
							if (leftSpace.length)
							{
								for (var i=0; i<leftSpace.length; i++)
									sel.modify('move', 'right', 'character')
							}
						}
						else
							sel.setPosition(sel.extentNode, sel.extentOffset)
					}
					else
					{
						// Nothing to do with a range as no newline is inserted.
					}
					
				}
				
				/*
					If Range selection, save all lines
				*/
			}
			
			var previouslySelectedLine
			function	postKeydown()
			{
				var sel = getSelection()
//				var lineNumber = lineNumberFromNode(sel.anchorNode)
				
				/*
					Maybe 
					* deleted everything
						-> just a text node left, or a br
					* backspace or delete
						-> two spans on the same line					
				*/
				
				var line = lineNodeFromNode(sel.anchorNode)
				if (!line)
				{
					// Will be called even after ALT-L (select address bar), check if we have a selection
					if (sel.type == 'None')	return
					
					var newLines = highlighted.innerText.split('\n')
					highlighted.innerHTML = ''
//					alert(newLines.length)
					for (var i=0; i<newLines.length; i++)
					{
						var n = document.createElement(lineElementName)
						n.className = 'line'
						n.innerText = newLines[i] + '\n'
						highlighted.appendChild(n)
					}
					// Select the text node
					sel.setPosition(highlighted.firstChild.firstChild, 0)
					var line = lineNodeFromNode(sel.anchorNode)
				}
				
				if (previouslySelectedLine)	previouslySelectedLine.className = 'line'
				previouslySelectedLine = null
				if (sel.type == 'Caret')
				{
					previouslySelectedLine = line
					line.className += ' selectedLine'
				}
				

				var lineCount2			= highlighted.childNodes.length
				var currentLineNumber2 	= lineNumberFromNode(sel.anchorNode)
				var currentLineText2 	= lineNodeFromNode(sel.anchorNode).innerText
				
				var mode = 'selecting'
				if (lineCount2 != lineCount || (currentLineNumber2 == currentLineNumber && currentLineText2 != currentLineText))
					mode = 'typing'
					
				
				var str  = getTickCount() + ' '
				if (mode == 'typing') 	str += '<span style="color: red">' + mode + '</span>'
				else					str += mode
				
				
				if (line.previousSibling && line.previousSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red">PREVIOUS SPAN ON SAME LINE</span>'
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red"><b>NEXT</b> SPAN ON SAME LINE</span>'

				// While forward or backward deleting, the next line SPAN came onto the current SPAN. Remove it
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
				{
					pushCaretSelection()
					line.innerText = line.innerText
					line.nextSibling.innerText = line.nextSibling.innerText
					line.innerText += line.nextSibling.innerText
					line.nextSibling.parentNode.removeChild(line.nextSibling)
					popCaretSelection()
					// Selection stays the same, nice !
				}

				str += '\nchildNodesCount=' + highlighted.childNodes.length + ' \\n count=' + (highlighted.innerText.match(/\n/g)||0).length
				
				str += '\nlineCount=' + lineCount
				str += '\nlineCount2=' + lineCount2
				str += '\nlineNumber=' + currentLineNumber
				str += '\nlineNumber2=' + currentLineNumber2
				str += '\ncurrentLineText=' + currentLineText
				str += '\ncurrentLineText2=' + currentLineText2
				str += '\n!=lineCount=' + (lineCount2 != lineCount)
				str += '\n!=currentLineNumber=' + (currentLineNumber2 != currentLineNumber)
				str += '\n!=currentLineText=' + (currentLineText2 != currentLineText)
				
				document.getElementById('dump4').innerHTML = str
				document.getElementById('dump5').innerHTML += '*PKD*line=' + currentLineNumber2
				
				
				if (mode != 'typing')	return
				
				highlightText()

//				alert(lines)
				
			}
			function	keyup()
			{
//				dumpHighlighted()
//				dumpInternalSource()
			}
			
			function	highlightText()
			{
				var lines = []
				var f = highlighted.firstChild
				while (f)
				{
					lines.push(f.innerText)
					f = f.nextSibling
				}
				var lint = lintLines(lines)
				
				highlighted.style.backgroundColor = lint.res ? '' : '#fee'


				pushCaretSelection()
				
				var f = highlighted.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					writeTokensToLine(f, tokens, line)
					f = f.nextSibling
					i++
				}
				
				popCaretSelection()
			}
			
			
			highlighted.onkeyup = keyup
			highlighted.onkeydown = keydown
			
			
			function	selectstart()
			{
				document.getElementById('dump4').innerHTML = getTickCount() + ' selectstart'
			}
			highlighted.onselectstart = selectstart
			
			function	focusHighlighted()
			{
				highlighted.focus()

				var s = getSelection()
				s.collapseToStart()
				highlightText()
//				s.setPosition(highlighted, 5)
//				s.setPosition(highlighted.firstChild.firstChild, 5)
				
//				s.setBaseAndExtent(highlighted.firstChild.firstChild, 5, highlighted.firstChild.nextSibling.firstChild, 7)
//				s.empty()
				
/*

	.	addRange: function addRange() {
	.	anchorNode: Text
	.	anchorOffset: 11
	.	baseNode: Text
	.	baseOffset: 11
	.	collapse: function collapse() {
	.	collapseToEnd: function collapseToEnd() {
	.	collapseToStart: function collapseToStart() {
	.	containsNode: function containsNode() {
	.	deleteFromDocument: function deleteFromDocument() {
	.	empty: function empty() {
	.	extend: function extend() {
	.	extentNode: Text
	.	extentOffset: 11
	.	focusNode: Text
	.	focusOffset: 11
	.	getRangeAt: function getRangeAt() {
	.	isCollapsed: true
	.	modify: function modify() {
	.	rangeCount: 1
	.	removeAllRanges: function removeAllRanges() {
	.	selectAllChildren: function selectAllChildren() {
	.	setBaseAndExtent: function setBaseAndExtent() {
	.	setPosition: function setPosition() {
	.	type: "Caret"


*/

//				alert(s)
//				zea
			}
			setTimeout(focusHighlighted, 10)

		</script>

<pre>
	Stratégie
	* parse tout : produx
		source :
			{
				lines : [ tokens : [], hash : [] ]
			}
	
	* compte les elements markdown et escape &lt;? ... ?&gt;
	* transform les et compt la hauteur
	
	* detect typing, and when 
		-> typing changes TEXT
		-> typing changes selection
		
	* when TEXT changes
		-> figure out WHAT changed
			* typing inside a function ?
			* typing a NEW function ?
			* DELETING a function ?

			* creating a new MD comment or text escape ?
			
		-> save text selection (line, offset)
		-> update html
		-> reset selection

	
	source
		all lines ?
		
		contains function list
			-> BIRDVIEW
				birdview xhib tout les sources
				
				
	DATA OWNERSHIP ? si chac document a son fich, prqoi pas.
	MAIS la birdview dev soy partage par tous.


	//
	hover variable : SHOW each assignment and usage in the function prior to it. and also the next ones.
	
	ATTENTION CTRL+O : insert line in place
	
	//
	make file links clickable, eg include('blah.js')
								-> click 'blah.js'
		

	autocomplete : highlight le symbol sur la page s'il exist.
	
	
	special case for option-backspace : delete to back of line

	design bouton : http://recaptcha.net/
	
	highlight line bar red when lint fails
	
	keying up : extent selection to line start
	
</body>
</html>
