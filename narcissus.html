<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Highlighter</title>
	<style>
		html, body
		{
			margin: 0;
			padding: 0;
		}
		body
		{
			font-size: 80%;
			ebackground-color: rgb(255, 255, 240);
		}
		textarea
		{
			width: 100%;
			height: 500px;
			ecolor: rgba(255, 255, 255, 0.1);
			background-color: transparent;
			font-family: courier;
			font-family: Andale Mono;
			font-family: Monaco;
			font-size: 7pt;
		}
		td
		{
			vertical-align: top;
			width: 50%;
		}
		#highlighted, #fontWidthMeasurer, #whiteSpaceRevealer, #tracesContainer
		{
			position: relative;
			white-space: pre-wrap;
			font-family: monaco;
			font-size: 7pt;
			outline: none;
		}
		#highlighted
		{
			-webkit-user-modify: read-write;
		}
		#sourceContainer
		{
			height: 100%;
			overflow-y: scroll;
			position: relative;
		}
		
		
		.line
		{
			ebackground-color: #fafafa;
			eposition: relative;
			line-height: 1.3em;
			min-height: 1.3em;
		}
		#selectedLine
		{
			background-color: lime;
			background: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(240, 240, 240, 0.8)));
			border: solid 1px #bbb;
			border-left: 0;
			border-right: 0;
			margin: -1px 0;
			position: absolute;
			width: 100%;
		}
		#selectedLinePosition
		{
			position: absolute;
			right: 0;
			bottom: 0;
			margin-right: 10px;
			font-size: 50%;
			opacity: 0.3;
			z-index: 300;
			cursor: pointer;
		}
		
		#dumpHighlighted
		{
		}
		#dump5
		{
			white-space: normal;
		}
		
		
		/* source styling */
		.keyword
		{
			color: rgba(51, 28, 255, 1);
			text-shadow: rgba(51, 28, 255, 0.9) 0px 0px 1px, rgba(51, 28, 255, 1) 0px 0px 0px;
		}
		.exps
		{
			color: red;
		}
		.number
		{
			color: green;
		}
		.string
		{
			color: purple;
		}
		.comment
		{
			color: rgb(83, 180, 255);
			ecolor: #888;
		}


/*		
		.newline:before
		{
			content: '¶';
		}
		.space:before
		{
			content: '·';
		}
		.tab:before
		{
			content: '→';
		}
*/
/*
		.newline, .space, .tab
		{
			color: rgb(83, 180, 255);
			eposition: absolute;
		}
*/

		.newline
		{
			display: inline-block; border: solid 1px red; height : 7px; width: 7px;
			
		}
		.newline-normal
		{
			white-space: normal;
			display: inline-block; border: solid 1px lime; height : 7px; width: 7px;
			
		}

		/* source styling */


		.tabspaceviewer
		{
			white-space: pre;
			font-family: monaco;
			font-size: 7pt;
		}

		.visualtab
		{
			background-color: red;
			position: absolute;
			display: inline-block;
			border-left: solid 1px #ddd;
			height: 800px;
		}

		.fakeTab
		{
/*
			eborder: solid 1px red; 
			height: 2px; 
			background-color: lime;			
*/
		}
		
		#fontWidthMeasurer
		{
			position: absolute;
			top: -30000px;
		}
		#rawSourceFromLineExtractor
		{
			display: none;
		}
/*		
		.bubble
		{
			position: absolute; 
			letter-spacing: 0px; 
			width: 800px;
			background-color: yellow;
			position: absolute;
			z-index: 100;
		}
*/
		.bubble
		{

			padding: 3px 9px;
			padding-bottom: 5px;
			background: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.2)), to(rgba(0, 0, 0, 0.2)));
			background-color: red;
			text-shadow: rgba(0, 0, 0, 0.3) 0px -1px 1px;
			color: white;
			font-weight: bold;
			font-family: helvetica neue;
			white-space: normal;

			-webkit-border-radius: 5px;
			-webkit-box-shadow: rgba(0, 0, 0, 0.3) 0px 3px 5px;
			
			display: inline-block;
			margin-bottom: 2em;
			max-width: 160px;
			emin-width: 80px;
			position: relative;
			z-index: 2;
			margin-left: -14px;
			margin-top: 2px;
		}
		.bubbleWrapper
		{
			position: absolute;
			z-index: 8;
		}
		.bubbleArrow
		{
			position: absolute;
			top: -21px;
			top: -3px;
			font-size: 40pt;
			-webkit-transform: rotate(180deg);
			color: red;
			margin-left: -14px;
			margin-top: 2px;
			eborder: solid 1px lime;
			ebackground-color: rgba(0, 255, 0, 0.5);
			ez-index: 20;
			height: 45px;
			overflow: hidden;
		}



		#lineNumbers
		{
			position: absolute;
			width: 25px;
			border-right: solid 1px #eee;
			background-color: #f8f8f8;
		}
		#highlightedContainer
		{
			padding-left: 30px;
			position: relative;
		}
		#highlighted, #highlightedContainer
		{
			position: relative;
		}
		
		.lineNumber
		{
			font-size: 50%;
			color: #ccc;
			text-align: right;
			padding-right: 1px;
			position: relative;
			z-index: 4;
		}
		.l10
		{
			color: #888;
		}
		
		#whiteSpaceRevealer div
		{
			color: rgb(83, 180, 255);
/*			color: #800; text-shadow: red 0px 0px 1px, red 0px 0px 0px, red 0px 0px 2px, red 0px 0px 2px;*/
			position: absolute;
		}
		
</style>
</head>
<body>
	
<table eborder='1' style='table-layout: fixed; width: 100%; height: 800px; height: 650px' cellPadding='0' cellSpacing='0'><tr>
<td>
	<div id='sourceContainer'><div id='bubbleContainer'></div><div id='lineNumbers'></div><div id='selectedLine'><div id='selectedLinePosition'></div></div><div id='highlightedContainer'><div id='tracesContainer'></div><div id='whiteSpaceRevealer'></div><div id='highlighted'></div></div></div>
</td><td style='width: 200px'><div id='birdView'></div></tr></table>

	<textarea style='display: none'>var a
	function fn1(a, b)
	{
		if (a)	{
			return a
		}
		
		while (b)
		{
			b++
			if (a)
			{
				return a
			}			
			return b
		}
		
		/* HA
			HOP !
		*/
		for (var z = 0; z&lt;4; z++)
		{
			/* world */ var i
			return z
		}
	}
	
	a++
	
	function z()	{
		if (z)
			return 'BLAH'
		do		{
		
		} while (K)
	}
	
	function zz()
	{
		if (a)
			for (a=0; a<4; a++)
			{
				if (b)
					for (z=0; z<4; z++)
						a=b
			}
	}
	</textarea>

	<textarea style='display: none'>var a = 4 £ 5 + 4
var b = hello £ world
for (var i=a £ b; i<10£2; i++,a£b) 
{
	// hello
	log(i£j)
	log(a£2)
}
</textarea>

	<textarea style='display: none'>
		var a = 'hello'
var b = "world"
var c = 'hello I\'m home'
var newop = 5*4 £ 5 + 2 £ a

if ('blah'.match(/[a-zA-Z0-4]/))
{
	// do something
	var d = 8.0
}

function doSomething(pa, pb, pc)
{
	
	function	fn2(pz)
	{
		return z+pa
	}
	function fn32(tryme)
	{
		return tryme+pc + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow
	}
	function fn4(pz)
	{
		return
	}
	var d = pb+pc+globalVar
	return a*b+c
}

var ccc = 'hello'
/*md
	some comment
*/
function somethingElse(z)
{
	if (!z)	return
	if (z == 2)	return z+2
	return z*2
}

&lt;?math ?&gt;
for (var i=0; i<10; i++)
{
	// do stuff ...
	for (var i=10; i>0; i--) { /* some more stuff ... */ }

}

	&lt;?math 2
		hop
		la
	?&gt;
	
// end line !
var c = 3+a2*5
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
	a
</textarea>


<!-- Measures the width of one char -->
<div id='fontWidthMeasurer'><span>*</span> measures font width</div>
<!-- readRawSourceFromLine copies line in here and reads it. As the process is destructive, copying it won't affect original source -->
<div id='rawSourceFromLineExtractor'></div>

	<pre id='dump'></pre>



<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
</tr></table>
	<button onclick="clearDumps()">Clear</button>
	<pre id='dump4'></pre>
	<pre id='dump5'></pre>
	<pre id='dump6'></pre>

	<script src="crockford/json2.js"></script>
	<script src="crockford/fulljslint.js"></script>
	<script src='showdown.js'></script>

		<script>
		
			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}
			function	dumpHashNoFunction(o)
			{
				var str = ''
				for (var i in o) { if (typeof o[i] == 'function') continue; str += i + '=' + (o[i].toString == toStringToken ? ('*TOKEN*'+o[i].value + '*') : o[i]) + '\n' }
				return str
			}


			var charWidth = document.getElementById('fontWidthMeasurer').firstChild.offsetWidth
		
			var textarea = document.getElementsByTagName('TEXTAREA')[0]
			var source = textarea.value
			var highlighted = document.getElementById('highlighted')
			
			var lines = source.split('\n')
			
			var src = []

			// Each line will be enclosed in a div, thereby enabling padding it to show info bubbles
			var lineElementName = 'DIV'
//			var prefix = '<' + lineElementName + ' class="line">'
//			var suffix = '\n</' + lineElementName + '>'
			// Display all lines as raw text


			function	displayRawText(lines)
			{

				for (var i=0; i<lines.length; i++)
				{
					var l = htmlEncode(lines[i])
					l = replaceTabsInLine(l, l)
					l = '<div class="line">' + l + '\n</div>'
					src.push(l)
				}
				highlighted.innerHTML = src.join('')
			}
			displayRawText(lines)
//			displayRawText([])
			
			function	dumpHighlighted()
			{
				var str = getTickCount() + '\n'
				str += '<textarea id="dumpHighlighted">' + highlighted.innerHTML + '</textarea>'
				document.getElementById('dump2').innerHTML = str
			}
			
			function	dumpInternalSource()
			{
				document.getElementById('dump3').innerHTML = lines.join('\n')
			}
			
			
			function	lineNodeFromNode(node)
			{
				while (node)
				{
					if (node.nodeType == 1 && node.className.match(/\bline\b/))
						return node
					node = node.parentNode
				}
			}
			
			function	lineNumberFromNode(node)
			{
				node = lineNodeFromNode(node)
				if (!node)	return
//				return parseFloat(node.id.match(/\d+/))
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			function	nodeFromLineNumber(i)
			{
				return highlighted.childNodes[i]
			}

			// Inner offset : counting tab as ONE character
			function	characterOffsetFromLineAndNode(node)
			{
				
			}
			
			
			
			function	toStringToken(o)
			{
				if (!o)	o = this
//				return this.value + '(' + this.line + ':' + this.from + '->' + this.character + ')'
				return dumpHashNoFunction(o) + '<hr>'
//				rez()
				return o.value + '(' + o.from + '->' + o.character + ')'
			}
			
			var tokensByLine
			var functionLines
			
			
			var	debugStr
			var debugCount
			
			
			var traceTokens
			
			
			var	tokensToTrace = { 'function' : true, 'if' : true, 'while' : true, 'do' : true, 'for' : true }
			
//			var currentlyOpenTraceIndex
			function	logToken(token)
			{
				var line = token.line
				
				token.toString = toStringToken
//				alert('TOKEN\n' + token.value + '\n' + token.left + '\n' + token.right)
				for (var i=0; i<debugCount; i++) debugStr += ' '
//				debugStr += ' TOKEN ' + token.value + '\n'
				debugStr += '<span style="color: blue">' + (token.value || token.id) + '(' + token.line + ',' + token.character + ')</span>\n'
//				debugStr += '<span style="color: blue">' + (token.id) + '(' + token.line + ',' + token.character + ')</span>\n'
//				alert(token+'\n'+dumpHash(token))
				
				/*
					Log traces
					
					functions : can start from 'function' tokens or next brace token if it's on a different line.
					
				*/
				 
				if (tokensToTrace[token.id])
				{
					traceTokens.push( { type : token.id, token : token, openingToken : token, closingToken : null } )
					var topTrace = traceTokens[traceTokens.length-1]
//					currentlyOpenTraceIndex = topTrace
				}
				if (traceTokens.length)
				{
					var topTrace = traceTokens[traceTokens.length-1]
					if (token.id == '{')
					{
						if (topTrace.openingToken.line != token.line) topTrace.openingToken = token
					}
					if (token.id == '}')
					{
						topTrace.closingToken = token
						topTrace = null
						
//						currentlyOpenTraceToken.
					}
				}
				
				if (!tokensByLine[line])	tokensByLine[line] = []
				tokensByLine[line].push(token)
			}
			function	logStatement(statement)
			{
			}
			
			
			function	logParseStart(rbp, initial)
			{
//				alert('parse start\n' + rbp + '\n' + initial)
				for (var i=0; i<debugCount; i++) debugStr += ' '
				debugStr += 'PSTART ' + rbp + ' ' + initial + '\n'
				debugCount++
			}
			function	logParseEnd(rbp, initial)
			{
//				alert('parse END\n' + rbp + '\n' + initial)
				debugCount--
				for (var i=0; i<debugCount; i++) debugStr += ' '
				debugStr += 'PEND ' + rbp + ' ' + initial + '\n'
				if (initial) debugStr += '\n'
			}


			function	logFunctionStart(startToken)
			{
				functionLines.push(startToken.line)
//				alert(startToken.line + ' ' + startToken)
			}
			function	logFunctionEnd(startToken, endToken)
			{
			}

			
			function	lintLines(lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }
				
				tokensByLine = {}
				functionLines = []
				traceTokens = []
    			tree = JSLINT(lines, options)
//alert(lines + '\n********\n' + tree)
//				alert(dumpHash(tokensByLine))
//				if (!tree)
				{
//					alert('FAIL')
//					return
				}
				
				return { tokens : tokensByLine, res : !!tree, functionLines : functionLines, errors : JSLINT.errors }
			}
			
			
			function	makeWhitespaceVisible(space)
			{
//				space = space.replace(/ /g, '<span contentEditable="false"><span class="space"></span></span> ')
//				space = space.replace(/\t/g, '<span contentEditable="false"><span class="tab"></span></span>	')
				return	space					
			}
			
			// 'line' is raw text, used to compute tab size
			// tabs are replaced in 'html' 
			function	replaceTabsInLine(line, html, customReplaceFunction)
			{
				var tabLengths = []
				function	countTabs(str, idx)
				{
					var length = (idx+deltaTabPosition) % tabLength
					length = tabLength - length
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition += length-1
					
					tabLengths.push(length)
				}
				var tabIndex = 0
				function	replaceTabs(str, idx)
				{
					// A tab is surrounded by a SPAN nulling its width (with negative letter-spacing) and padding it to the correct 4-size with charWidth (measured in fontWidthMeasurer)
					return '<span class="fakeTab" style="letter-spacing: -' + charWidth + 'px; padding-right: ' + tabLengths[tabIndex++]*charWidth + 'px">	</span>'
//					return '<span class="fakeTab" >	</span>'
				}
				var tabLength = 4
				var deltaTabPosition = 0

				line.replace(/\t/g, countTabs)
				var fn = customReplaceFunction ? function () { return customReplaceFunction(tabLengths[tabIndex++]) } : replaceTabs
				html = html.replace(/\t/g, fn)

				return	html
			}
			function	writeTokensToLine(node, tokens, line)
			{
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
//alert('value=' + token.value + '\nlength=' + token.value.length + '\nrange=' + token.from + ',' + token.character)
//					keep an index of current char, copy from source string with splice or substring if not there
					if (token.value && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						str += htmlEncode(space)
					}
					var c = ''
					var v = token.value
					v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
//						alert(line + '*\ncharacter=' + token.character + '\nline.length=' + line.length + '\nv=' + v + '*')
/*
						// Single line markdown comment
						if (v.match(/^\/\/md/))
						{
							v = v.replace(/^\/\/md\s?/, '')
							v = MarkDownConverter.makeHtml(v)
							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
						}
*/
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length)
				{
					var space = line.substr(lastIndex)
					str += htmlEncode(space)
//					alert('COPY\n*' + str + '*' + '\n===\n' + line.substr(lastIndex) + '*')
				}
				
				// Treat newlines in lines empty or containing only tabs as white-space: pre (so the caret lets you stop on them), use white-space: normal for the rest
//				if (line.match(/^(\t*)\n$/))	str = str.replace(/\n/, '<span class="newline">\n</span>')
//				else 							str = str.replace(/\n/, '<span class="newline-normal">\n</span>')

				// TABS ! sized to any size you want.
				str = replaceTabsInLine(line, str)
				
				node.innerHTML = str
			}

			//
			// Get raw text from highlighted line
			//
			function	rawSourceFromLineQuicker(line)
			{
/*
				// Restore newlines
				var ns = line.getElementsByClassName('newline')
				for (var i=0; i<ns.length; i++) 
				{
					var n = ns[i]
					n.className = ''
				}
				
				// Restore tabs
				var ns = line.getElementsByClassName('fakeTab')
				for (var i=0; i<ns.length; i++) 
				{
					var n2 = document.createElement('SPAN')
					n2.className = 'realTab'
					n2.innerText = '\t'
					ns[i].insertAdjacentElement('beforeBegin', n2)
				} 
*/
				var t = line.innerText
				// innerText removes \n when using white-space: normal (we need it to make tabs show up)
//				if (line.lastChild && line.lastChild.nodeType == 1 && line.lastChild.className == 'newline-normal')	t += '\n'
				return	t
			}
			
			function	rawSourceFromLine(line)
			{
/*
				var n = document.getElementById('rawSourceFromLineExtractor')
				n.innerHTML = '<div>' + line.innerHTML + '</div>'
//				alert(n.innerHTML)
//				return ''
*/
//				return	readRawSourceFromLineQuicker(n.firstChild)
				return	rawSourceFromLineQuicker(line)
			}
			
			

			var selectionStack = []
			
			function	rawSelection()
			{
				var sel = getSelection()
//				return { baseNode : sel.baseNode, baseOffset : sel.baseOffset, extentNode : sel.extentNode, extentOffset : sel.extentOffset }
				return sel.getRangeAt(0)
			}
			function	setRawSelection(r)
			{
				var sel = getSelection()
				sel.removeAllRanges()
				sel.addRange(r)
//				sel.setBaseAndExtent(r.baseNode, r.baseOffset, r.extentNode, r.extentOffset)
			}
			
			function	lineAndOffsetFromNodeAndOffset(node, offset)
			{
				var n = node
				var lineNumber = lineNumberFromNode(n), offset2
				// This is a line node
				if (n.className == 'line')
				{
					offset2 = offset
				}
				// Walk up to the node having the line node as parent, then walk up its siblings to count offset from line start
				else
				{
					while (n && n.parentNode && n.parentNode.className != 'line') n = n.parentNode
					if (n)
					{
						offset2 = offset
						var n2 = n.previousSibling
						while (n2)
						{
							if (n2.nodeType == 1)	offset2 += n2.innerText.length
							if (n2.nodeType == 3)	offset2 += n2.nodeValue.length
							n2 = n2.previousSibling
						}
					}
				}
				return	{ line : lineNumber, offset : offset2}
			}
			
			function	selectionAsLineAndOffset()
			{
				var sel = getSelection()
				var raw = rawSelection()

				sel.modify('extend', 'left', 'paragraphboundary')
				var selectionText = sel.toString()
				var length = selectionText.length
				var range = sel.getRangeAt(0)
				var h = { type : 'Caret', line : lineNumberFromNode(sel.baseNode), offset : length }

				setRawSelection(raw)

				return h
			}

			function	setSelectionAsLineAndOffset(line, offset)
			{
				var line = nodeFromLineNumber(line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<offset; i++)
					sel.modify('move', 'right', 'character')
			}

			function	rangeSelectionAsLineAndOffset()
			{
				var sel = getSelection()

				var names = ['anchor', 'extent', 'focus', 'base']
				var base = { line : 999999999, offset : 999999999 }
				var extent = { line : -1, offset : -1 }
				for (var i=0; i<names.length; i++)
				{
					var name = names[i]
					var s = lineAndOffsetFromNodeAndOffset(sel[name + 'Node'], sel[name + 'Offset'])
					if (s.line <= base.line && s.offset <= base.offset)		base = s
					if (s.line >= extent.line && s.offset >= extent.offset)	extent = s
				}
				return { base : base, extent : extent }
			}

			function	pushCaretSelection()
			{
				selectionStack.push(selectionAsLineAndOffset())
			}
			function	popCaretSelection()
			{
				var s = selectionStack.pop()
//				alert(s.line + ' ' + s.offset)
				setSelectionAsLineAndOffset(s.line, s.offset)
			}
			function	caretSelectionOnStack()
			{
				if (!selectionStack.length)	return
				return	selectionStack[selectionStack.length-1]
			}
			
			function	pushSelection()
			{
				pushCaretSelection()
			}
			function	popSelection()
			{
				popCaretSelection()
			}
			
			
			var lineCount
			var currentLineNumber
			var currentLineText
//			var previousLineText
//			var nextLineText
			
			function	keydown()
			{
				setTimeout(postKeydown, 0)
//				alert(event.keyCode)
				var keyCode = event.keyCode
				
				//  Check control key to account for emacs shortcuts
				if (event.shiftKey || event.ctrlKey)	
				{
//					alert('SELEX')
//					alert('mark newlines as normal')
				}
				
				
				var sel = getSelection()
				
				if (sel.type != 'Caret' && sel.type != 'Range')	return
				
				var line = lineNodeFromNode(sel.baseNode)

				if (!line)
				{
					alert('Caret is not in a DIV')
					return
				}
					
				var lineNode 		= lineNodeFromNode(sel.baseNode)
				lineCount			= highlighted.childNodes.length
				currentLineNumber 	= lineNumberFromNode(sel.baseNode)
//				currentLineText 	= lineNode.innerText
				currentLineText		= rawSourceFromLine(lineNode)
//				previousLineText	= lineNode.previousSibling ? lineNode.previousSibling.innerText : null
//				nextLineText		= lineNode.nextSibling ? lineNode.nextSibling.innerText : null
				

				var lineNumber = lineNumberFromNode(sel.baseNode)

				//  Insert tab
				if (keyCode == 9)
				{
					event.preventDefault()
					var lineNumber2 = lineNumberFromNode(sel.extentNode)
					// Insert a single tab
					if (lineNumber == lineNumber2)
					{
						if (sel.type == 'Range')	sel.deleteFromDocument()
						pushCaretSelection()
//alert('1')						
						var t = currentLineText
//						lineNode.innerText = t
						var offset = caretSelectionOnStack().offset
//alert('2')						
//alert('3')						
						var left = t.substr(0, offset)
						var right = t.substr(offset)
//						alert(left + '<CARET>' + right)
//						alert('offset=' + offset + '\ntext=' + t + '\n\n\nleft=' + left + '\n\n\nright=' + right)
						var text = left + '\t' + right
						lineNode.innerHTML = replaceTabsInLine(text, text)
//alert('4')						
						popCaretSelection()
						// Advance after tabbing
						sel.modify('move', 'right', 'character')
//alert('5')						
//				document.getElementById('dump6').innerHTML += '\nselectionAsLineAndOffset line=' + h.line + ', offset=' + h.offset

					}
					else
					// Move lines back and from
					{
//						alert(sel.extentNode.parentNode.innerText + ' ' + sel.extentOffset)
//						alert('tab selection TODO, account shift')
						
//						pushRangeSelection()
/*
						var str = 'when shift selecting keyboard, selection differs and selects part of the first line'
						str += '\nanchor=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\nextent=(' + sel.extentOffset + ')' + lineNodeFromNode(sel.extentNode).innerText
						str += '\nbase=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\noffset=(' + sel.focusOffset + ')' + lineNodeFromNode(sel.focusNode).innerText
						alert(str)
*/
alert('SEL TAB MULTIPLE LINES')
						// Keyboard selecting lines will select the next line with a zero offset
						// happens on triple-clicking left space on tabs on a function
						if (sel.extentOffset == 0) lineNumber2--

//						alert(lineNumber + ' ' + lineNumber2)
//						alert(lineNodeFromNode(sel.baseNode).innerText)
						
						if (lineNumber2 <= lineNumber)
						{
							var tmp = lineNumber2
							lineNumber2 = lineNumber
							lineNumber = tmp
						}
						
						for (var i=lineNumber; i<=lineNumber2; i++)
						{
							alert('change innerText to READ')
							var line = nodeFromLineNumber(i)
							if (!event.shiftKey)
								line.innerText = '\t' + line.innerText
							else
							{
								line.innerText = line.innerText.toString().replace(/^\s/, '')
							}
						}
//						popRangeSelection()
					}
				}
				
				// Custom word delete handling
				if (keyCode == 8 && event.altKey)
				{
					alert('CHECK ! extent selection to previous word. if overflows line, just move it to start of line')
				}
				
				// Insert new line
				// Check enter and CTRL+O
				if (keyCode == 13 || (keyCode == 79 && event.ctrlKey))
				{
					if (sel.type == 'Caret')
					// OR if one line range
					{
						event.preventDefault()
						pushCaretSelection()
						lineNode.innerText = rawSourceFromLineQuicker(lineNode)
						popCaretSelection()
						var l = lineNumberFromNode(sel.baseNode)
						
						var line = lineNodeFromNode(sel.baseNode)
						
						sel.setBaseAndExtent(line, 0, sel.baseNode, sel.baseOffset)
//						alert(line.innerText + '\n' + l)
//						var c = characterOffsetFromLineAndNode(sel.baseNode, sel.baseOffset)
						
//						sel.modify('extend', 'left', 'line')
						
						
						
						var leftLength = sel.toString().length
//						var newLine = line.innerText.substr(leftLength)
						
//						alert(l)
//						alert(lines[l])
//						alert(sel.toString().length + '\n' + line.innerText.length)
						
						var n = document.createElement(lineElementName)
						n.className = 'line'
						
						// Add \n if it's not here (happens on one-line documents)
						var rightText = line.innerText.substr(leftLength)
						if (!rightText.match(/\n/)) rightText += '\n'
						// Get space (minus \n) on cursor left
						var leftSpace = line.innerText.substr(0, leftLength).toString().match(/^\s*/).toString().replace(/(\r|\n)/g, '').toString()
						
						// Add a tab if we're pressing enter AFTER a brace
						if (line.innerText.match(/^\s*\{/) && !rightText.match(/\{/))	leftSpace += '	'
						
//						alert(line.innerText)
						
						var text = leftSpace + rightText
						text = replaceTabsInLine(text, text)
						n.innerHTML = text
						
						line.insertAdjacentElement('afterEnd', n)
//						line.innerText = line.innerText.substr(0, leftLength) + '\n'
						var text = line.innerText.substr(0, leftLength) + '\n'
						lineNode.innerHTML = replaceTabsInLine(text, text)

						if (keyCode == 13)
						{
							sel.setPosition(n, 0)
							if (leftSpace.length)
							{
								for (var i=0; i<leftSpace.length; i++)
									sel.modify('move', 'right', 'character')
							}
						}
						else
							sel.setPosition(sel.extentNode, sel.extentOffset)
					}
					else
					{
						// Nothing to do with a range as no newline is inserted.
					}
					
				}
				
				/*
					If Range selection, save all lines
				*/
			}
			
//			var previouslySelectedLine
			function	postKeydown()
			{
				var sel = getSelection()
//				var lineNumber = lineNumberFromNode(sel.baseNode)
				
				/*
					Maybe 
					* deleted everything
						-> just a text node left, or a br
					* backspace or delete
						-> two spans on the same line					
				*/
				var line = lineNodeFromNode(sel.baseNode)
				if (!line)
				{
					// Will be called even after ALT-L (select address bar), check if we have a selection
					if (sel.type == 'None')	return
					
					alert('ADD READ')
					var newLines = highlighted.innerText.split('\n')
					highlighted.innerHTML = ''
//					alert(newLines.length)
					for (var i=0; i<newLines.length; i++)
					{
						var n = document.createElement(lineElementName)
						n.className = 'line'
						n.innerText = newLines[i] + '\n'
						highlighted.appendChild(n)
					}
					// Select the text node
					sel.setPosition(highlighted.firstChild.firstChild, 0)
					var line = lineNodeFromNode(sel.baseNode)
				}
				
//				if (previouslySelectedLine)	previouslySelectedLine.className = 'line'
//				previouslySelectedLine = null
				
				var lineCount2			= highlighted.childNodes.length
				var currentLineNumber2 	= lineNumberFromNode(sel.baseNode)
				
				var currentLineText2 	= rawSourceFromLine(lineNodeFromNode(sel.baseNode))

				

//alert(currentLineText + '\n\n' + currentLineText2 + '\n\n\nn1=' + currentLineNumber + '\nn2=' + currentLineNumber2)
				
				var mode = 'selecting'
				var moved = lineCount2 != lineCount
				var lineChanged = !(currentLineNumber2 == currentLineNumber && currentLineText2 == currentLineText)
				if (moved || lineChanged)
					mode = 'typing'
				
				// Custom handling for having inserted specific characters, eg closing a brace : remove one tab in front of it
				if (mode == 'typing' && currentLineNumber == currentLineNumber2 && currentLineText.length+1 == currentLineText2.length)
				{
					
					var s = selectionAsLineAndOffset()
					var addedChar = currentLineText2.charAt(s.offset-1)

					// If closed a block, remove a tab in front of it
					if (addedChar == '}' && currentLineText2.match(/\t\}/))
					{
						pushCaretSelection()
						var text = currentLineText2.replace(/\t\}/, '}')
						line.innerText = text
						selectionStack[selectionStack.length-1].offset--
						popCaretSelection()
					}
				}
				
/*				
				var str  = getTickCount() + ' '
				if (mode == 'typing') 	str += '<span style="color: red">' + mode + '</span>'
				else					str += mode
				
				
				if (line.previousSibling && line.previousSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red">PREVIOUS SPAN ON SAME LINE</span>'
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red"><b>NEXT</b> SPAN ON SAME LINE</span>'
*/
				// While forward or backward deleting, the next line SPAN came onto the current SPAN. Remove it
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
				{
					alert('Does this still happen ?')
					pushCaretSelection()
					line.innerText = rawSourceFromLineQuicker(line)
					line.nextSibling.innerText = rawSourceFromLineQuicker(line.nextSibling)
					line.innerText += rawSourceFromLine(line.nextSibling)
					line.nextSibling.parentNode.removeChild(line.nextSibling)
					popCaretSelection()
					// Selection stays the same, nice !
				}
/*
				str += '\nchildNodesCount=' + highlighted.childNodes.length + ' \\n count=' + (highlighted.innerText.match(/\n/g)||0).length
				
				str += '\nlineCount=' + lineCount
				str += '\nlineCount2=' + lineCount2
				str += '\nlineNumber=' + currentLineNumber
				str += '\nlineNumber2=' + currentLineNumber2
				str += '\ncurrentLineText=' + currentLineText
				str += '\ncurrentLineText2=' + currentLineText2
				str += '\n!=lineCount=' + (lineCount2 != lineCount)
				str += '\n!=currentLineNumber=' + (currentLineNumber2 != currentLineNumber)
				str += '\n!=currentLineText=' + (currentLineText2 != currentLineText)
				
				document.getElementById('dump4').innerHTML = str
*/				
//				document.getElementById('dump5').innerHTML += '*PKD*line=' + currentLineNumber2
				
				
				if (mode != 'typing')	return
				
				if (sel.type == 'Range') alert('HIGHLIGHT WITH RANGE SELECTION')
				highlightText()

				//
				// Selected line
				// 
				showSelectedLine()

//				alert(lines)
				
			}

			function	birdView(line, functionLines)
			{
				var str = ''
				for (var i=0; i<functionLines.length; i++)
				{
					var idx = functionLines[i]
					var line = lines[idx]
					str += idx + '=' + line + '<br>'
				}
				document.getElementById('birdView').innerHTML = str
				
			}
			
			var charWidth = 0
			var paddedLines = []
			
			function	replaceExtensions(src)
			{
				var idx = src.indexOf('<?')
				var idx2 = 0
				
				var tag1 = /<\?/g
				var tag2 = /\?>/g
				
				var r1
				var lastIndex = 0
				var src2 = []
				while (r1 = tag1.exec(src))
				{
//					alert(r1.index  + '\n' + dumpHash(r1))
					tag2.lastIndex = r1.index
					var r2 = tag2.exec(src)
					if (r2)
					{
						src2.push(src.substr(lastIndex, r1.index-lastIndex))
//						src2.push(src.substr(r1.index, r2.index-r1.index+2))
						var str = src.substr(r1.index, r2.index-r1.index+2)
//						alert('IN=' + str + '\n**********************')
						lastIndex = r2.index+2
					}
					else
					{
						return null
					}
//					alert(dumpHash(r1))
//					alert(dumpHash(r2))
//					alert(r.index + '\n' + (r2 ? r2.index : 'NO LASTMATCH'))
				}
				if (lastIndex)
				{
					src2.push(src.substr(lastIndex))
//					alert('EXTRACTED=' + src2.join(''))
					return src2.join('')
				}
				return	src
				
/*
				if (idx)
				{
					var src2 = src.substr(idx2, idx)
					var idx2 = src.indexOf('')
				}
*/
			}

			
			function	errorBubbles(lint)
			{
				pushCaretSelection()
				
				var str = ''
				
				var bubbleContainer = document.getElementById('bubbleContainer')
				bubbleContainer.innerHTML = ''

				// Remove padding from bubble lines
				for (var i=0; i<paddedLines.length; i++)	
				{
//					var line = nodeFromLineNumber(paddedLines[i].lineNumber)
					var line = paddedLines[i].line
					// Skip line if it's been deleted since
					if (!line)	continue
					line.style.padding = 0
				}



//				if (highlightCount > 1)	return
//					pushSelection()

				// Copy error list and remove trailing null
				var errors = []
				for (var i=0; i<lint.errors.length; i++) { if (lint.errors[i])	errors.push(lint.errors[i]) } 
				
				// Sort errors as they can come non ordered
				errors.sort(function (a, b)
							{
								if (a.line < b.line)	return -1
								if (a.line > b.line)	return 1
								return 0
							})

				var previousErrorLine
				// Error list is null-terminated
				for (var i=0; i<errors.length; i++)
				{
					var error = errors[i]

					// This error will be made visible by the non-highlighted source appearing black
					if (error['reason'].match(/unable to continue/))	continue

					// Only show one error per line
					if (error.line == previousErrorLine)				continue

					// Copy these as they can be modified
					var errorLine = error.line
					var errorReason = error.reason
					
					
					var ll = nodeFromLineNumber(errorLine)

					// JSLint will sometimes give the error one (non existant) line ahead,
					// Try getting previous line
					if (!ll /*&& error.reason == 'Unexpected early end of program.'*/)
					{
						ll = nodeFromLineNumber(errorLine-1)
						if (ll) 
						{
							errorLine--
							if (errorLine == previousErrorLine)	continue
						}
					}
					previousErrorLine = errorLine

					if (!ll)
					{
						alert('NULL LINE IN LINT ERROR\n' + dumpHash(error) + '\nhighlighted.childNodes.length=' + highlighted.childNodes.length)
						return
					}

					var sel = getSelection()
					if (!sel.baseNode)
					{
						alert(getSelection().type + '\n' + error.line + '(' + errorLine + ')' + ',' + error.character)
					}
					
					// Create an empty span to measure position of caret in line
					var span = insertMeasuringSpanAtLineAndOffset(errorLine, error.character)

					// Create bubble
					var line = nodeFromLineNumber(errorLine)
					var x = (span.offsetLeft + highlighted.offsetLeft)
					var y = /*span.offsetTop +*/ line.offsetTop + line.offsetHeight
					var margin = span.offsetHeight
					
					var bubbleWrapper	= document.createElement('DIV')
					bubbleWrapper.className = 'bubbleWrapper'
					bubbleWrapper.style.top = y + 'px'
					bubbleWrapper.style.marginLeft = 0 + 'px'
					bubbleWrapper.innerHTML = "<span class='bubbleArrow'>▾</span>"

					var bubble			= document.createElement('DIV')
					bubble.innerHTML = errorReason
					bubble.className = 'bubble'
					
					bubbleWrapper.appendChild(bubble)
					bubbleContainer.appendChild(bubbleWrapper)

					// Clamp bubble position so it doesn't overflow on the right side
					if (x+bubbleWrapper.offsetWidth > highlighted.offsetWidth)
						x = highlighted.offsetWidth - bubbleWrapper.offsetWidth

					bubbleWrapper.style.marginLeft = x + 'px'

					// Pad line bottom to leave space for the bubble, stored one layer down
					line.style.paddingBottom = bubbleWrapper.offsetHeight + 'px'
					paddedLines.push( { lineNumber : errorLine, line : line } )
				}


				str = '\n<span style="color: red">' + str + '</span>'
				document.getElementById('dump5').innerHTML += str

				popCaretSelection()
			}
			
			function	lineNumbers()
			{
				var lineNumbers = document.getElementById('lineNumbers')
				lineNumbers.innerHTML = ''
				var lines = highlighted.childNodes
				var f = highlighted.firstChild
				var numbers = []
				var i = 1
				while (f)
				{
					var h = f.offsetHeight
					var c = 'lineNumber'
					if ((i % 10) == 0) c += ' l10'
					numbers.push('<div class="' + c + '" style="height: ' + h + 'px">' + i++ + '</div>')
					f = f.nextSibling
				}
				lineNumbers.innerHTML = numbers.join('')
			}
			
			
			
			var highlightCount = 0
			
			//
			// Highlight
			// 
			function	highlightText()
			{
				var str = ''
				try
				{
					str = 'childNodes.length=' + highlighted.childNodes.length + ' innerText.newlineCount=' + highlighted.innerText.match(/\n/g).length
				}
				catch (e) { str = 'NOT EVENT ONE LINE RETURN'}
				str += ' newline-normal=' + document.getElementsByClassName('newline-normal').length + ' newline=' + document.getElementsByClassName('newline').length
				document.getElementById('dump4').innerHTML = str




				highlightCount++
				charWidth = document.getElementById('fontWidthMeasurer').firstChild.offsetWidth
				lines = []
				var f = highlighted.firstChild
				while (f)
				{
					var text = rawSourceFromLineQuicker(f)
					lines.push(text)
					
					if (text.indexOf('<?') != -1)
					{
//						alert('ext start line=' + text)
					}
					
					f = f.nextSibling
				}
//				var src = lines.join('')
//				src = replaceExtensions(src)
//				lines = src.split('\n')
//				for (var i=0; i<lines.length-1; i++)	lines[i] += '\n'
/*				if (src.match(/<\?/))
				{
					function	r(a, b, c, d)
					{
//						alert(a + '!' + String(a).indexOf('\n'))//+ ' ' + b)
						
					}					
					src.replace(/<\?.*\?>/g, r)
				}
*/				
//				alert(lines.join('').substr(0, 200))


				debugStr = ''
				debugCount = 0
				
				var lint = lintLines(lines)
//				var lint = lintLines(src)
				

				//
				// Highlight
				//
				pushCaretSelection()
//				alert(dumpHash(caretSelectionOnStack()))
				
				var f = highlighted.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					writeTokensToLine(f, tokens, line)
					
					f = f.nextSibling
					i++
				}
				


				var str = getTickCount()
/*				
				str += '\ntokens=' + dumpHash(lint.tokens)
				for (var i=0; i<lint.tokens.length; i++)
				{
					str += lint.tokens[i]
					str += i + '*'
				}
*/
				str += '\nSTACKLENGTH=' + selectionStack.length + '\n'// + str
				str += 'traceTokens count=' + traceTokens.length + '\n'
				for (var i=0; i<traceTokens.length; i++)
				{
					var trace = traceTokens[i]
					var l1 = trace.token.line
					var l2 = trace.openingToken.line
					str += trace.token.id + '=' + (l1==l2 ? l1 : (l1 + '(' + l2 + ')'))
					if (trace.closingToken)
						str += '->' + trace.closingToken.line
					str += '\n'
				}
				str += getTickCount() + ' highlight'
				document.getElementById('dump3').innerHTML = str
				document.getElementById('dump2').innerHTML = debugStr
//				alert(debugStr)
//				alert(lines)
				//
				// Bird view
				// 
				birdView(lines, lint.functionLines)
//				alert(lint.errors)


				//
				// Save selected line's className
				// 
/*
				var selectedLineClassName
				if (previouslySelectedLine)
				{
					selectedLineClassName = previouslySelectedLine.className
					previouslySelectedLine.className = 'line'
				}
*/				
				
				



				var str = getTickCount() + ' highlight (' + highlightCount + ')<br>' 
				document.getElementById('dump5').innerHTML = str
				
				
				
				//
				// Show error bubbles
				// 
				
				popCaretSelection()
				errorBubbles(lint)
//return
//				alert(lint.errors[0].reason)
//				alert(str)
				
				
				//
				// Line numbers
				//
				lineNumbers()
				
				//
				// Traces
				// 
				traces()
				
				//
				// White space
				// 
//				revealWhiteSpace()
				

//					popSelection()



//				if (previouslySelectedLine)	previouslySelectedLine.className = selectedLineClassName
			}
			
			
			function	insertMeasuringSpanAtLineAndOffset(line, offset)
			{
				var sel = getSelection()
				setSelectionAsLineAndOffset(line, offset)
				var range = sel.getRangeAt(0)
				// Special case for tabs : insert them in front of the next node instead of the end of current tab
				if (sel.baseOffset == 1 && sel.baseNode && sel.baseNode.parentNode && sel.baseNode.parentNode.className == 'fakeTab' && sel.baseNode.parentNode.nextSibling)
				{
					range = range.cloneRange()
					var n = sel.baseNode.parentNode.nextSibling
					range.selectNode(n)
				}

				// Create an empty span to measure position
				var span = document.createElement('SPAN')
				range.insertNode(span)
				return span
			}
			
			function	traces()
			{
				pushCaretSelection()
				var tracesContainer = document.getElementById('tracesContainer')
				tracesContainer.innerHTML = ''
				for (var i=0; i<traceTokens.length; i++)
				{
					var traceToken = traceTokens[i]

//					var offset = traceToken.openingToken.character-traceToken.openingToken.value.length
//					var offset = 
//x = 1

if (!traceToken.closingToken)	continue

					var span = insertMeasuringSpanAtLineAndOffset(traceToken.openingToken.line, traceToken.openingToken.from)

					var span2 = insertMeasuringSpanAtLineAndOffset(traceToken.closingToken.line, traceToken.closingToken.from)
					
					var ll = nodeFromLineNumber(traceToken.openingToken.line)
//					alert(ll.outerHTML)
					var n2 = document.createElement('DIV')
					n2.style.cssText = 'width: 10px; height: 15px; background-color: lime; position: absolute'
//					n2.innerHTML = '*'
					var x = span.offsetLeft
					var y = ll.offsetTop
					n2.style.left = x + 'px'
					n2.style.top = y + 'px'
					tracesContainer.appendChild(n2)
					var n3 = n2

					var ll2 = nodeFromLineNumber(traceToken.closingToken.line)
					var n2 = document.createElement('DIV')
					n2.style.cssText = 'width: 10px; height: 15px; background-color: lime; position: absolute'
//					n2.innerHTML = '*'
					var x = span2.offsetLeft
					var y = ll2.offsetTop
					n2.style.left = x + 'px'
					n2.style.top = y + 'px'
					tracesContainer.appendChild(n2)
					var n4 = n2
					
					var n5 = document.createElement('DIV')
					tracesContainer.appendChild(n5)
					n5.style.cssText = 'width: 4px; background-color: orange; position: absolute'
					n5.style.top = n3.offsetTop + 'px'
					n5.style.left = n3.style.left
					var h = n4.offsetTop - n3.offsetTop + n4.offsetHeight
					n5.style.height = h + 'px'
					
//					alert(h + '*' + n5.outerHTML)
//					return
					
//					document.getElementById('dump3').innerHTML += '\nl=' + span.offsetLeft + ' x=' + x + ' offset=' + offset


//alert(dumpHash(sel))
//return
				}
				popCaretSelection()
			}
			
			function	showSelectedLine()
			{
				var sel = getSelection()
				var selectedLine = document.getElementById('selectedLine')
				if (sel.type == 'Caret')
				{
					var line = lineNodeFromNode(sel.baseNode)
					selectedLine.style.top = line.offsetTop + 'px'
					selectedLine.style.height = line.offsetHeight + 'px'

					var s = selectionAsLineAndOffset()
					
					var selectedLinePosition = document.getElementById('selectedLinePosition')
					selectedLinePosition.innerHTML = (s.line+1) + ',' + (s.offset+1)
//					alert(dumpHash(s))
//					previouslySelectedLine = line
//					line.className += ' selectedLine'
				}
				else
					selectedLine.style.top = '-30000px'
			}
			
			function	revealWhiteSpace()
			{
				var revealer = document.getElementById('whiteSpaceRevealer')
				revealer.innerHTML = ''
				
				function	replaceTab(tabSize)
				{
//					alert(tabSize + '\n*\n' + text)
					var t = '→'
					if (tabSize == 2) t += ' '
					if (tabSize == 3) t += '  '
					if (tabSize == 4) t += '   '
					return t
				}
				
				function	revealWhite(match)
				{
					var str = String(match)
					if (str.length == 1)
					{
						if (str == ' ')		return '<span style="position: absolute">·</span> '
						if (str == '\n')	return '¶' 
						if (str == '\t')	return str
					}
					return '<span style="opacity: 0">' + str + '</span>'
				}
				
				var f = highlighted.firstChild

				while (f)
				{
					var text = rawSourceFromLineQuicker(f)
					var n2 = document.createElement('DIV')

					var html = text					
					var html = text.replace(/(\S+|\s|\t|\n)/g, revealWhite)
					text = replaceTabsInLine(text, html, replaceTab)
					n2.innerHTML = text
					
					var y = f.offsetTop
					n2.style.top = y + 'px'
					revealer.appendChild(n2)
					f = f.nextSibling
				}
			}
			
/*			
			function	copy()
			{
				alert('handle copy cut paste')
			}
			function	cut()
			{
				alert('handle copy cut paste')
			}
*/
			//
			// If we could reenter after Webkit's right after paste, we'd just have to fixup existing text
			// 
			// http://developer.apple.com/documentation/AppleApplications/Conceptual/SafariJSProgTopics/Tasks/CopyAndPaste.html#//apple_ref/doc/uid/30001234
			function	paste()
			{
//				alert('handle copy cut paste - CHECK WHEN SELECTION RANGE')
				var sel = getSelection()
//				if (sel.type == 'Range')
				var clipboard = event.clipboardData
//				alert(dumpHash(clipboard))
				clipboard.clearData()
//				alert('->' + clipboard.types)
				
//				alert('TEXT=' + clipboard.getData('Text'))
				
//				clipboard.setData('Text', 'HO')
//				alert('TEXT=' + clipboard.getData('Text'))
				
				// We'll handle paste as we need to create one DIV per line
				event.preventDefault()


				var caret = selectionAsLineAndOffset()
				var caret = rangeSelectionAsLineAndOffset().base
//				alert(dumpHash(caret))

				// Delete selection if we have a range
				if (sel.type == 'Range')
				{
//					alert('paste1 ' + dumpHash(caret))
//					alert('SELECTIONASLINEANDOFFSET FROM RANGE')
					sel.deleteFromDocument()
					sel.collapseToStart()
//					alert('paste2' + dumpHash(caret))
				}
				var ll = nodeFromLineNumber(caret.line)
//				alert(sel.baseOffset)
				
				var text = clipboard.getData('Text')
				var lines = text.split('\n')
//				alert(lines.length)
//				alert('*' + lines + '$')
				
/*				if (lines.length == 1)
				{
					sel
				}
*/
//				alert(ll.outerHTML)
				
				// Split line according to caret : prefix (caret) suffix
				var text = rawSourceFromLine(ll)
				var prefix = text.substr(0, caret.offset)
				var suffix = text.substr(caret.offset)

//				alert('text=' + text + '\nprefix=' + prefix + '\nsuffix=' + suffix)

				// The first line becomes prefix + first line of selection (+ suffix in one line pastes)
				ll.innerText = prefix + lines[0]
				var currentLine = ll
				
				var newLineForCaret = caret.line

				// Each of the remaining lines gets its own html node
				for (var i=1; i<lines.length; i++)
				{
					var n2 = document.createElement('DIV')
					n2.className = ll.className
					n2.innerText = lines[i]
//					if (i < lines.length-1) n2.innerText += '\n'
//					else					n2.innerText += suffix
					currentLine.innerText += '\n'
					currentLine.insertAdjacentElement('afterEnd', n2)
					currentLine = n2
					newLineForCaret++
				}
				// Append suffix to last line
				var newOffsetForCaret = currentLine.innerText.length
				currentLine.innerText += suffix
				
				setSelectionAsLineAndOffset(newLineForCaret, newOffsetForCaret)
				highlightText()
//				currentLine.
			}
			
			
			highlighted.onkeydown = keydown
//			highlighted.oncopy	= copy
//			highlighted.oncut 	= cut
			highlighted.onpaste	= paste
			
			
			function	selectstart()
			{
//				document.getElementById('dump4').innerHTML = getTickCount() + ' selectstart'
			}
			highlighted.onselectstart = selectstart
			
			function	focusHighlighted()
			{
				highlighted.focus()

				var s = getSelection()
				s.collapseToStart()
				highlightText()
				showSelectedLine()
			}
			setTimeout(focusHighlighted, 10)
			
			
			function	dumpSelection()
			{
				var str = getTickCount()
				var sel = getSelection()
				str += '\ntype=' + sel.type
//				if (sel.type == 'Caret')
				{

					function dumpSelectionNode(name)
					{
						var node = sel[name + 'Node']
						var offset = sel[name + 'Offset']
						if (!node)	return str += '(null)'
						var t = ''
						if (node.nodeType == 3) t = node.nodeValue
						if (node.nodeType == 1) t = node + '->' + htmlEncode(node.innerText.substr(0, 80))
						str += '\n' + name + '(' + offset + ')=' + (t) + '<span style="color:red">*</span>'

						var o = lineAndOffsetFromNodeAndOffset(node, offset)
						var lineNumber = o.line
						var offset2 = o.offset
/*						
						var n = node
						if (!n)	str += 'NULL'
						
						var lineNumber, offset2
						if (n.className == 'line')
						{
							lineNumber = lineNumberFromNode(n)
							offset2 = offset
							str += '<b>DIV</b> '
						}
						else
						{
							while (n && n.parentNode.className != 'line') n = n.parentNode
							if (n)
							{
								lineNumber = lineNumberFromNode(n)
								offset2 = offset
								var n2 = n.previousSibling
								while (n2)
								{
									if (n2.nodeType == 1)	offset2 += n2.innerText.length
									if (n2.nodeType == 3)	offset2 += n2.nodeValue.length
//									else 				str += '*' + n2 + '*'
									n2 = n2.previousSibling
								}
							}
						}
*/
						str += '<span style="color: blue">' + (lineNumber+1) + ',' + (offset2+1) + ' <span style="font-size: 50%; opacity: 0.5">' + lineNumber + ',' + offset2 +  '</span></span>'
						
//						alert(n.parentNode.outerHTML)
//						rez()
//						str += 'line=' + lineNumberFromNode(n.parentNode)
					}
					
					dumpSelectionNode('base')
					dumpSelectionNode('anchor')
					dumpSelectionNode('extent')
					dumpSelectionNode('focus')
					str += '\nselection=<span style="color:red">*</span>' + sel.toString() + '<span style="color:red">*</span>'
					
					str += '\n'
					var s = rangeSelectionAsLineAndOffset()
					str += '\nbase=<span style="color: blue">' + s.base.line + ',' + s.base.offset + '</span>'
					str += '\nextent=<span style="color: blue">' + s.extent.line + ',' + s.extent.offset + '</span>'

/*
type=Range
focusOffset=14
baseNode=[object Text]
baseNode=[object Text]
baseOffset=279
baseOffset=289
isCollapsed=false
type=Range
focusNode=[object Text]
extentNode=[object Text]
rangeCount=1
extentOffset=18
collapseToStart=function collapseToStart() {
    [native code]
*/
				}
//				str += dumpHash(sel)
				document.getElementById('dump3').innerHTML = str
			}
//			setInterval(dumpSelection, 100)
			
			
			
			
			function	clearDumps()
			{
				document.getElementById('dump2').innerHTML = ' '
				document.getElementById('dump3').innerHTML = ' '
				document.getElementById('dump4').innerHTML = ' '
				document.getElementById('dump5').innerHTML = ' '
				document.getElementById('dump6').innerHTML = ' '
			}

		</script>

<pre>
	<h1 style='color: red; margin-top: -50px'>
* highlight happens on caret move : left/right + up/down on overflowing lines
* try linting src, ie lines.join('')
* when option/suppr, might delete an endline. need to restore it
	deleted newline : 
		* enter to create a line
		* new tab
		* type some text
		* option suppr
		-> no newline
* remove all innerText refs
* cmd-a plant parfois
* check displayRawText([])
* cmd-a, delete all, type -> newline disappears

	</h1>
	everything on the same line : white-space: wrap
	retour lign : white-space: pre-wrap


</body>
</html>
