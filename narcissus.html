<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Highlighter</title>
	<style>
		body
		{
			font-size: 80%;
			ebackground-color: rgb(255, 255, 240);
		}
		textarea
		{
			width: 100%;
			height: 500px;
			ecolor: rgba(255, 255, 255, 0.1);
			background-color: transparent;
			font-family: courier;
			font-family: Andale Mono;
			font-family: Monaco;
			font-size: 7pt;
		}
		td
		{
			vertical-align: top;
			width: 50%;
		}
		#highlighted, #fontWidthMeasurer
		{
			white-space: pre;
			emargin-left: 20px;
			font-family: monaco;
			font-size: 7pt;
			outline: none;
			border: solid 1px #aaa;
		}
		.line
		{
			ebackground-color: #fafafa;
			position: relative;
			line-height: 1.3em;
			min-height: 1.3em;
		}
		.selectedLine
		{
			background-color: lime;
			background: -webkit-gradient(linear, left top, left bottom, from(#eee), to(#ddd));
			border: solid 1px #ccc;
			border-left: 0;
			border-right: 0;
			margin: -1px 0;
		}
		
		#dumpHighlighted
		{
			width: 100%;
		}
		#dump5
		{
			white-space: normal;
		}
		
		
		/* source styling */
		.keyword
		{
			color: rgba(51, 28, 255, 1);
			text-shadow: rgba(51, 28, 255, 0.9) 0px 0px 1px, rgba(51, 28, 255, 1) 0px 0px 0px;
		}
		.exps
		{
			color: red;
		}
		.number
		{
			color: green;
		}
		.string
		{
			color: purple;
		}
		.comment
		{
			color: rgb(83, 180, 255);
		}


/*		
		.newline:before
		{
			content: '¶';
		}
		.space:before
		{
			content: '·';
		}
		.tab:before
		{
			content: '→';
		}
*/
/*
		.newline, .space, .tab
		{
			color: rgb(83, 180, 255);
			eposition: absolute;
		}
*/

		.newline
		{
		}
		.newline-normal
		{
			white-space: normal;
		}

		/* source styling */

		.lintError
		{
			background-color: rgba(255, 240, 240, 0.8);
		}


		.tabspaceviewer
		{
			white-space: pre;
			font-family: monaco;
			font-size: 7pt;
		}

		.visualtab
		{
			background-color: red;
			position: absolute;
			display: inline-block;
			border-left: solid 1px #ddd;
			height: 800px;
		}

		.fakeTab
		{
			eborder: solid 1px red; 
			height: 2px; 
			background-color: lime;			
		}
		
		#fontWidthMeasurer
		{
			position: absolute;
			top: -30000px;
		}
		#rawSourceFromLineExtractor
		{
			display: none;
		}
		
		
</style>
</head>
<body>
<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px; width: 1px'>
	<textarea style='display: none'>
		var a = 'hello'
var b = "world"
var c = 'hello I\'m home'

if ('blah'.match(/[a-zA-Z0-4]/))
{
	// do something
}

function doSomething(pa, pb, pc)
{
	function	fn2(pz)
	{
		return z+pa
	}
	function fn32(tryme)
	{
		return tryme+pc + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow + longToOverflow
	}
	function fn4(pz)
	{
		return
	}
	var d = pb+pc+globalVar
	return a*b+c
}

var ccc = 'hello'
/*md
	some comment
*/
function somethingElse(z)
{
	if (!z)	return
	if (z == 2)	return z+2
	return z*2
}

&lt;?minitex ?&gt;
for (var i=0; i<10; i++)
{
	// do stuff ...
}

	&lt;?minitex 2
		hop
		la
	?&gt;
</textarea>

<!-- Measures the width of one char -->
<div id='fontWidthMeasurer'><span>*</span> measures font width</div>
<!-- readRawSourceFromLine copies line in here and reads it. As the process is destructive, copying it won't affect original source -->
<div id='rawSourceFromLineExtractor'></div>

	<pre id='dump'></pre>
	
</td><td style='width: 20px'></td><td>
<div class='tabspaceviewer'><span class='visualtab'></span>1234<span class='visualtab'></span>1234<span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    <span class='visualtab'></span>    </div>
	<div id='highlighted' contentEditable='true'></div>
</td><td><div id='birdView'></div></tr></table>
<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
</tr></table>
	<button onclick="clearDumps()">Clear</button>
	<pre id='dump4'></pre>
	<pre id='dump5'></pre>
	<pre id='dump6'></pre>

	<script src="crockford/json2.js"></script>
	<script src="crockford/fulljslint.js"></script>
	<script src='showdown.js'></script>

		<script>
			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}

		
			var textarea = document.getElementsByTagName('TEXTAREA')[0]
			var source = textarea.value
			var highlighted = document.getElementById('highlighted')
			
			var lines = source.split('\n')
			
			var src = []

			// Typing on an empty line deletes trailing '\n'
			// Now that I'm handling line breaking, no more problems
			var lineElementName = 'DIV'
			// OK
//			var lineElementName = 'SPAN'
			var prefix = '<' + lineElementName + ' class="line">'
			var suffix = '\n</' + lineElementName + '>'
			for (var i=0; i<lines.length; i++)
			{
				src.push(prefix + htmlEncode(lines[i]) + suffix)
			}
			highlighted.innerHTML = src.join('')
			
			function	dumpHighlighted()
			{
				var str = getTickCount() + '\n'
				str += '<textarea id="dumpHighlighted">' + highlighted.innerHTML + '</textarea>'
				document.getElementById('dump2').innerHTML = str
			}
			
			function	dumpInternalSource()
			{
				document.getElementById('dump3').innerHTML = lines.join('\n')
			}
			
			
			function	lineNodeFromNode(node)
			{
				while (node)
				{
					if (node.nodeType == 1 && node.className.match(/\bline\b/))
						return node
					node = node.parentNode
				}
			}
			
			function	lineNumberFromNode(node)
			{
				node = lineNodeFromNode(node)
				if (!node)	return
//				return parseFloat(node.id.match(/\d+/))
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			function	nodeFromLineNumber(i)
			{
				return highlighted.childNodes[i]
			}

			// Inner offset : counting tab as ONE character
			function	characterOffsetFromLineAndNode(node)
			{
				
			}
			
			
			
			function	toStringToken()
			{
//				return this.value + '(' + this.line + ':' + this.from + '->' + this.character + ')'
				return this.value + '(' + this.from + '->' + this.character + ')'
			}
			
			var tokensByLine
			var functionLines
			function	logToken(token)
			{
				var line = token.line
				
//				token.toString = toStringToken
				
				if (!tokensByLine[line])	tokensByLine[line] = []
				tokensByLine[line].push(token)
				
				if (token.type == '(extension)')
				{
//					alert(dumpHash(token))
				}
			}
			function	logStatement(statement)
			{
			}


			function	logFunctionStart(startToken)
			{
				functionLines.push(startToken.line)
//				alert(startToken.line + ' ' + startToken)
			}
			function	logFunctionEnd(startToken, endToken)
			{
			}

			
			function	lintLines(lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }
				
				tokensByLine = {}
				functionLines = []
    			tree = JSLINT(lines, options)
//alert(lines + '\n********\n' + tree)
//				alert(dumpHash(tokensByLine))
//				if (!tree)
				{
//					alert('FAIL')
//					return
				}
				
				return { tokens : tokensByLine, res : !!tree, functionLines : functionLines, errors : JSLINT.errors }
			}
			
			
			function	makeWhitespaceVisible(space)
			{
//				space = space.replace(/ /g, '<span contentEditable="false"><span class="space"></span></span> ')
//				space = space.replace(/\t/g, '<span contentEditable="false"><span class="tab"></span></span>	')
				return	space					
			}
			
			
			function	replaceTabInLine(line, html)
			{
				var tabLengths = []
				function	countTabs(str, idx)
				{
					var length = (idx+deltaTabPosition) % tabLength
					length = tabLength - length
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition += length-1
					
					tabLengths.push(length)
//					var str = ''
//					for (var i=0; i<length; i++)	str += ' '
					
					
//					return "<img class='fakeTab5' src='' style='eborder: solid 1px red; height: 2px; background-color: lime; width: " + w + "px'>"

//					str = '<span>' + String.fromCharCode(0x200b) + '<span eclass="tab" contentEditable="false">' + str + '</span></span>'
//					str = '<span>' + String.fromCharCode(0x200b) + '<span eclass="tab" contentEditable="false">' + str + '</span></span>'
//					str = '<span style="display: inline-block; width: 3ex">' + '\t' + '</span>'
//					str = '<span style="display: inline-block; width: 20px">' + '' + '</span>'
//					str = '<span>' + String.fromCharCode(0x200b) + '</span><span style="padding-left: 20px">' + '' + '</span>'


//					alert(deltaTabPosition + ' length=' + length + '\nstr=' + str + '!')
//					tabLengths.push(str)
				}
				var tabIndex = 0
				function	replaceTabs(str, idx)
				{
					return '<span class="fakeTab" style="letter-spacing: -' + charWidth + 'px; padding-right: ' + tabLengths[tabIndex++]*charWidth + 'px">	</span>'
					// A tab is an IMG sized to charWidth (measured in fontWidthMeasurer)
					// This is only for display, as source retains original \t
//					return "<img class='fakeTab' src='' style='width: " + tabLengths[tabIndex++]*charWidth + "px'>"
				}
				var tabLength = 4
				var deltaTabPosition = 0

				line.replace(/\t/g, countTabs)
				html = html.replace(/\t/g, replaceTabs)
//				alert('line=' + line + '\nhtml=' + html)
//				alert(n1 + ' ' + n2)
//				rez()
				return	html
			}
			function	writeTokensToLine(node, tokens, line)
			{
//				node.innerHTML = '*' + lineContent
//				alert(tokens)
				
//				line = line.replace(/\r/, '').toString()
//				line = line.replace(/\u200b/, '').toString()
				
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
//					keep an index of current char, copy from source string with splice or substring if not there
					if (token.value && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						str += htmlEncode(space)
					}
					var c = ''
					var v = token.value
						v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
/*
						// Single line markdown comment
						if (v.match(/^\/\/md/))
						{
							v = v.replace(/^\/\/md\s?/, '')
							v = MarkDownConverter.makeHtml(v)
							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
						}
*/
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length)
				{
					var space = line.substr(lastIndex)
					str += htmlEncode(space)
				}
//				str += String.fromCharCode(0xfeff)
				// Hide newline or Safari will stop on it when keying up while selecting
				// Add a zero-width space to make empty lines visible
//				str = str.replace(/\n/, '<span style="display: none">\n</span>')
//				str = str.replace(/\n/, '<span style="display: none">\n</span><span style="margin-left: 1px"></span>')

if (line.match(/^\n$/))	str = str.replace(/\n/, '<span class="newline">\n</span>')
else 					str = str.replace(/\n/, '<span class="newline-normal">\n</span>')


//					str = str.replace(/\n/, '<span style="position: absolute; evisibility: hidden">\n</span>')
//				str += String.fromCharCode(0x200b)
//				str += 'HANDLE BLANK LINES'
//str += '\n'				
				str = replaceTabInLine(line, str)
				
//				str = '<div style="position: relative; z-index: 4">' + str + '</span>'
				node.innerHTML = str
/*
				var n2 = document.createElement('DIV')
//				en2.style.visibility = 'hidden'
				var lineSpaced = line
				lineSpaced = lineSpaced.replace(/ /g, '<span class="space">·</span>')
				lineSpaced = lineSpaced.replace(/\t/g, '<span class="tab"><span style="position: absolute">→</span>	</span>')
				lineSpaced = lineSpaced.replace(/\n/g, '<span class="newline">¶</span>')
				n2.innerHTML = lineSpaced
				n2.style.position = 'absolute'
				n2.style.width = '100%'
//				node.insertBefore(n2, node.firstChild)

				var f = n2.firstChild
				while (f)
				{
					if (f.nodeType == 3)	f.nodeValue = f.nodeValue.replace(/./g, ' ')
					f = f.nextSibling
				}
*/				
//				node.innerHTML = '<span style="position: absolute">bk</span>' + node.innerHTML
//				if (node.innerText.length == 0)	node.innerHTML += String.fromCharCode(0x200b)
//				if (node.innerText.length == 0)	node.innerHTML += '\r'
//				if (node.innerText.length == 0)	node.innerHTML += ' '
//				alert(node.innerText.length)


//				alert(str)
//				if (node.innerText.match(/^\s*$/)) node.innerHTML += String.fromCharCode(0x200b)
//				alert('*' + node.innerText + '*' + node.innerText.match(/^\s*$/))
			}

			//
			// Get raw text from highlighted line
			//
			function	readRawSourceFromLineQuicker(line)
			{
/*
				// Restore newlines
				var ns = line.getElementsByClassName('newline')
				for (var i=0; i<ns.length; i++) 
				{
					var n = ns[i]
					n.className = ''
				}
				
				// Restore tabs
				var ns = line.getElementsByClassName('fakeTab')
				for (var i=0; i<ns.length; i++) 
				{
					var n2 = document.createElement('SPAN')
					n2.className = 'realTab'
					n2.innerText = '\t'
					ns[i].insertAdjacentElement('beforeBegin', n2)
				} 
*/
				return	line.innerText
			}
			
			function	readRawSourceFromLine(line)
			{
/*
				var n = document.getElementById('rawSourceFromLineExtractor')
				n.innerHTML = '<div>' + line.innerHTML + '</div>'
//				alert(n.innerHTML)
//				return ''
*/
//				return	readRawSourceFromLineQuicker(n.firstChild)
				return	readRawSourceFromLineQuicker(line)
			}
			
			

			var selectionStack = []
			
			function	rawSelection()
			{
				var sel = getSelection()
//				return { anchorNode : sel.anchorNode, anchorOffset : sel.anchorOffset, extentNode : sel.extentNode, extentOffset : sel.extentOffset }
				return sel.getRangeAt(0)
			}
			function	setRawSelection(r)
			{
				var sel = getSelection()
				sel.removeAllRanges()
				sel.addRange(r)
//				sel.setBaseAndExtent(r.anchorNode, r.anchorOffset, r.extentNode, r.extentOffset)
			}
			function	selectionAsLineAndOffset()
			{
				var sel = getSelection()
				var raw = rawSelection()

				sel.modify('extend', 'left', 'paragraphboundary')
				var selectionText = sel.toString()
				var length = selectionText.length
				var range = sel.getRangeAt(0)
				// If there are no real tabs (\t) in the line, try checking for fake ones (img class='fakeTab')
/*
				if (range && selectionText.indexOf('	') == -1)
				{
//					length += range
					
					var n = range.endContainer
//					alert(dumpHash(sel))
					if (!n.previousSibling) n = n.parentNode
					// Account for tabs
					while (n)
					{
//						alert('*' + sel.toString() + '*\nc=' + range.endContainer)
						if (n.nodeType == 1 && n.className == 'fakeTab')	length++
						n = n.previousSibling
					}
//					alert(dumpHash(sel))
//					alert(dumpHash(range))
//					alert(range.toString())
				}
*/
				var h = { type : 'Caret', line : lineNumberFromNode(sel.anchorNode), offset : length }

				document.getElementById('dump6').innerHTML += '\nselectionAsLineAndOffset line=' + h.line + ', offset=' + h.offset

				setRawSelection(raw)

				return h
			}
			function	setSelectionAsLineAndOffset(line, offset)
			{
				var line = nodeFromLineNumber(line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<offset; i++)
					sel.modify('move', 'right', 'character')
			}
			function	pushCaretSelection()
			{
				selectionStack.push(selectionAsLineAndOffset())
			}
			function	popCaretSelection()
			{
				var s = selectionStack.pop()
//				alert(s.line + ' ' + s.offset)
				setSelectionAsLineAndOffset(s.line, s.offset)
			}
			function	caretSelectionOnStack()
			{
				if (!selectionStack.length)	return
				return	selectionStack[selectionStack.length-1]
			}
			
			
			var lineCount
			var currentLineNumber
			var currentLineText
//			var previousLineText
//			var nextLineText
			
			function	keydown()
			{
				setTimeout(postKeydown, 0)
//				alert(event.keyCode)
				var keyCode = event.keyCode
				
				
				
				var sel = getSelection()
				
				if (sel.type != 'Caret' && sel.type != 'Range')	return
				
				var line = lineNodeFromNode(sel.anchorNode)
/*				
				if (line.innerText.length > 1)
				{
					var brs = line.getElementsByTagName('BR')
					for (var i=0; i<brs.length; i++) brs[i].parentNode.removeChild(brs[i])
				}
*/
//				if (sel.anchorNode == highlighted || sel.extentNode == highlighted)

				if (!line)
				{
					alert('Caret is not in a DIV')
					return
				}
					
				var lineNode 		= lineNodeFromNode(sel.anchorNode)
				lineCount			= highlighted.childNodes.length
				currentLineNumber 	= lineNumberFromNode(sel.anchorNode)
//				currentLineText 	= lineNode.innerText
				currentLineText		= readRawSourceFromLine(lineNode)
//				previousLineText	= lineNode.previousSibling ? lineNode.previousSibling.innerText : null
//				nextLineText		= lineNode.nextSibling ? lineNode.nextSibling.innerText : null
				

				var lineNumber = lineNumberFromNode(sel.anchorNode)
//				alert(lineNumber)
//				var str = keyCode + '(' + String.fromCharCode(keyCode) + ') line=' + lineNumber
//				document.getElementById('dump5').innerHTML += str


				//  Insert tab
				if (keyCode == 9)
				{
					event.preventDefault()
					var lineNumber2 = lineNumberFromNode(sel.extentNode)
					// Insert a single tab
					if (lineNumber == lineNumber2)
					{
						if (sel.type == 'Range')	sel.deleteFromDocument()
						pushCaretSelection()
//alert('1')						
						var t = currentLineText
//						lineNode.innerText = t
						var offset = caretSelectionOnStack().offset
//alert('2')						
//alert('3')						
						var left = t.substr(0, offset)
						var right = t.substr(offset)
//						alert(left + '<CARET>' + right)
//						alert('offset=' + offset + '\ntext=' + t + '\n\n\nleft=' + left + '\n\n\nright=' + right)
						lineNode.innerText = left + '\t' + right
//alert('4')						
						popCaretSelection()
						// Advance after tabbing
						sel.modify('move', 'right', 'character')
//alert('5')						
				document.getElementById('dump6').innerHTML += '\nselectionAsLineAndOffset line=' + h.line + ', offset=' + h.offset

					}
					else
					// Move lines back and from
					{
//						alert(sel.extentNode.parentNode.innerText + ' ' + sel.extentOffset)
//						alert('tab selection TODO, account shift')
						
//						pushRangeSelection()
/*
						var str = 'when shift selecting keyboard, selection differs and selects part of the first line'
						str += '\nanchor=(' + sel.anchorOffset + ')' + lineNodeFromNode(sel.anchorNode).innerText
						str += '\nextent=(' + sel.extentOffset + ')' + lineNodeFromNode(sel.extentNode).innerText
						str += '\nbase=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\noffset=(' + sel.focusOffset + ')' + lineNodeFromNode(sel.focusNode).innerText
						alert(str)
*/
alert('SEL TAB MULTIPLE LINES')
						// Keyboard selecting lines will select the next line with a zero offset
						// happens on triple-clicking left space on tabs on a function
						if (sel.extentOffset == 0) lineNumber2--

//						alert(lineNumber + ' ' + lineNumber2)
//						alert(lineNodeFromNode(sel.baseNode).innerText)
						
						if (lineNumber2 <= lineNumber)
						{
							var tmp = lineNumber2
							lineNumber2 = lineNumber
							lineNumber = tmp
						}
						
						for (var i=lineNumber; i<=lineNumber2; i++)
						{
							alert('change innerText to READ')
							var line = nodeFromLineNumber(i)
							if (!event.shiftKey)
								line.innerText = '\t' + line.innerText
							else
							{
								line.innerText = line.innerText.toString().replace(/^\s/, '')
							}
						}
//						popRangeSelection()
					}
				}
				
				// Custom word delete handling
				if (keyCode == 8 && event.altKey)
				{
					alert('CHECK ! extent selection to previous word. if overflows line, just move it to start of line')
				}
				
				// Insert new line
				// Check enter and CTRL+O
				if (keyCode == 13 || (keyCode == 79 && event.ctrlKey))
				{
					if (sel.type == 'Caret')
					// OR if one line range
					{
						event.preventDefault()
						pushCaretSelection()
						lineNode.innerText = readRawSourceFromLineQuicker(lineNode)
						popCaretSelection()
						var l = lineNumberFromNode(sel.anchorNode)
						
						var line = lineNodeFromNode(sel.anchorNode)
						
						sel.setBaseAndExtent(line, 0, sel.anchorNode, sel.anchorOffset)
//						alert(line.innerText + '\n' + l)
//						var c = characterOffsetFromLineAndNode(sel.anchorNode, sel.anchorOffset)
						
//						sel.modify('extend', 'left', 'line')
						
						
						
						var leftLength = sel.toString().length
//						var newLine = line.innerText.substr(leftLength)
						
//						alert(l)
//						alert(lines[l])
//						alert(sel.toString().length + '\n' + line.innerText.length)
						
						var n = document.createElement(lineElementName)
						n.className = 'line'
						
						// Add \n if it's not here (happens on one-line documents)
						var rightText = line.innerText.substr(leftLength)
						if (!rightText.match(/\n/)) rightText += '\n'
						// Get space (minus \n) on cursor left
						var leftSpace = line.innerText.substr(0, leftLength).toString().match(/^\s*/).toString().replace(/(\r|\n)/g, '').toString()
						n.innerText = leftSpace + rightText
						
						line.insertAdjacentElement('afterEnd', n)
						line.innerText = line.innerText.substr(0, leftLength) + '\n'

						if (keyCode == 13)
						{
							sel.setPosition(n, 0)
							if (leftSpace.length)
							{
								for (var i=0; i<leftSpace.length; i++)
									sel.modify('move', 'right', 'character')
							}
						}
						else
							sel.setPosition(sel.extentNode, sel.extentOffset)
					}
					else
					{
						// Nothing to do with a range as no newline is inserted.
					}
					
				}
				
				/*
					If Range selection, save all lines
				*/
			}
			
			var previouslySelectedLine
			function	postKeydown()
			{
				var sel = getSelection()
//				var lineNumber = lineNumberFromNode(sel.anchorNode)
				
				/*
					Maybe 
					* deleted everything
						-> just a text node left, or a br
					* backspace or delete
						-> two spans on the same line					
				*/
				
				var line = lineNodeFromNode(sel.anchorNode)
				if (!line)
				{
					// Will be called even after ALT-L (select address bar), check if we have a selection
					if (sel.type == 'None')	return
					
					alert('ADD READ')
					var newLines = highlighted.innerText.split('\n')
					highlighted.innerHTML = ''
//					alert(newLines.length)
					for (var i=0; i<newLines.length; i++)
					{
						var n = document.createElement(lineElementName)
						n.className = 'line'
						n.innerText = newLines[i] + '\n'
						highlighted.appendChild(n)
					}
					// Select the text node
					sel.setPosition(highlighted.firstChild.firstChild, 0)
					var line = lineNodeFromNode(sel.anchorNode)
				}
				
				if (previouslySelectedLine)	previouslySelectedLine.className = 'line'
				previouslySelectedLine = null
				if (sel.type == 'Caret')
				{
					previouslySelectedLine = line
					line.className += ' selectedLine'
				}
				
				var lineCount2			= highlighted.childNodes.length
				var currentLineNumber2 	= lineNumberFromNode(sel.anchorNode)
				
				var currentLineText2 	= readRawSourceFromLine(lineNodeFromNode(sel.anchorNode))

//alert(currentLineText + '\n\n' + currentLineText2 + '\n\n\nn1=' + currentLineNumber + '\nn2=' + currentLineNumber2)
				
				var mode = 'selecting'
				var moved = lineCount2 != lineCount
				var lineChanged = !(currentLineNumber2 == currentLineNumber && currentLineText2 == currentLineText)
				if (moved || lineChanged)
					mode = 'typing'
					
/*				
				var str  = getTickCount() + ' '
				if (mode == 'typing') 	str += '<span style="color: red">' + mode + '</span>'
				else					str += mode
				
				
				if (line.previousSibling && line.previousSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red">PREVIOUS SPAN ON SAME LINE</span>'
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
					str += '\n<span style="color: red"><b>NEXT</b> SPAN ON SAME LINE</span>'
*/
				// While forward or backward deleting, the next line SPAN came onto the current SPAN. Remove it
				if (line.nextSibling && line.nextSibling.offsetTop == line.offsetTop)
				{
					pushCaretSelection()
					line.innerText = readRawSourceFromLineQuicker(line)
					line.nextSibling.innerText = readRawSourceFromLineQuicker(line.nextSibling)
					line.innerText += readRawSourceFromLine(line.nextSibling)
					line.nextSibling.parentNode.removeChild(line.nextSibling)
					popCaretSelection()
					// Selection stays the same, nice !
				}
/*
				str += '\nchildNodesCount=' + highlighted.childNodes.length + ' \\n count=' + (highlighted.innerText.match(/\n/g)||0).length
				
				str += '\nlineCount=' + lineCount
				str += '\nlineCount2=' + lineCount2
				str += '\nlineNumber=' + currentLineNumber
				str += '\nlineNumber2=' + currentLineNumber2
				str += '\ncurrentLineText=' + currentLineText
				str += '\ncurrentLineText2=' + currentLineText2
				str += '\n!=lineCount=' + (lineCount2 != lineCount)
				str += '\n!=currentLineNumber=' + (currentLineNumber2 != currentLineNumber)
				str += '\n!=currentLineText=' + (currentLineText2 != currentLineText)
				
				document.getElementById('dump4').innerHTML = str
*/				
//				document.getElementById('dump5').innerHTML += '*PKD*line=' + currentLineNumber2
				
				
				if (mode != 'typing')	return
				
				highlightText()

//				alert(lines)
				
			}
			function	keyup()
			{
//				dumpHighlighted()
//				dumpInternalSource()
			}

			function	updateBirdView(line, functionLines)
			{
				var str = ''
				for (var i=0; i<functionLines.length; i++)
				{
					var idx = functionLines[i]
					var line = lines[idx]
					str += idx + '=' + line + '<br>'
				}
				document.getElementById('birdView').innerHTML = str
				
			}
			
			var charWidth = 0
			function	highlightText()
			{
				charWidth = document.getElementById('fontWidthMeasurer').firstChild.offsetWidth
				var lines = []
				var f = highlighted.firstChild
				while (f)
				{
					var text = readRawSourceFromLineQuicker(f)
					lines.push(text)
					f = f.nextSibling
				}
//				alert(lines.join('').substr(0, 200))
				var lint = lintLines(lines)
				
				highlighted.className = lint.res ? '' : 'lintError'


				pushCaretSelection()
				
				var f = highlighted.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					writeTokensToLine(f, tokens, line)
					f = f.nextSibling
					i++
				}
				
				popCaretSelection()
				
				
				updateBirdView(lines, lint.functionLines)
//				alert(lint.errors)

				var str = getTickCount() + ' highlight'
				for (var i=0; i<lint.errors.length; i++)
				{
					var error = lint.errors[i]
					str += i + '='
//					str += JSLINT.errors[i].line
					str += dumpHash(error)
					str += '<br>'
//					str += error['reason'] + '<br>'
//					str += i + '=' + error.reason + '<br>'
//alert(dumpHash(e))
//					str += i + '=' + e.line + '<br>'
				}
//				alert(lint.errors[0].reason)
//				alert(str)
				str = '\n<span style="color: red">' + str + '</span>'
				document.getElementById('dump5').innerHTML = str

			}
			
			
			highlighted.onkeyup = keyup
			highlighted.onkeydown = keydown
			
			
			function	selectstart()
			{
				document.getElementById('dump4').innerHTML = getTickCount() + ' selectstart'
			}
			highlighted.onselectstart = selectstart
			
			function	focusHighlighted()
			{
				highlighted.focus()

				var s = getSelection()
				s.collapseToStart()
				highlightText()
//				s.setPosition(highlighted, 5)
//				s.setPosition(highlighted.firstChild.firstChild, 5)
				
//				s.setBaseAndExtent(highlighted.firstChild.firstChild, 5, highlighted.firstChild.nextSibling.firstChild, 7)
//				s.empty()
				
/*

	.	addRange: function addRange() {
	.	anchorNode: Text
	.	anchorOffset: 11
	.	baseNode: Text
	.	baseOffset: 11
	.	collapse: function collapse() {
	.	collapseToEnd: function collapseToEnd() {
	.	collapseToStart: function collapseToStart() {
	.	containsNode: function containsNode() {
	.	deleteFromDocument: function deleteFromDocument() {
	.	empty: function empty() {
	.	extend: function extend() {
	.	extentNode: Text
	.	extentOffset: 11
	.	focusNode: Text
	.	focusOffset: 11
	.	getRangeAt: function getRangeAt() {
	.	isCollapsed: true
	.	modify: function modify() {
	.	rangeCount: 1
	.	removeAllRanges: function removeAllRanges() {
	.	selectAllChildren: function selectAllChildren() {
	.	setBaseAndExtent: function setBaseAndExtent() {
	.	setPosition: function setPosition() {
	.	type: "Caret"


*/

//				alert(s)
//				zea
			}
			setTimeout(focusHighlighted, 10)
			
			
			
			
			function	clearDumps()
			{
				document.getElementById('dump2').innerHTML = ' '
				document.getElementById('dump3').innerHTML = ' '
				document.getElementById('dump4').innerHTML = ' '
				document.getElementById('dump5').innerHTML = ' '
				document.getElementById('dump6').innerHTML = ' '
			}

		</script>

<pre>
	<h1 style='color: red'>
* highlight happens on caret move : left/right + up/down on overflowing lines
* enter removes white space
* birdview keeps OLD LINES !
	</h1>
	
</body>
</html>
