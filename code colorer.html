<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Code Colorer</title>
<!--
-->	
	<link rel="stylesheet" href="code%20colorer.css" type="text/css" />
	<style>
	
		#coloredCodeContainer
		{
			position: relative;
			white-space: pre-wrap;
			font-family: monaco;
			font-size: 7pt;
			epadding: 1em;
		}
		#coloredCode
		{
			outline: none;
			position: relative;
			z-index: 20;
		}
	
		/*
		*
		* Dump styles
		*
		*/
		td
		{
			vertical-align: top;
		}
		
		.selectedLine
		{
			position: absolute;
			width: 100%;
			ebackground-color: red;
			border: solid 1px #fc8;
			border-left: 0;
			border-right: 0;
			margin-top: -2px;
			background: -webkit-gradient(linear, left top, left bottom, from(#fec), to(#fda));
		}
		.selectedLinePosition
		{
			position: absolute;
			right: 0;
			bottom: 0;
			text-align: right;
			color: #f80;
			vertical-align: bottom;
			margin-right: 4px;
			efont-size: 70%;
		}
		
		.selectionDump
		{
			width: 350px;
		}
		.selectionDump, .selectionDump td
		{
			border: solid 1px #aaa;
		}
		.selectionDump .header
		{
			font-weight: bold;
		}
		#undoStackDump
		{
			color: #8c0;
		}
	</style>
</head>
<body>

<ul><li>REMOVE STYLESHEET
	<li><h1 style='color: red'>save selection with all four types and offsets</h1>
	<li>make an automated undo tester : random commands (including undo/redo) + consistency test : replay to initial state, then back to final
	<li>make a statement list ?
		</ul>


<table border='1' style='table-layout: fixed; width: 100%; height: 800px; height: 650px' cellPadding='0' cellSpacing='0'><tr>
	<td>
		<div id='coloredCodeContainer'><div id='coloredCode'></div></div>
	</td>
	<td style='width: 300px'>
		<div id='birdView'></div>
		<hr>
		<div id='birdViewDump'>LOG ALL COMMANDS HERE. typing (typing count, line extent + sel) + move + undo/redo</div>
		<hr>
		<div id='selectionDump'>SELECTION DUMP</div>
		<div id='undoStackDump'>UNDO DUMP</div>
		<button onclick='undo()'>undo</button>
		<button onclick='redo()'>redo</button>
	</td>
</tr></table>

	<textarea style='display: none'>
		
	//	List launched applications
	var apps = [[NSWorkspace sharedWorkspace] launchedApplications]

	for (var i=0; i<apps.length; i++)
		// option-right from next EOL
		log(apps[i].NSApplicationName)	


	// Instead of using alloc/init and releasing ...
	var url = [[NSURL alloc] initFileURLWithPath:"/tmp" isDirectory:true]
	[url release]
	// Replace 'init' in the method name with 'instance' to get an object managed by JavascriptCore
	var url = [NSURL instanceFileURLWithPath:"/tmp" isDirectory:true]
	// Mark object as collectable
	url = null


	// Mix and match ObjJ and Javascript syntax
	var a = [NSArray arrayWithObjects:'hello', [7, 8, 9], 'world']
	log('a[1][2]=' + [[a objectAtIndex:1] objectAtIndex:2])
	log('a[1][1]=' + [a[1] objectAtIndex:1])
	log('a[1][0]=' + a[1][0])


	// Syntactic sugar for selector notation
	var o = [SomeObject instance]
	[o performSelector:@selector(doStuff:) withObject:anObject afterDelay:500]
	
	
	//
	// Define a Cocoa class in Javascript
	//	It can then be used from Javascript or Cocoa (use it as a delegate class, create a new NSView, ...)
	//
	class MyObject < NSObject
	{
		// Find objects containing at least one capital letter
		- (NSArray*)findObjectsInArray:(NSArray*)array
		{
			return array.filter(function (elt) { return elt.match(/[A-Z]/) })
		}
		// Use radix = 16 to parse hex
		// Use radix = 36 to parse a Reddit story number
		- (NSNumber*)parseNumberInString:(NSString*)str withRadix:(int)radix
		{
			return parseInt(str, radix)
		}
		// NSApplication delegate method
		- (void)applicationWillBecomeActive:(NSNotification *)notification
		{
			log('Hello ! ' + notification.name)
		}
	}

	// Instance our new class
	var obj = [MyObject instance]
	log([obj parseNumberInString:'9q5vm' withRadix:'36'])
	// Register it as application delegate
	[NSApplication sharedApplication].delegate = obj


	//
	// Swizzle a method from an existing class
	//
	class NSButton
	{
		swizzle - (void)drawRect:(NSRect)rect
		{
			// Call original method
			this.Original(arguments)
			log('drawRect: called on button ' + this)
		}
	}

</textarea>

	<pre id='dump'></pre>



<table style='table-layout: fixed; width: 100%'><tr><td style='width: 480px'>
<tr><td>
	<pre id='dump2'></pre>
<td>
	<pre id='dump3'></pre>
	<pre id='dump4'></pre>
</tr></table>
	<button onclick="clearDumps()">Clear</button>
	<pre id='dump5'></pre>
	<pre id='dump6'></pre>

	<script src="crockford/json2.js"></script>
	<script src="crockford/jslint-jscocoa.js"></script>
	<script src='showdown.js'></script>

		<script>
		
			var MarkDownConverter = new Showdown.converter()

			function	htmlEncode(str)
			{
//				return str
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
				return str.replace(/</g, '&lt;')
			}
			function	getTickCount()
			{
				return (new Date).getTime()
			}
			function	dumpHash(o)
			{
				var str = ''
				for (var i in o) str += i + '=' + (o[i]) + '\n'
				return str
			}
			function	dumpHashNoFunction(o)
			{
				var str = ''
				for (var i in o) { if (typeof o[i] == 'function') continue; str += i + '=' + (o[i].toString == 'toStringToken' in this ? ('*TOKEN*'+o[i].value + '*') : o[i]) + '\n' }
				return str
			}
			function	newNodeAsChildOf(node, tagName)
			{
				var n2 = document.createElement(tagName||'DIV')
				node.appendChild(n2)
				return n2
			}
			

			// Walkers
			function nextNode(n)
			{
				if (n.firstChild)	return n.firstChild
				while (n)
				{
					if (n.nextSibling)	return n.nextSibling
					n = n.parentNode
				}
				return	null
			}
			function	previousNode(n)
			{
				if (n.previousSibling)
				{
					n = n.previousSibling
					while (n && n.lastChild)
						n = n.lastChild
					return	n
				}
				n = n.parentNode
				return	n
			}
			
			
			function	dumpSelection()
			{
					function dumpSelectionNode(name)
					{
						var node = sel[name + 'Node']
						var offset = sel[name + 'Offset']
						if (!node)	return str += name + '=(null)<br>'
						var t = ''
//						str += '\n' + name + '(' + offset + ')=' + (t)

						str += '<tr><td style="color: blue">' + name + '<td>' + cc.lineNumberFromNode(node) + '<td>' + offset


						var o = cc.lineAndOffsetFromNodeAndOffset(node, offset)
						str += '<td>' + o.line + ',' + o.offset + ' &nbsp; l=' + cc.sourceFromLine(cc.lineNodeFromNode(node)).length

							str += '<tr><td colSpan="4">'
						if (node.nodeType == 3) 
						{
							t = node.nodeValue
							str += '<span style="color:#a00">*</span>' + t.substr(0, offset) + '<span style="color:red">*</span>' + t.substr(offset) + '<span style="color:#a00">*</span>'
							str += ' length=' + t.length
						}
						if (node.nodeType == 1) 
						{
//							t = node + '->' + htmlEncode(cc.sourceFromLine(node).substr(0, 80))
							t = htmlEncode(cc.sourceFromLine(node).substr(0, 80))
							var line = cc.lineNumberFromNode(node)
							str += '<span style="color: lime">DIV</span> line=' + line + ' content=' + node.innerText
						}

//						str += '<span style="color: blue">' + (lineNumber+1) + ',' + (offset2+1) + ' <span style="efont-size: 50%; opacity: 0.5">' + lineNumber + ',' + offset2 +  '</span></span>'
//						str += '<span style="color: blue">' + (lineNumber) + ',' + (offset2) + '</span>'
						str += '<br><br>'
					}
				var sel = getSelection()
				var str = '<table class="selectionDump" eborder="1" style="border-collapse: collapse; table-layout: fixed">'
				str += '<tr class="header"><td>name</td><td>line</td><td>offset</td><td><nobr>line, lineoffset, length</nobr></td></tr>'
					dumpSelectionNode('base')
					dumpSelectionNode('anchor')
					dumpSelectionNode('extent')
					dumpSelectionNode('focus')
					str += '</table>'
				return str
			}











			//
			// Code colorer class
			// 						
			function	CodeColorer(editorNode, containerNode, birdViewNode)
			{
				this.initWithNodes(editorNode, containerNode, birdViewNode)
			}
			var CCp = CodeColorer.prototype
			CCp.initWithNodes = function (editorNode, containerNode, birdViewNode)
			{
				this.editorNode		= editorNode
				this.birdViewNode	= birdViewNode
				this.containerNode	= containerNode
/*
><div id='bubbleContainer'></div><div id='lineNumbers'></div><div id='selectedLine'><div id='selectedLinePosition'></div></div><div id='highlightedContainer'><div id='tracesContainer'></div><div id='whiteSpaceRevealer'></div>
*/			
				this.editorNode.contentEditable = true
				
				this.bubbleContainer	= newNodeAsChildOf(this.containerNode)
				this.lineNumbers		= newNodeAsChildOf(this.containerNode)
				this.selectedLine		= newNodeAsChildOf(this.containerNode)
				this.selectedLinePosition	= newNodeAsChildOf(this.selectedLine)
				this.tracesContainer	= newNodeAsChildOf(this.containerNode)
				this.whiteSpaceRevealer	= newNodeAsChildOf(this.containerNode)
				
				this.selectedLine.className	= 'selectedLine'
				this.selectedLinePosition.className	= 'selectedLinePosition'


				// Measure width of one character
				this.fontWidthMeasurer	= newNodeAsChildOf(this.containerNode)
				this.fontWidthMeasurer.innerHTML = '<span>*</span>'


				this.selectionStack = []
				this.undoStack = []
				this.redoStack = []
				
				// Create lint and register our logs
				var logNames = ['logToken', 'logExtraSyntax']
				var logs = {}
				var self = this
				for (var i=0; i<logNames.length; i++)	{
					var name = logNames[i]
					// Close name
					logs[name] = function (name) { return function () { return self[name].apply(self, arguments) } }(name)
				}
				this.JSLINT = JSLintWithLogs(logs)
				this.jslint = this.JSLINT()
				
				// Events
				var self = this
				this.editorNode.onkeydown		= function () { return self.keydown.apply(self, arguments) }
				this.editorNode.oncopy			= function () { return self.copy.apply(self, arguments) }
				this.editorNode.oncut			= function () { return self.cut.apply(self, arguments) }
				this.editorNode.onpaste			= function () { return self.paste.apply(self, arguments) }
				this.editorNode.onmousedown		= function () { return self.mousedown.apply(self, arguments) }
				this.postKeydownEventFunction	= function () { return self.postKeydown.apply(self, arguments) }
			}
			
			//
			// Helpers
			// 
			CCp.warn = function (str)
			{
				document.getElementById('dump3').innerHTML = getTickCount() + '<br>' + '<span style="color: red">' + str + '</span>'
			}
			CCp.dumpLintErrors = function (errors)
			{
				var str = ''
				for (var i=0; i<errors.length; i++)
					if (errors[i]) str += '(' + errors[i].line + ',' + errors[i].character + ')=' + errors[i].reason + '\n'
				return str
			}
			CCp.toString = function () {
				return 'CodeColorer'
			}
			
			//
			// Text loading
			//
			CCp.loadText = function (text)
			{
				// Should remove \r
				var lines = text.split('\n')
				this.loadLines(lines)
			}
			CCp.loadLines = function (lines)
			{
				this.measureCharWidth()
				var src = []
				if (lines.length == 0) lines = ['']
				for (var i=0; i<lines.length; i++)
				{
					var l = lines[i]
					l = this.replaceTabsInLine(l)
					l = '<div class="line">' + l + '\n</div>'
					src.push(l)
				}
				this.editorNode.innerHTML = src.join('')
			}
			CCp.lineCount = function()
			{
				return this.editorNode.childNodes.length
			}
			CCp.rawText = function ()
			{
				return this.editorNode.innerText
			}

			CCp.measureCharWidth = function ()
			{
				this.charWidth = this.fontWidthMeasurer.firstChild.offsetWidth
			}

			CCp.sourceFromLine = function(line)
			{
				if (typeof line == 'number')
					line = this.nodeFromLineNumber(line)
				
				var t = line.innerText
				// When suppr-ing text from the end of line, Safari might delete newline - readd it
				if (!t.match(/\n/)) t += '\n'
//				if (line.lastChild && line.lastChild.className == 'newline') t += '\n'
				return	t
			}
			
			
			//
			// Line and offset computation
			// 
			CCp.lineNodeFromNode = function (node)
			{
				while (node)
				{
					if (node.nodeType == 1 && node.className.match(/\bline\b/))
						return node
					node = node.parentNode
				}
				return node
			}
			
			CCp.lineNumberFromNode = function (node)
			{
				node = this.lineNodeFromNode(node)
				if (!node)	return
				var i = 0
				node = node.previousSibling
				while (node)
				{
					i++
					node = node.previousSibling
				}
				return i
			}
			CCp.nodeFromLineNumber = function (i)
			{
				return this.editorNode.childNodes[i]
			}
			// Given a relative (node, offset), return an absolute offset in the matching line
			CCp.lineAndOffsetFromNodeAndOffset = function (node, offset)
			{
				var n = node
				var offset2 = offset, lineNumber = this.lineNumberFromNode(n)
				if (n.className != 'line')
				{
					n = previousNode(n)
					while (n && n.className != 'line')
					{
						if (n.nodeType == 3) offset2 += n.nodeValue.length
						n = previousNode(n)
					}
				}
				return	{ line : lineNumber, offset : offset2, isDiv : node.className == 'line' && offset == 0 }
			}
			// Given an absolute (line, offset), return an inner line node and offset
			CCp.nodeAndOffsetFromLineAndOffset = function (line, offset, isDiv)
			{
				var lineNode		= this.nodeFromLineNumber(line)
				if (isDiv && offset == 0)	return { node : lineNode, offset : offset }
				var currentOffset	= 0
				
				var n = nextNode(lineNode)
				while (n && n.className != 'line')
				{
					if (n.nodeType == 3)
					{
						var t = n.nodeValue
						if (currentOffset + t.length >= offset)
							return { node : n, offset : offset-currentOffset }
						else
							currentOffset += t.length
					}
					n = nextNode(n)
				}
				return { node : null, offset : undefined }
			}


			//
			// Selection handling
			// 
			CCp.rawSelection = function ()
			{
				var sel = getSelection()
				return sel.getRangeAt(0)
			}
			CCp.setRawSelection = function (r)
			{
				var sel = getSelection()
				sel.removeAllRanges()
				sel.addRange(r)
			}
			
			CCp.selectionAsLineAndOffset = function ()
			{
				var sel = getSelection()
				var raw = this.rawSelection()

				sel.modify('extend', 'left', 'paragraphboundary')
				var selectionText = sel.toString()
				var length = selectionText.length
				var range = sel.getRangeAt(0)
				var h = { type : 'Caret', line : this.lineNumberFromNode(sel.baseNode), offset : length }

				this.setRawSelection(raw)

				return h
			}

			CCp.setSelectionAsLineAndOffset = function (line, offset)
			{
				var line = this.nodeFromLineNumber(line)
				var sel = getSelection()
				sel.setPosition(line, 0)
				for (var i=0; i<offset; i++)
					sel.modify('move', 'right', 'character')
			}

			CCp.setRangeSelectionAsLinesAndOffsets = function (line1, offset1, line2, offset2)
			{
				var sel = getSelection()
				this.setSelectionAsLineAndOffset(line1, offset1)
				var baseNode	= sel.baseNode
				var baseOffset	= sel.baseOffset
				this.setSelectionAsLineAndOffset(line2, offset2)
				var extentNode	= sel.extentNode
				var extentOffset= sel.extentOffset
				sel.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset)
			}
			
			//	Return the current range selection as 
			//	{ 
			//		 base : { line, offset }
			//		,extent : { line, offset }
			//	}
			
			CCp.rangeSelectionAsLineAndOffset = function()
			{
				var sel = getSelection()

				var names = ['anchor', 'extent', 'focus', 'base']
				var base = { line : 999999999, offset : 999999999 }
				var extent = { line : -1, offset : -1 }
				for (var i=0; i<names.length; i++)
				{
					var name = names[i]
					var s = this.lineAndOffsetFromNodeAndOffset(sel[name + 'Node'], sel[name + 'Offset'])
					if (s.line < base.line) 	base = s
					if (s.line == base.line && s.offset < base.offset)		base = s
					if (s.line > extent.line)	extent = s
					if (s.line == extent.line && s.offset > extent.offset)	extent = s
				}
				return { base : base, extent : extent }
			}

			CCp.pushCaretSelection = function()
			{
				this.selectionStack.push(this.selectionAsLineAndOffset())
			}
			CCp.popCaretSelection = function()
			{
				var s = this.selectionStack.pop()
				this.setSelectionAsLineAndOffset(s.line, s.offset)
			}
			CCp.pushRangeSelection = function()
			{
				this.selectionStack.push(this.rangeSelectionAsLineAndOffset())
			}
			CCp.popRangeSelection = function()
			{
				var s = this.selectionStack.pop()
				this.setRangeSelectionAsLinesAndOffsets(s.base.line, s.base.offset, s.extent.line, s.extent.offset)
			}
			CCp.caretSelectionOnStack = function()
			{
				if (!this.selectionStack.length)	return
				return	this.selectionStack[this.selectionStack.length-1]
			}
			
			CCp.pushSelection = function ()
			{
				this.pushCaretSelection()
			}
			CCp.popSelection = function ()
			{
				this.popCaretSelection()
			}

			CCp.pushSelection2 = function ()
			{
			}
			CCp.popSelection2 = function ()
			{
			}
			
			// Return position - offset differs from selection offset, as tabs will count for 1 to 4 chars
			CCp.textPositionAsLineAndOffset = function ()
			{
				var sel = getSelection()
				var s = this.selectionAsLineAndOffset()
				var line	= this.lineNodeFromNode(sel.baseNode)
				var str = this.sourceFromLine(line).substr(0, s.offset)

				var o = {}
				this.replaceTabsInLine(str, null, null, o)
				return { line : s.line, offset : o.totalWidth }
			}


			CCp.gatherLinesToLint = function ()
			{
				var lines = []
				var f = this.editorNode.firstChild
				while (f)
				{
					var text = this.sourceFromLine(f)
					lines.push(text)
					f = f.nextSibling
				}
				return lines
			}
			
			CCp.lintLines = function (lines)
			{
				var options = { forin : true, laxbreak : true, indent : true }

//### FIX INSTANCE VARS				
				this.tokensByLine	= {}
				this.functionLines	= []
//				this.traceTokens	= []
    			var res = this.jslint(lines, options)
				return { tokens : this.tokensByLine, res : !!res, functionLines : this.functionLines, errors : this.JSLINT.errors }
			}
			
			//
			// Color code
			// 
			CCp.colorCode = function ()
			{
					this.measureCharWidth()
				
				var lines = this.gatherLinesToLint()
				var lint = this.lintLines(lines.join(''))
//				alert(lines)
				if (!lint.res)	
				{
					this.warn('Lint error dump ... ' + getTickCount() + '\n' + this.dumpLintErrors(lint.errors))
				}
				else
				{
					document.getElementById('dump3').innerHTML = getTickCount() + ' <span style="color: lime; font-weight: bold">OK</span>'
				}
				
				
				//
				// Color
				//
				this.pushSelection()

				var f = this.editorNode.firstChild
				var i = 0
				while (f)
				{
					var tokens = lint.tokens[i]
					if (!tokens) tokens = []
					var line = lines[i]
					this.writeTokensToLine(f, tokens, line, i)
					
					f = f.nextSibling
					i++
				}
				this.popSelection()
				
			}

			//
			//
			// Write functions
			// 
			//
			CCp.replaceTabsInLine = function (line, html, customReplaceFunction, o)
			{
				if (!html)	html = htmlEncode(line)
				var tabWidths = []
				function	countTabs(str, idx)
				{
					var length = (idx+deltaTabPosition) % tabWidth
					length = tabWidth - length
					// Add spaces to position (minus one to 'remove' the tab)
					deltaTabPosition += length-1
					
					tabWidths.push(length)
				}

				var tabIndex = 0
				var charWidth = this.charWidth
				function	replaceTabs(str, idx)
				{
					// A tab is surrounded by a SPAN nulling its width (with negative letter-spacing) and padding it to the correct 4-size with charWidth (measured in fontWidthMeasurer)
					totalWidth += tabWidths[tabIndex]
					var w1 = charWidth
					var w2 = tabWidths[tabIndex++]*charWidth
					return '<span class="fakeTab" style="letter-spacing: -' + w1 + 'px; padding-right: ' + w2 + 'px">	</span>'
				}
				var tabWidth = this.tabWidth()
				var deltaTabPosition = 0

				// Count tabs
				line.replace(/\t/g, countTabs)
				// Total character width of line (counting a full tab as tabWidth())
				var totalWidth = line.length - tabWidths.length
				// Replace tabs
				html = html.replace(/\t/g, customReplaceFunction ? function () { return customReplaceFunction(tabWidths[tabIndex++]) } : replaceTabs)
				
				// Output totalWidth
				if (o)	o.totalWidth = totalWidth
				
				return	html
			}
			CCp.tabWidth = function ()
			{
				return	4
			}
			
			CCp.writeTokensToLine = function (node, tokens, line, lineNumber)
			{
				var i = 0
				var lastIndex 	= 0
				var str = ''
				while (tokens[i])
				{
					var token = tokens[i]
					// Skip endline
					if (token.id == '(endline)')
					{
						i++
						continue
					}
					
					if (token.rawValue && token.from > lastIndex)
					{
						var space = line.substr(lastIndex, token.from-lastIndex)
						str += htmlEncode(space)
					}
					var c = ''
					var v = token.value
					v = line.substr(token.from, token.character-token.from)
					if (token.identifier) c = 'identifier-' + token.value
					if (token.reserved) c = 'keyword'
					if (token.id && !token.reserved) 
					{
						c = 'exps'
					}
					if (token.type == '(number)') c = 'number'
					if (token.type == '(string)') 
					{
						c = 'string'
					}
					if (token.type == '(comment)') 
					{
						c = 'comment'
//						alert(line + '*\ncharacter=' + token.character + '\nline.length=' + line.length + '\nv=' + v + '*')

						// Single line markdown comment
//						if (v.match(/^\/\/md/))
//						{
//							v = v.replace(/^\/\/md\s?/, '')
//							v = MarkDownConverter.makeHtml(v)
//							v = '<span class="markdown-singleline-container"><span class="markdown-singleline">' + v + '</span></span>'
//							printEndLine = false
//						}

					}
					if (token.isObjCCall)
					{
						c += ' objcCall'
						if (!token.isObjCCallOpener && !token.isObjCCallCloser && !token.isObjCFirstCall)	
							c+= ' objcCallSelector'
						if (token.isObjCCallOpener || token.isObjCCallCloser)
							c += ' objcCallBracket'
					}
					v = htmlEncode(v)
					str += '<span class="' + c + '">' + v + '</span>'
					lastIndex = token.character
					i++
				}
				// Copy end of line
				if (lastIndex < line.length)
				{
					var space = line.substr(lastIndex)
					str += htmlEncode(space)
				}

				// TABS ! sized to any size you want.
				str = this.replaceTabsInLine(line, str)
				str = str.replace(/\n/, '<span class="newline">\n</span>')
				
				node.innerHTML = str
			}
			
			//
			// Logs
			// 
			CCp.logToken = function (token)
			{
/*
				var el  = token.id == '(endline)' ? '\n' : ''
				var id = token.id ? ('<span style="color: blue">(<b>' + token.id + '</b>)</span> ') : ''
				document.getElementById('dump2').innerHTML += token.value + id + el
*/
//				if (this.lines[token.line])	token.rawValue = lines[token.line].substr(token.from, token.character-token.from)				
//				else						token.rawValue = ''
//				alert('handle rawvalue'), eaz()

				var line = token.line
				if (!this.tokensByLine[line])	this.tokensByLine[line] = []
				this.tokensByLine[line].push(token)
			}
			
			CCp.logExtraSyntax = function (syntaxName, token)
			{
//				alert(syntaxName)
			}

			
			CCp.mousedown = function()
			{
				var self = this
				function h()
				{
					self.highlightSelectedLine()
				}
				setTimeout(h, 0)
				this.closeUndoAction()
			}
			
			CCp.closeUndoAction = function ()
			{
				if (this.currentEditingAction == 'typing')
				{
					this.currentEditingAction = 'moving'
					if (this.undoStack.length)
					{
						var action = this.topUndoAction()
						action.closed = true
						
						var text = ''
						var lineChangedCount = action.newLineCount - action.backwardLineDeleteCount - action.forwardLineDeleteCount
						lineChangedCount = Math.abs(lineChangedCount)
//						if (lineChangedCount < 1) lineChangedCount = 1
//						alert(action.lastDeletedBackwardLineNumber + '\n' + lineChangedCount)
						for (var i=action.lastDeletedBackwardLineNumber; i<=action.lastDeletedBackwardLineNumber+lineChangedCount; i++)
							text += this.sourceFromLine(i)
						action.newText = text
						// Remove action if nothing was changed
						if (action.isBlank)	this.undoStack.pop()
					}
				}
				this.dumpUndoStack()
			}
			CCp.dumpUndoStack = function ()
			{
				if (this.undoStack.length)
				{
					var str = getTickCount() + ' actionCount=' + this.undoStack.length + ' redoActionCount=' + this.redoStack.length
					for (var j=this.undoStack.length-1; j>=0; j--)
					{
						var action = this.undoStack[j]
					
						str += '<br><br><b> ACTION ' + j  + '</b>  ' + (action.closed ? '' : ' ...IN PROGRESS') + ' ' + (action.isBlank ? '<b>isBlank</b>' : '')
						str += '<br>startedAtLine=' + action.startedAtLine
						if (j == this.undoStack.length-1)
							str += '<br>currentLine=' + action.currentLine
						str += '<br>range=' + action.startLine + ',' + action.endLine
						str += '<br>backwardLineDeleteCount=' + action.backwardLineDeleteCount
						str += '<br>forwardLineDeleteCount=' + action.forwardLineDeleteCount
						str += '<br>newLineCount=' + action.newLineCount
						str += '<br>lastDeletedBackwardLineNumber=' + action.lastDeletedBackwardLineNumber
						str += '<br>total line change count=' + (action.newLineCount - action.backwardLineDeleteCount - action.forwardLineDeleteCount)
//						str += '<br>text=' + action.text.split('n').length
						str += '<br>text=' + (action.text.split('\n').length-1) + ' lines'
						str += '<pre style="background-color: #eee">' + htmlEncode(action.text) + '</pre>'
						str += '<br>newText=' + (action.newText.split('\n').length-1) + ' lines'
						str += '<pre style="background-color: #eee">' + htmlEncode(action.newText) + '</pre>'
					}
					document.getElementById('undoStackDump').innerHTML = str
				}
			}
			
			CCp.topUndoAction = function ()
			{
				return this.undoStack[this.undoStack.length-1]
			}
			
			
			//
			// Events
			// 
			CCp.keydown = function ()
			{
				
				setTimeout(this.postKeydownEventFunction, 0)


				var sel = getSelection()


								if (!sel.baseNode)
									return


				var keyCode = event.keyCode

				var str = getTickCount() + ' postKeydown<br>'
				str += keyCode
				// up down left right
				this.movingForSure = keyCode >= 37 && keyCode <= 40
				// Backspace or suppr
				this.deletingForSure = keyCode == 8 || keyCode == 46
				this.keydownKeycode = keyCode
//				this.deletingDeletesLine = /*(lineCount > 0) && */ 

				var s = this.selectionAsLineAndOffset()
				
				str += '<br>linePREKEYDOWN=' + s.line
				str += '<br>lineCountPREKEYDOWN=' + this.lineCount()
				str += '<br>movingForSure='  + this.movingForSure
				str += '<br>deletingForSure='  + this.deletingForSure
				str += '<br>altKey=' + event.altKey + ' metaKey=' + event.metaKey
				
				if (this.deletingForSure)
				{
					// Need to account range
					var rawSelection = this.rawSelection()
					if (keyCode == 8)
					{
						sel.modify('extend', 'left', 'word')
						sel.collapseToStart()
					}
					else
					{
						sel.modify('extend', 'right', 'word')
						sel.collapseToEnd()
					}
					
					var s2 = this.selectionAsLineAndOffset()
					if (s.line != s2.line)
					{
						str += '<br><b style="color: red">DELETE OVERFLOW</b>'
					}
//					event.returnValue = false
					this.setRawSelection(rawSelection)
				}
				


//				str += '<br>line=' + s.line + ' lineNode='
				var text = this.sourceFromLine(this.nodeFromLineNumber(s.line))
				str += '<br>offset=' + s.offset + ' text='
				str += text.substr(0, s.offset)
				str += '<span style="color: red">*</span>'
				str += text.substr(s.offset)
				str += '<span style="color: red">*</span>'
				var lastChar = text.charCodeAt(text.length-1)

//				this.deletingForSure = keyCode == 8 || keyCode == 46
//				this.keydownKeycode = keyCode
				
				var isDeletingLineBackwards = this.keydownKeycode == 8 && s.offset == 0
				var isDeletingLineForwards = this.keydownKeycode == 46 && (lastChar == '\n' ? s.offset == text.length-2 : s.offset == text.length-1)
				
				// Deleting backwards only when we're not on the first line
				isDeletingLineBackwards = isDeletingLineBackwards && s.line
				// Deleting forwards only when we're not on the last line
				isDeletingLineForwards = isDeletingLineForwards && ((s.line+1) != this.lineCount())
				
				var isInsertingNewLine = keyCode == 13

				str += '<br>isDeletingLineBackwards=' +  (isDeletingLineBackwards ? '<b style="color: red">YES</b>' : 'no')
				str += '<br>isDeletingLineForwards=' +  (isDeletingLineForwards ? '<b style="color: red">YES</b>' : 'no')
				str += '<br>isInsertingNewLine=' +  (isInsertingNewLine ? '<b style="color: red">YES</b>' : 'no')
				
				// Undo
				if (event.metaKey && event.keyCode == 90)
				{
//					if (event.shiftKey)
					str += '<br><span style="font-weight: bold; color: red; font-size: 200%">' + (event.shiftKey ? '......REDO' : 'UNDO') + '</span>'
				}
//				alert(dumpHash(event))
//				if ()
//alert(dumpHash(event))			

				// Update lineCount
				var lineCount = this.editorNode.childNodes.length
				if (!this.previousLineCount)	this.previousLineCount = lineCount
				var lineText 		= this.lineNodeFromNode(sel.baseNode).innerText
				if (!this.previousLineText)		this.previousLineText = lineText
				this.previousLineText = lineText

				if (event.altKey && (keyCode == 8 || keyCode == 46))
				{
					str += '<br><b>option delete</b>'
				}
				
				
				
				
				if (!this.movingForSure)
				{
//					var justStarted = false
					var previousAction = this.currentEditingAction
					// Create new action
					if (this.currentEditingAction != 'typing')
					{
						this.currentEditingAction = 'typing'
						
						var action = {}
						action.startedAtLine = s.line
						action.currentLine = action.startLine = action.endLine = s.line
						action.text = this.sourceFromLine(this.nodeFromLineNumber(s.line))
						action.newText = ''
						action.forwardLineDeleteCount = 0
						action.backwardLineDeleteCount = 0
						action.lastDeletedBackwardLineNumber = s.line
						action.newLineCount = 0
						
						this.undoStack.push(action)
					}
					// Update current undo action
					if (this.currentEditingAction == 'typing')
					{
						var action = this.topUndoAction()

						var currentLine = action.currentLine
						if (isDeletingLineBackwards)	currentLine--
						if (isInsertingNewLine)			currentLine++
						
						if (isDeletingLineBackwards)	action.backwardLineDeleteCount++
						if (isDeletingLineForwards)		action.forwardLineDeleteCount++
						if (isInsertingNewLine)			action.newLineCount++
						
						
						action.startLine	= Math.min(action.startLine, currentLine)
						action.endLine		= Math.max(action.endLine, currentLine)
						
						action.currentLine = currentLine
						
						if (isDeletingLineForwards)
						{
							var nextLineText = this.sourceFromLine(s.line+1)
							action.text += nextLineText
						}
						if (isDeletingLineBackwards && (s.line-1) < action.lastDeletedBackwardLineNumber)
						{
							action.lastDeletedBackwardLineNumber = s.line-1
							var previousLineText = this.sourceFromLine(s.line-1)
							action.text = previousLineText + action.text
						}
					}					
					if (previousAction != 'typing')	this.topUndoAction().isBlank = true
				}
				else
				{
					// Close undo action
					this.closeUndoAction()
				}
				
				this.dumpUndoStack()
				


				// REMOVE ME
				this.keydownStr = str + '<hr><b>END KEYDOWN</b><hr>'
//				alert('clean action in postkeydown if no typing')
//				this.birdViewNode.innerHTML = str





				
				if (sel.type != 'Caret' && sel.type != 'Range')	return
				
				var line = this.lineNodeFromNode(sel.baseNode)

				if (!line)
				{
					alert('Caret is not in a DIV')
					return
				}
					
				var lineNode 		= this.lineNodeFromNode(sel.baseNode)
				var lineNumber 		= this.lineNumberFromNode(sel.baseNode)
				lineCount			= this.editorNode.childNodes.length
				currentLineNumber 	= this.lineNumberFromNode(sel.baseNode)
//				currentLineText 	= lineNode.innerText
				currentLineText		= this.sourceFromLine(lineNode)
//				previousLineText	= lineNode.previousSibling ? lineNode.previousSibling.innerText : null
//				nextLineText		= lineNode.nextSibling ? lineNode.nextSibling.innerText : null
				


				//  Insert tab
				if (keyCode == 9)
				{
					var s = this.rangeSelectionAsLineAndOffset()
					var lineNumber1 = s.base.line
					var lineNumber2 = s.extent.line


					event.preventDefault()
					var lineNumber2 = this.lineNumberFromNode(sel.extentNode)
					// Insert a single tab
					if (lineNumber == lineNumber2)
					{
						if (sel.type == 'Range')	sel.deleteFromDocument()
						this.pushCaretSelection()
//alert('1')						
						var t = currentLineText
//						lineNode.innerText = t
						var offset = this.caretSelectionOnStack().offset
//alert('2')						
//alert('3')						
						var left = t.substr(0, offset)
						var right = t.substr(offset)
//						alert(left + '<CARET>' + right)
//						alert('offset=' + offset + '\ntext=' + t + '\n\n\nleft=' + left + '\n\n\nright=' + right)
						var text = left + '\t' + right
						lineNode.innerHTML = this.replaceTabsInLine(text)
//alert('4')						
						this.popCaretSelection()
						// Advance after tabbing
						sel.modify('move', 'right', 'character')
//alert('5')						
//				document.getElementById('dump6').innerHTML += '\nselectionAsLineAndOffset line=' + h.line + ', offset=' + h.offset

					}
					else
					// Move lines back and from
					{
//						alert(sel.extentNode.parentNode.innerText + ' ' + sel.extentOffset)
//						alert('tab selection TODO, account shift')
						
						this.pushRangeSelection()
/*
						var str = 'when shift selecting keyboard, selection differs and selects part of the first line'
						str += '\nanchor=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\nextent=(' + sel.extentOffset + ')' + lineNodeFromNode(sel.extentNode).innerText
						str += '\nbase=(' + sel.baseOffset + ')' + lineNodeFromNode(sel.baseNode).innerText
						str += '\noffset=(' + sel.focusOffset + ')' + lineNodeFromNode(sel.focusNode).innerText
						alert(str)
*/
/*
	alert('SEL TAB MULTIPLE LINES')
						// Keyboard selecting lines will select the next line with a zero offset
						// happens on triple-clicking left space on tabs on a function
						if (sel.extentOffset == 0) lineNumber2--

//						alert(lineNumber + ' ' + lineNumber2)
//						alert(lineNodeFromNode(sel.baseNode).innerText)
						
						if (lineNumber2 <= lineNumber)
						{
							var tmp = lineNumber2
							lineNumber2 = lineNumber
							lineNumber = tmp
						}
*/
						var s = this.rangeSelectionAsLineAndOffset()
						var lineNumber1 = s.base.line
						var lineNumber2 = s.extent.line
						// Full line selections have an extent that starts to the next line with an offset of 0. (1 if line starts with a fake tab)
						if (s.extent.offset == 0 || s.extent.offset == 1) lineNumber2--
						for (var i=lineNumber1; i<=lineNumber2; i++)
						{
							var line = this.nodeFromLineNumber(i)
							var t
							if (!event.shiftKey)	t = '\t' + this.sourceFromLine(line)
							else					t = this.sourceFromLine(line).toString().replace(/^\s/, '')
							
							line.innerHTML = this.replaceTabsInLine(t)
						}
						this.popRangeSelection()
					}
				}
/*				
				// Custom word delete handling
				if (keyCode == 8 && event.altKey)
				{
					alert('CHECK ! extent selection to previous word. if overflows line, just move it to start of line')
				}
*/				
				// Insert new line
				if (keyCode == 13)
				{
					if (sel.type == 'Caret')
					// OR if one line range
					{
						event.preventDefault()
						// Transform line to raw text
						this.pushCaretSelection()
						lineNode.innerText = this.sourceFromLine(lineNode)
						this.popCaretSelection()
						var l = this.lineNumberFromNode(sel.baseNode)
						
						sel.setBaseAndExtent(lineNode, 0, sel.baseNode, sel.baseOffset)


						var leftLength = sel.toString().length
						
						// Add \n if it's not here (happens on one-line documents)
						var rightText = this.sourceFromLine(lineNode).substr(leftLength)
						if (!rightText.match(/\n/)) rightText += '\n'

						// Get space (minus \n) on cursor left
						var leftSpace = this.sourceFromLine(lineNode).substr(0, leftLength).toString().match(/^\s*/).toString().replace(/(\r|\n)/g, '').toString()
						
						// Add a tab if we're pressing enter AFTER a brace
						if (this.sourceFromLine(lineNode).match(/^\s*\{/) && !rightText.match(/\{/))	leftSpace += '	'

						// New node
						var n = document.createElement('DIV')
						n.className = 'line'
						var text = leftSpace + rightText
						text = this.replaceTabsInLine(text)
						n.innerHTML = text
						// Add new node right after current line
						lineNode.insertAdjacentElement('afterEnd', n)


						// Cut current line content
						var text = this.sourceFromLine(lineNode).substr(0, leftLength) + '\n'
						lineNode.innerHTML = this.replaceTabsInLine(text)


						sel.setPosition(n, 0)
						if (leftSpace.length)
						{
							for (var i=0; i<leftSpace.length; i++)
								sel.modify('move', 'right', 'character')
						}
					}
					else
					{
						// Nothing to do with a range as no newline is inserted.
					}
					
				}
				
				/*
					If Range selection, save all lines
				*/
			}
			
			
			//
			// post key down
			// 
			CCp.postKeydown = function ()
			{
				this.dumpUndoStack()
				
				var sel = getSelection()



				var self = this
				var str = ''

				this.birdViewNode.innerHTML = this.keydownStr
				this.birdViewNode.innerHTML += str
				
				// Check editingForSure
				var lineCount = this.lineCount()
				var lineCountChanged = lineCount != this.previousLineCount
				str += '<br>lineCountChanged=' + (lineCountChanged  ? ('<b>YES</b> ' + this.previousLineCount + '->' + lineCount) : 'no')

				// Check if linetext changed
				var lineTextChanged = false
				if (sel.baseNode)
				{
					var lineText 		= this.lineNodeFromNode(sel.baseNode).innerText
				
					lineTextChanged = lineText != this.previousLineText
					str += '<br>lineTextChanged=' + (lineTextChanged ? '<b>YES</b>' : 'no')
				}
				str += '<br>Selection is range=' + (sel.type == 'Range' ? '<b>YES</b>' : 'no')
				
				var type = 'moving'
				if (!this.movingForSure && (lineCountChanged || lineTextChanged)) type = '<b style="color: red; font-size: 150%">editing</b>'
				str += '<br>TYPE=' + type
				
//				str += '<hr><pre>' + dumpSelection()

				var s = this.selectionAsLineAndOffset()
				str += '<br>line=' + s.line
				str += '<br>lineCount=' + this.lineCount()

				
				this.birdViewNode.innerHTML += str
				
				
				this.previousLineCount = lineCount
				
				
				
				//
				//
				// 
				// 
				// 
				// 
				// 
				
				this.highlightSelectedLine()
//				var lineNumber = lineNumberFromNode(sel.baseNode)
				
				//	Maybe 	* deleted everything	-> just a text node left, or a br
				//			* backspace or delete	-> two spans on the same line					
				var line = this.lineNodeFromNode(sel.baseNode)
				if (!line)
				{
					// Will be called even after ALT-L (select address bar), check if we have a selection
					if (sel.type == 'None')	return

					// Load and select
					this.loadText(this.editorNode.innerText)
					sel.setPosition(this.editorNode.firstChild.firstChild, 0)
					var line = this.lineNodeFromNode(sel.baseNode)
				}
				
//				if (previouslySelectedLine)	previouslySelectedLine.className = 'line'
//				previouslySelectedLine = null
				
				var lineCount2			= this.editorNode.childNodes.length
				var currentLineNumber2 	= this.lineNumberFromNode(sel.baseNode)
				
				var currentLineText2 	= this.sourceFromLine(this.lineNodeFromNode(sel.baseNode))

				

//alert(currentLineText + '\n\n' + currentLineText2 + '\n\n\nn1=' + currentLineNumber + '\nn2=' + currentLineNumber2)
				
				var mode = 'selecting'
				var moved = lineCount2 != lineCount
				var lineChanged = !(currentLineNumber2 == currentLineNumber && currentLineText2 == currentLineText)
				if (moved || lineChanged)
					mode = 'typing'
					
				
				// Custom handling for having inserted specific characters, eg closing a brace : remove one tab in front of it
				if (mode == 'typing' && currentLineNumber == currentLineNumber2 && currentLineText.length+1 == currentLineText2.length)
				{
					var s = this.selectionAsLineAndOffset()
					var addedChar = currentLineText2.charAt(s.offset-1)

					// If closed a block, remove a tab in front of it
					if (addedChar == '}' && currentLineText2.match(/\t\}/))
					{
						this.pushCaretSelection()
						var text = currentLineText2.replace(/\t\}/, '}')
						line.innerText = text
						this.selectionStack[this.selectionStack.length-1].offset--
						this.popCaretSelection()
					}
				}
				
				if (mode == 'typing')	this.topUndoAction().isBlank = false

//				if (mode != 'typing')	return



				
//				if (sel.type == 'Range') alert('HIGHLIGHT WITH RANGE SELECTION')
				if (sel.type == 'Range') return
				this.colorCode()
			}
			
			
			
			CCp.undo = function ()
			{
				
			}
			
			
			CCp.highlightSelectedLine = function ()
			{
				var sel		= getSelection()
				var line	= this.lineNodeFromNode(sel.baseNode)
				if (!line)	return
				this.selectedLine.style.top		= line.offsetTop + 'px'
				this.selectedLine.style.height	= (line.offsetHeight+1) + 'px'

				var s = this.textPositionAsLineAndOffset()
				this.selectedLinePosition.innerHTML = (s.line+1) + ',' + (s.offset+1)
			}
			
			CCp.copy = function ()
			{
				alert('handle copy')
			}
			CCp.cut = function ()
			{
				alert('handle cut')
			}
			//
			// If we could reenter after Webkit's right after paste, we'd just have to fixup existing text
			// 
			// http://developer.apple.com/documentation/AppleApplications/Conceptual/SafariJSProgTopics/Tasks/CopyAndPaste.html#//apple_ref/doc/uid/30001234
			CCp.paste = function ()
			{
				var sel = getSelection()
				var clipboard = event.clipboardData
				clipboard.clearData()

				// We'll handle paste as we need to create one DIV per line
				event.preventDefault()
				// Caret postion
				var caret = this.rangeSelectionAsLineAndOffset().base

				// Delete selection if we have a range
				if (sel.type == 'Range')
				{
					sel.deleteFromDocument()
					sel.collapseToStart()
				}

				var text = clipboard.getData('Text')
				var lines = text.split('\n')

				// Split line according to caret : prefix (caret) suffix
				var ll		= this.nodeFromLineNumber(caret.line)
				var text	= this.sourceFromLine(ll)
				var prefix	= text.substr(0, caret.offset)
				var suffix	= text.substr(caret.offset)

				// The first line becomes prefix + first line of selection (+ suffix in one line pastes)
				ll.innerText		= prefix + lines[0]
				var currentLine		= ll
				var newLineForCaret	= caret.line

				// Each of the remaining lines gets its own html node
				for (var i=1; i<lines.length; i++)
				{
					var n2 = document.createElement('DIV')
					n2.className = ll.className
					n2.innerText = lines[i]
//					if (i < lines.length-1) n2.innerText += '\n'
//					else					n2.innerText += suffix
					currentLine.innerText += '\n'
					currentLine.insertAdjacentElement('afterEnd', n2)
					currentLine = n2
					newLineForCaret++
				}
				// Append suffix to last line
				var newOffsetForCaret = this.sourceFromLine(currentLine).length
				currentLine.innerText += suffix
				
				this.setSelectionAsLineAndOffset(newLineForCaret, newOffsetForCaret)
				this.colorCode()
			}


			//
			// Init a code colorer and load some text in it
			//
			var cc = new CodeColorer(	document.getElementById('coloredCode'), 
										document.getElementById('coloredCodeContainer'), 
										document.getElementById('birdView'))
			
			var textarea = document.getElementsByTagName('TEXTAREA')[0]


			cc.loadText(textarea.value)

//			var JSLINT = JSLintWithLogs({})
//			cc.loadText(JSLINT.toString())
			
			
			function	undo()
			{
				cc.undo()
			}
			function	redo()
			{
				cc.redo()
			}



			function	focusHighlighted()
			{
				cc.editorNode.focus()

				var s = getSelection()
				s.collapseToStart()
				cc.colorCode()
//				cc.showSelectedLine()
			}
			setTimeout(focusHighlighted, 10)
			
/*			
			function	clearDumps()
			{
				document.getElementById('dump2').innerHTML = ' '
				document.getElementById('dump3').innerHTML = ' '
				document.getElementById('dump4').innerHTML = ' '
				document.getElementById('dump5').innerHTML = ' '
				document.getElementById('dump6').innerHTML = ' '
			}
*/
			function ds()
			{
				document.getElementById('selectionDump').innerHTML = getTickCount() + '<br>' + dumpSelection()
				cc.pushSelection2()
				cc.popSelection2()
				
				var sel = getSelection()
				function	saveSelectionPiece(name)
				{
					var node = sel[name + 'Node']
					var offset = sel[name + 'Offset']
					var line = cc.lineNumberFromNode()
					var o1 = cc.lineAndOffsetFromNodeAndOffset(node, offset)
					
					var o2 = cc.nodeAndOffsetFromLineAndOffset(o1.line, o1.offset, o1.isDiv)
					
					document.getElementById('selectionDump').innerHTML += name + '(RAW)=' + node + ',' + offset + '<br>'
					document.getElementById('selectionDump').innerHTML += name + '(lineOffset)=' + o1.line + ',' + o1.offset + ' '
					document.getElementById('selectionDump').innerHTML += (o1.isDiv?'<b style="background-color: lime; color: red">DIV</b>':'') + '<br>'
					document.getElementById('selectionDump').innerHTML += name + '(nodeOffset)=' + o2.node + ',' + o2.offset + '<br>'
					var nodeEQ = (o2.node == node)
					var offsetEQ = (o2.offset == offset)
					document.getElementById('selectionDump').innerHTML += 'nodeEQ=' + nodeEQ + ' offsetEQ=' + offsetEQ + ' '
					document.getElementById('selectionDump').innerHTML += (nodeEQ && offsetEQ) ? '<span style="color: lime">OK</span>' : '<span style="color: red">NO</span>'
					document.getElementById('selectionDump').innerHTML += '<br>'
//					return { lineNumber : line, isDIV : isDIV, }
					return o1
				}
				var saved = {}
				saved.base		= saveSelectionPiece('base')
				saved.anchor	= saveSelectionPiece('anchor')
				saved.extent	= saveSelectionPiece('extent')
				saved.focus		= saveSelectionPiece('focus')
/*				
				var n = document.getElementById('coloredCode').firstChild
				sel.setBaseAndExtent(n, 0, n, 0)

				var base = cc.nodeAndOffsetFromLineAndOffset(saved.base.line, saved.base.offset)
				var extent = cc.nodeAndOffsetFromLineAndOffset(saved.extent.line, saved.extent.offset)
				sel.setBaseAndExtent(base.node, base.offset, extent.node, extent.offset)
*/

/*
				restoreSelectionPiece(name, o1)
				{
					var o2 = cc.nodeAndOffsetFromLineAndOffset(o1.line, o1.offset, o1.isDiv)
					sel[name + 'Node'] = o2.node
					sel[name + 'Offset'] = o2.offset
				}
				restoreSelectionPiece('base', saved.base)
				restoreSelectionPiece('anchor', saved.anchor)
				restoreSelectionPiece('extent', saved.extent)
				restoreSelectionPiece('extent', saved.extent)
*/				
				
//					dumpSelectionNode('base')
//					dumpSelectionNode('anchor')
//					dumpSelectionNode('extent')
//					dumpSelectionNode('focus')
				
				document.getElementById('selectionDump').innerHTML += '<br>PUSH / POP 2<br><br>'
				document.getElementById('selectionDump').innerHTML += getTickCount() + '<br>' + dumpSelection()
			}
//			setInterval(ds, 1000)
//			setTimeout(ds, 3000)

		</script>

<pre>
	<h3 style='color: red; margin-top: -30px; font-weight: normal'>
* highlight happens on caret move : left/right + up/down on overflowing lines
* try linting src, ie lines.join('')
* when option/suppr, might delete an endline. need to restore it
	deleted newline : 
		* enter to create a line
		* new tab
		* type some text
		* option suppr
		-> no newline
* check displayRawText([])
* cmd-a, delete all, type -> newline disappears
* on typing : should only show upstream errors as collapsed bubbles, opening after typing a bit 
	OR don't padd top errors, just bubble them up with zIndex, no padding (downwards arrow)
* mousedown on DIV with one line : focus last line

	everything on the same line : white-space: wrap
	retour lign : white-space: pre-wrap

* DO NOT LINT below a line where we typed ?
* markdown : allow custom tags like &lt;ObjC&gt;NSView&lt;/ObjC&gt;, linking to google "innerText reference" site:apple.com, lucky=yes
* css classes to highlight return (eg add an arrow), continue to indicate where the loop is continuing, break ... ?
* BUG : ctrl+o
	MOVE
		ctrl+A line start
		ctrl+E line end
		ctrl+T invert pre and post caret chars, advance caret
		ctrl+P move to end of previous line
		ctrl+F advance caret
		ctrl+B backwards caret
		ctrl+N move to next line
	EDIT
		ctrl+Y yank - undelete last thing deleted
		ctrl+O insert line in place
		ctrl+Q ?????
		ctrl+D front delete
		ctrl+H backwards delete
		ctrl+K delete to end of line
		
* before undo, or after move, call commitTypingTransaction() to save undo state		
* handle oncut
* keyboard selection from right to left seems to fail
	-> my fault, disabling JS works

* base, extent, anchor, focus
	when dragging to a range
		base, anchor mark selection start
		extent, focus mark selection end
	click
		all 4 to the same value : caret
	double click
		base, extent keep caret value
		anchor, focus move to highlight the word
			anchor is where selection starts from : when using shift, it stays fixed to extend selection
			focus is where selection expands from : when using shift, it moves to extend selection

* detect insertion by Character Viewer
* undo start can be a line deletion !

* bug : saving top deleted line too many times ! each time caret come on it
	* go to line 3 'var apps'
	* backspace to previous line : SAVES LINE
	* enter
	* backspace to previous line again : SAVES LINE AGAIN !
	
</body>
</html>
